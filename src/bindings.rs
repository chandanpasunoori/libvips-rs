/* automatically generated by rust-bindgen 0.69.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const G_MINSHORT: i32 = -32768;
pub const G_MAXSHORT: u32 = 32767;
pub const G_MAXUSHORT: u32 = 65535;
pub const G_MININT: i32 = -2147483648;
pub const G_MAXINT: u32 = 2147483647;
pub const G_MAXUINT: u32 = 4294967295;
pub const G_MINLONG: i64 = -9223372036854775808;
pub const G_MAXLONG: u64 = 9223372036854775807;
pub const G_MAXULONG: i32 = -1;
pub const G_GINT16_MODIFIER: &[u8; 2] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GINT64_FORMAT: &[u8; 4] = b"lli\0";
pub const G_GUINT64_FORMAT: &[u8; 4] = b"llu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSIZE_FORMAT: &[u8; 3] = b"lu\0";
pub const G_GSSIZE_FORMAT: &[u8; 3] = b"li\0";
pub const G_MAXSIZE: i32 = -1;
pub const G_MINSSIZE: i64 = -9223372036854775808;
pub const G_MAXSSIZE: u64 = 9223372036854775807;
pub const G_GOFFSET_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GOFFSET_FORMAT: &[u8; 4] = b"lli\0";
pub const G_POLLFD_FORMAT: &[u8; 3] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINTPTR_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINTPTR_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 78;
pub const GLIB_MICRO_VERSION: u32 = 4;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_PID_FORMAT: &[u8; 2] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 30;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2] = b":\0";
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __VISIONOS_1_0: u32 = 10000;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140200;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const __DTF_SKIPREAD: u32 = 16;
pub const __DTF_ATEND: u32 = 32;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_STR_DELIMITERS: &[u8; 8] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11] = b"0123456789\0";
pub const G_CSET_LATINC : & [u8 ; 31] = b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0" ;
pub const G_CSET_LATINS : & [u8 ; 33] = b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0" ;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 10420224;
pub const SF_SETTABLE: u32 = 1073676288;
pub const SF_SYNTHETIC: u32 = 3221225472;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_FIRMLINK: u32 = 8388608;
pub const SF_DATALESS: u32 = 1073741824;
pub const EF_MAY_SHARE_BLOCKS: u32 = 1;
pub const EF_NO_XATTRS: u32 = 2;
pub const EF_IS_SYNC_ROOT: u32 = 4;
pub const EF_IS_PURGEABLE: u32 = 8;
pub const EF_IS_SPARSE: u32 = 16;
pub const EF_IS_SYNTHETIC: u32 = 32;
pub const EF_SHARES_ALL_BLOCKS: u32 = 64;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const G_TYPE_FUNDAMENTAL_SHIFT: u32 = 2;
pub const G_TYPE_FUNDAMENTAL_MAX: u32 = 1020;
pub const G_TYPE_RESERVED_GLIB_FIRST: u32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: u32 = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: u32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: u32 = 48;
pub const G_TYPE_RESERVED_USER_FIRST: u32 = 49;
pub const G_VALUE_NOCOPY_CONTENTS: u32 = 134217728;
pub const G_PARAM_MASK: u32 = 255;
pub const G_PARAM_USER_SHIFT: u32 = 8;
pub const G_SIGNAL_FLAGS_MASK: u32 = 511;
pub const G_SIGNAL_MATCH_MASK: u32 = 63;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: u32 = 200112;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME: &[u8; 21] = b"gio-debug-controller\0";
pub const G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: &[u8; 12] = b"unix-device\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE: &[u8; 15] = b"standard::type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: &[u8; 20] = b"standard::is-hidden\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP: &[u8; 20] = b"standard::is-backup\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: &[u8; 21] = b"standard::is-symlink\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: &[u8; 21] = b"standard::is-virtual\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: &[u8; 22] = b"standard::is-volatile\0";
pub const G_FILE_ATTRIBUTE_STANDARD_NAME: &[u8; 15] = b"standard::name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: &[u8; 23] = b"standard::display-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME: &[u8; 20] = b"standard::edit-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME: &[u8; 20] = b"standard::copy-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION: &[u8; 22] = b"standard::description\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ICON: &[u8; 15] = b"standard::icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: &[u8; 24] = b"standard::symbolic-icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: &[u8; 23] = b"standard::content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: &[u8; 28] = b"standard::fast-content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE: &[u8; 15] = b"standard::size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: &[u8; 25] = b"standard::allocated-size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: &[u8; 25] = b"standard::symlink-target\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI: &[u8; 21] = b"standard::target-uri\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER: &[u8; 21] = b"standard::sort-order\0";
pub const G_FILE_ATTRIBUTE_ETAG_VALUE: &[u8; 12] = b"etag::value\0";
pub const G_FILE_ATTRIBUTE_ID_FILE: &[u8; 9] = b"id::file\0";
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM: &[u8; 15] = b"id::filesystem\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ: &[u8; 17] = b"access::can-read\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE: &[u8; 18] = b"access::can-write\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: &[u8; 20] = b"access::can-execute\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE: &[u8; 19] = b"access::can-delete\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH: &[u8; 18] = b"access::can-trash\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME: &[u8; 19] = b"access::can-rename\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: &[u8; 21] = b"mountable::can-mount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: &[u8; 23] = b"mountable::can-unmount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: &[u8; 21] = b"mountable::can-eject\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: &[u8; 23] = b"mountable::unix-device\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: &[u8; 28] = b"mountable::unix-device-file\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: &[u8; 19] = b"mountable::hal-udi\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START: &[u8; 21] = b"mountable::can-start\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: &[u8; 30] =
    b"mountable::can-start-degraded\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: &[u8; 20] = b"mountable::can-stop\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: &[u8; 27] = b"mountable::start-stop-type\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: &[u8; 20] = b"mountable::can-poll\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: &[u8; 36] =
    b"mountable::is-media-check-automatic\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED: &[u8; 15] = b"time::modified\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC: &[u8; 20] = b"time::modified-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: &[u8; 20] = b"time::modified-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS: &[u8; 13] = b"time::access\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC: &[u8; 18] = b"time::access-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC: &[u8; 18] = b"time::access-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED: &[u8; 14] = b"time::changed\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC: &[u8; 19] = b"time::changed-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_NSEC: &[u8; 19] = b"time::changed-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED: &[u8; 14] = b"time::created\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC: &[u8; 19] = b"time::created-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_NSEC: &[u8; 19] = b"time::created-nsec\0";
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE: &[u8; 13] = b"unix::device\0";
pub const G_FILE_ATTRIBUTE_UNIX_INODE: &[u8; 12] = b"unix::inode\0";
pub const G_FILE_ATTRIBUTE_UNIX_MODE: &[u8; 11] = b"unix::mode\0";
pub const G_FILE_ATTRIBUTE_UNIX_NLINK: &[u8; 12] = b"unix::nlink\0";
pub const G_FILE_ATTRIBUTE_UNIX_UID: &[u8; 10] = b"unix::uid\0";
pub const G_FILE_ATTRIBUTE_UNIX_GID: &[u8; 10] = b"unix::gid\0";
pub const G_FILE_ATTRIBUTE_UNIX_RDEV: &[u8; 11] = b"unix::rdev\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: &[u8; 17] = b"unix::block-size\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS: &[u8; 13] = b"unix::blocks\0";
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: &[u8; 20] = b"unix::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE: &[u8; 16] = b"dos::is-archive\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM: &[u8; 15] = b"dos::is-system\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: &[u8; 19] = b"dos::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: &[u8; 23] = b"dos::reparse-point-tag\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER: &[u8; 12] = b"owner::user\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL: &[u8; 17] = b"owner::user-real\0";
pub const G_FILE_ATTRIBUTE_OWNER_GROUP: &[u8; 13] = b"owner::group\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH: &[u8; 16] = b"thumbnail::path\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED: &[u8; 18] = b"thumbnail::failed\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: &[u8; 20] = b"thumbnail::is-valid\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: &[u8; 23] = b"thumbnail::path-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: &[u8; 25] = b"thumbnail::failed-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: &[u8; 27] = b"thumbnail::is-valid-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: &[u8; 22] = b"thumbnail::path-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: &[u8; 24] = b"thumbnail::failed-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: &[u8; 26] = b"thumbnail::is-valid-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: &[u8; 23] = b"thumbnail::path-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: &[u8; 25] = b"thumbnail::failed-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: &[u8; 27] = b"thumbnail::is-valid-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: &[u8; 24] = b"thumbnail::path-xxlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: &[u8; 26] = b"thumbnail::failed-xxlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: &[u8; 28] = b"thumbnail::is-valid-xxlarge\0";
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON: &[u8; 14] = b"preview::icon\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE: &[u8; 17] = b"filesystem::size\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE: &[u8; 17] = b"filesystem::free\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED: &[u8; 17] = b"filesystem::used\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE: &[u8; 17] = b"filesystem::type\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY: &[u8; 21] = b"filesystem::readonly\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: &[u8; 24] = b"filesystem::use-preview\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE: &[u8; 19] = b"filesystem::remote\0";
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND: &[u8; 14] = b"gvfs::backend\0";
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT: &[u8; 17] = b"selinux::context\0";
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT: &[u8; 18] = b"trash::item-count\0";
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH: &[u8; 17] = b"trash::orig-path\0";
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE: &[u8; 21] = b"trash::deletion-date\0";
pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED: &[u8; 17] = b"recent::modified\0";
pub const G_MEMORY_MONITOR_EXTENSION_POINT_NAME: &[u8; 19] = b"gio-memory-monitor\0";
pub const G_MENU_ATTRIBUTE_ACTION: &[u8; 7] = b"action\0";
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE: &[u8; 17] = b"action-namespace\0";
pub const G_MENU_ATTRIBUTE_TARGET: &[u8; 7] = b"target\0";
pub const G_MENU_ATTRIBUTE_LABEL: &[u8; 6] = b"label\0";
pub const G_MENU_ATTRIBUTE_ICON: &[u8; 5] = b"icon\0";
pub const G_MENU_LINK_SUBMENU: &[u8; 8] = b"submenu\0";
pub const G_MENU_LINK_SECTION: &[u8; 8] = b"section\0";
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME: &[u8; 19] = b"gio-volume-monitor\0";
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: &[u8; 26] = b"gio-native-volume-monitor\0";
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME: &[u8; 20] = b"gio-network-monitor\0";
pub const G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: &[u8; 26] = b"gio-power-profile-monitor\0";
pub const G_PROXY_EXTENSION_POINT_NAME: &[u8; 10] = b"gio-proxy\0";
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME: &[u8; 19] = b"gio-proxy-resolver\0";
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME: &[u8; 16] = b"gio-tls-backend\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: &[u8; 18] = b"1.3.6.1.5.5.7.3.1\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: &[u8; 18] = b"1.3.6.1.5.5.7.3.2\0";
pub const G_VFS_EXTENSION_POINT_NAME: &[u8; 8] = b"gio-vfs\0";
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: &[u8; 12] = b"unix-device\0";
pub const G_VOLUME_IDENTIFIER_KIND_LABEL: &[u8; 6] = b"label\0";
pub const G_VOLUME_IDENTIFIER_KIND_UUID: &[u8; 5] = b"uuid\0";
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT: &[u8; 10] = b"nfs-mount\0";
pub const G_VOLUME_IDENTIFIER_KIND_CLASS: &[u8; 6] = b"class\0";
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const VIPS_PI: f64 = 3.141592653589793;
pub const VIPS_PATH_MAX: u32 = 4096;
pub const VIPS_TARGET_BUFFER_SIZE: u32 = 8500;
pub const VIPS_TARGET_CUSTOM_BUFFER_SIZE: u32 = 4096;
pub const VIPS_SBUF_BUFFER_SIZE: u32 = 4096;
pub const VIPS_VERSION: &[u8; 7] = b"8.15.1\0";
pub const VIPS_VERSION_STRING: &[u8; 7] = b"8.15.1\0";
pub const VIPS_MAJOR_VERSION: u32 = 8;
pub const VIPS_MINOR_VERSION: u32 = 15;
pub const VIPS_MICRO_VERSION: u32 = 1;
pub const VIPS_LIBRARY_CURRENT: u32 = 59;
pub const VIPS_LIBRARY_REVISION: u32 = 1;
pub const VIPS_LIBRARY_AGE: u32 = 17;
pub const VIPS_CONFIG : & [u8 ; 1291] = b"enable debug: false\nenable deprecated: true\nenable modules: true\nenable cplusplus: true\nenable RAD load/save: true\nenable Analyze7 load/save: true\nenable PPM load/save: true\nenable GIF load: true\nuse fftw for FFTs: true\nSIMD support with highway: true\naccelerate loops with ORC: false\nICC profile support with lcms: true\nzlib: true\ntext rendering with pangocairo: true\nfont file support with fontconfig: true\nEXIF metadata support with libexif: true\nJPEG load/save with libjpeg: true\nJXL load/save with libjxl: true (dynamic module: true)\nJPEG2000 load/save with OpenJPEG: true\nPNG load/save with libspng: true\nPNG load/save with libpng: false\nselected quantisation package: imagequant\nTIFF load/save with libtiff: true\nimage pyramid save with libarchive: true\nHEIC/AVIF load/save with libheif: true (dynamic module: true)\nWebP load/save with libwebp: true\nPDF load with PDFium: false\nPDF load with poppler-glib: true (dynamic module: true)\nSVG load with librsvg: true\nEXR load with OpenEXR: true\nOpenSlide load: true (dynamic module: true)\nMatlab load with libmatio: true\nNIfTI load/save with niftiio: false\nFITS load/save with cfitsio: true\nGIF save with cgif: true\nselected Magick package: MagickCore (dynamic module: true)\nMagick API version: magick7\nMagick load: true\nMagick save: true\0" ;
pub const VIPS_ENABLE_DEPRECATED: u32 = 1;
pub const VIPS_SPARE: u32 = 8;
pub const VIPS__WINDOW_MARGIN_PIXELS: u32 = 128;
pub const VIPS__WINDOW_MARGIN_BYTES: u32 = 10485760;
pub const VIPS_SIZEOF_HEADER: u32 = 64;
pub const VIPS__TILE_WIDTH: u32 = 128;
pub const VIPS__TILE_HEIGHT: u32 = 128;
pub const VIPS__THINSTRIP_HEIGHT: u32 = 1;
pub const VIPS__FATSTRIP_HEIGHT: u32 = 16;
pub const VIPS_MAGIC_INTEL: u32 = 3064394248;
pub const VIPS_MAGIC_SPARC: u32 = 150120118;
pub const VIPS_MAX_COORD: u32 = 10000000;
pub const VIPS_TRANSFORM_SHIFT: u32 = 6;
pub const VIPS_TRANSFORM_SCALE: u32 = 64;
pub const VIPS_INTERPOLATE_SHIFT: u32 = 12;
pub const VIPS_INTERPOLATE_SCALE: u32 = 4096;
pub const VIPS_META_EXIF_NAME: &[u8; 10] = b"exif-data\0";
pub const VIPS_META_XMP_NAME: &[u8; 9] = b"xmp-data\0";
pub const VIPS_META_IPTC_NAME: &[u8; 10] = b"iptc-data\0";
pub const VIPS_META_PHOTOSHOP_NAME: &[u8; 15] = b"photoshop-data\0";
pub const VIPS_META_ICC_NAME: &[u8; 17] = b"icc-profile-data\0";
pub const VIPS_META_IMAGEDESCRIPTION: &[u8; 18] = b"image-description\0";
pub const VIPS_META_RESOLUTION_UNIT: &[u8; 16] = b"resolution-unit\0";
pub const VIPS_META_BITS_PER_SAMPLE: &[u8; 16] = b"bits-per-sample\0";
pub const VIPS_META_LOADER: &[u8; 12] = b"vips-loader\0";
pub const VIPS_META_SEQUENTIAL: &[u8; 16] = b"vips-sequential\0";
pub const VIPS_META_ORIENTATION: &[u8; 12] = b"orientation\0";
pub const VIPS_META_PAGE_HEIGHT: &[u8; 12] = b"page-height\0";
pub const VIPS_META_N_PAGES: &[u8; 8] = b"n-pages\0";
pub const VIPS_META_N_SUBIFDS: &[u8; 10] = b"n-subifds\0";
pub const VIPS_META_CONCURRENCY: &[u8; 12] = b"concurrency\0";
pub const VIPS_D93_X0: f64 = 89.74;
pub const VIPS_D93_Y0: f64 = 100.0;
pub const VIPS_D93_Z0: f64 = 130.77;
pub const VIPS_D75_X0: f64 = 94.9682;
pub const VIPS_D75_Y0: f64 = 100.0;
pub const VIPS_D75_Z0: f64 = 122.571;
pub const VIPS_D65_X0: f64 = 95.047;
pub const VIPS_D65_Y0: f64 = 100.0;
pub const VIPS_D65_Z0: f64 = 108.8827;
pub const VIPS_D55_X0: f64 = 95.6831;
pub const VIPS_D55_Y0: f64 = 100.0;
pub const VIPS_D55_Z0: f64 = 92.0871;
pub const VIPS_D50_X0: f64 = 96.425;
pub const VIPS_D50_Y0: f64 = 100.0;
pub const VIPS_D50_Z0: f64 = 82.468;
pub const VIPS_A_X0: f64 = 109.8503;
pub const VIPS_A_Y0: f64 = 100.0;
pub const VIPS_A_Z0: f64 = 35.5849;
pub const VIPS_B_X0: f64 = 99.072;
pub const VIPS_B_Y0: f64 = 100.0;
pub const VIPS_B_Z0: f64 = 85.223;
pub const VIPS_C_X0: f64 = 98.07;
pub const VIPS_C_Y0: f64 = 100.0;
pub const VIPS_C_Z0: f64 = 118.23;
pub const VIPS_E_X0: f64 = 100.0;
pub const VIPS_E_Y0: f64 = 100.0;
pub const VIPS_E_Z0: f64 = 100.0;
pub const VIPS_D3250_X0: f64 = 105.659;
pub const VIPS_D3250_Y0: f64 = 100.0;
pub const VIPS_D3250_Z0: f64 = 45.8501;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_longlong;
pub type guint64 = ::std::os::raw::c_ulonglong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t {{ union }}")
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
#[doc = " GEqualFuncFull:\n @a: a value\n @b: a value to compare with\n @user_data: user data provided by the caller\n\n Specifies the type of a function used to test two values for\n equality. The function should return %TRUE if both values are equal\n and %FALSE otherwise.\n\n This is a version of #GEqualFunc which provides a @user_data closure from\n the caller.\n\n Returns: %TRUE if @a = @b; %FALSE otherwise\n Since: 2.74"]
pub type GEqualFuncFull = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gboolean,
>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:\n @data: a data pointer\n\n Declares a type of function which takes an arbitrary\n data pointer argument and has no return value. It is\n not currently used in GLib or GTK."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:\n @str: the untranslated string\n @data: user data specified when installing the function, e.g.\n  in g_option_group_set_translate_func()\n\n The type of functions which are used to translate user-visible\n strings, for <option>--help</option> output.\n\n Returns: a translation of the string for the current locale.\n  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    const UNINIT: ::std::mem::MaybeUninit<_GFloatIEEE754> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
impl ::std::fmt::Debug for _GFloatIEEE754 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GFloatIEEE754 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    const UNINIT: ::std::mem::MaybeUninit<_GDoubleIEEE754> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
impl ::std::fmt::Debug for _GDoubleIEEE754 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GDoubleIEEE754 {{ union }}")
    }
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    const UNINIT: ::std::mem::MaybeUninit<_GTimeVal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: size_t,
        __little: *const ::std::os::raw::c_void,
        __little_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GByteArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GPtrArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_new_take(
        data: gpointer,
        len: gsize,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_new_take_zero_terminated(
        data: gpointer,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_take(
        data: *mut gpointer,
        len: gsize,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_from_array(
        data: *mut gpointer,
        len: gsize,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_take_null_terminated(
        data: *mut gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_from_null_terminated_array(
        data: *mut gpointer,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_sort_values(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_values_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
        preval: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_exchange(
        atomic: *mut ::std::os::raw::c_void,
        newval: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    const UNINIT: ::std::mem::MaybeUninit<_GError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " GErrorInitFunc:\n @error: extended error\n\n Specifies the type of function which is called just after an\n extended error instance is created and its fields filled. It should\n only initialize the fields in the private data, which can be\n received with the generated `*_get_private()` function.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorInitFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
#[doc = " GErrorCopyFunc:\n @src_error: source extended error\n @dest_error: destination extended error\n\n Specifies the type of function which is called when an extended\n error instance is copied. It is passed the pointer to the\n destination error and source error, and should copy only the fields\n of the private data from @src_error to @dest_error.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @src_error and\n @dest_error.\n\n Since: 2.68"]
pub type GErrorCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
#[doc = " GErrorClearFunc:\n @error: extended error to clear\n\n Specifies the type of function which is called when an extended\n error instance is freed. It is passed the error pointer about to be\n freed, and should free the error's private data fields.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorClearFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
extern "C" {
    pub fn g_error_domain_register_static(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
extern "C" {
    pub fn g_error_domain_register(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: va_list,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
}
extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_state_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:\n @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory\n @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory\n @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory\n @G_USER_DIRECTORY_MUSIC: the user's Music directory\n @G_USER_DIRECTORY_PICTURES: the user's Pictures directory\n @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory\n @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory\n @G_USER_DIRECTORY_VIDEOS: the user's Movies directory\n @G_USER_N_DIRECTORIES: the number of enum values\n\n These are logical ids for special directories which are defined\n depending on the platform used. You should use g_get_user_special_dir()\n to retrieve the full path associated to the logical id.\n\n The #GUserDirectory enumeration can be extended at later date. Not\n every platform has a directory for every logical id in this\n enumeration.\n\n Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:\n @key: the string\n @value: the flag\n\n Associates a string with a bit flag.\n Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugKey> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:\n\n Declares a type of function which takes no arguments\n and has no return value. It is used to specify the type\n function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl ::std::fmt::Debug for sigval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "sigval {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
impl ::std::fmt::Debug for sigevent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "sigevent {{ sigev_notify: {:?}, sigev_signo: {:?}, sigev_value: {:?}, sigev_notify_function: {:?}, sigev_notify_attributes: {:?} }}" , self . sigev_notify , self . sigev_signo , self . sigev_value , self . sigev_notify_function , self . sigev_notify_attributes)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
impl ::std::fmt::Debug for __siginfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__siginfo {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, si_band: {:?}, __pad: {:?} }}" , self . si_signo , self . si_errno , self . si_code , self . si_pid , self . si_uid , self . si_status , self . si_addr , self . si_value , self . si_band , self . __pad)
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
impl ::std::fmt::Debug for __sigaction_u {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__sigaction_u {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
impl ::std::fmt::Debug for __sigaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "__sigaction {{ __sigaction_u: {:?}, sa_tramp: {:?}, sa_mask: {:?}, sa_flags: {:?} }}",
            self.__sigaction_u, self.sa_tramp, self.sa_mask, self.sa_flags
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
impl ::std::fmt::Debug for sigaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "sigaction {{ __sigaction_u: {:?}, sa_mask: {:?}, sa_flags: {:?} }}",
            self.__sigaction_u, self.sa_mask, self.sa_flags
        )
    }
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_reserved: [u64; 14usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
impl ::std::fmt::Debug for wait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "wait {{ union }}")
    }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn __builtin_alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: size_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: size_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: size_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: size_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: size_t,
        size: size_t,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
impl ::std::fmt::Debug for _GMutex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GMutex {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    const UNINIT: ::std::mem::MaybeUninit<_GRWLock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    const UNINIT: ::std::mem::MaybeUninit<_GCond> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    const UNINIT: ::std::mem::MaybeUninit<_GPrivate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).future) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    const UNINIT: ::std::mem::MaybeUninit<_GOnce> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer) -> !;
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:\n\n Opaque type. See g_mutex_locker_new() for details.\n Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:\n\n Opaque type. See g_rec_mutex_locker_new() for details.\n Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:\n\n Opaque type. See g_rw_lock_writer_locker_new() for details.\n Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:\n\n Opaque type. See g_rw_lock_reader_locker_new() for details.\n Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type pthread_t = __darwin_pthread_t;
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:\n @G_TIME_TYPE_STANDARD: the time is in local standard time\n @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time\n @G_TIME_TYPE_UNIVERSAL: the time is in UTC\n\n Disambiguates a given time in two ways.\n\n First, specifies if the given time is in universal or local time.\n\n Second, if the time is in local time, specifies if it is local\n standard time or local daylight time.  This is important for the case\n where the same local time occurs twice (during daylight savings time\n transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n An opaque structure that represents a date and time, including a time zone.\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:\n @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed\n @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found\n @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did\n     not register a bookmark\n @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found\n @G_BOOKMARK_FILE_ERROR_READ: document was ill formed\n @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was\n     in an unknown encoding\n @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing\n @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found\n\n Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:\n\n An opaque data structure representing a set of bookmarks."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_copy(bookmark: *mut GBookmarkFile) -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        added: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        modified: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        visited: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:\n @G_CHECKSUM_MD5: Use the MD5 hashing algorithm\n @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm\n @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm\n @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)\n @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)\n\n The hashing algorithm to be used by #GChecksum when performing the\n digest of some data.\n\n Note that the #GChecksumType enumeration may be extended at a later\n date to include new hashing algorithm types.\n\n Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:\n\n An opaque structure representing a checksumming operation.\n\n To create a new GChecksum, use g_checksum_new(). To free\n a GChecksum, use g_checksum_free().\n\n Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:\n @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character\n     sets is not supported.\n @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;\n    or the character sequence could not be represented in the target\n    character set.\n @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.\n @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.\n @G_CONVERT_ERROR_BAD_URI: URI is invalid.\n @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.\n @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40\n @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in\n     conversion output where a NUL-terminated string is expected.\n     Since: 2.56\n\n Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)\n\n The GIConv struct wraps an iconv() conversion descriptor. It contains\n private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: gsize,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
pub type ino_t = __darwin_ino_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    const UNINIT: ::std::mem::MaybeUninit<dirent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        1048usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_seekoff) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_seekoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_namlen) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    const UNINIT: ::std::mem::MaybeUninit<DIR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::std::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_loc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_loc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_buf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__padding) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_lock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dd_td) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_td)
        )
    );
}
extern "C" {
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn readdir(arg1: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        arg1: *mut DIR,
        arg2: *mut dirent,
        arg3: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(arg1: *mut DIR);
}
extern "C" {
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn alphasort(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dirfd(dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir_b(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int)
        -> *mut DIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
#[doc = " GFileSetContentsFlags:\n @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.\n   The most dangerous setting, which is slightly faster than other settings.\n @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,\n   either the old version of the file or the new version of the file will be\n   available, but not a mixture. On Unix systems this equates to an `fsync()`\n   on the file and use of an atomic `rename()` of the new version of the file\n   over the old.\n @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the\n   new version of the file will be available. On Unix systems this equates to\n   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or\n   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the\n   directory containing the file after calling `rename()`.\n @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability\n   guarantees if the file already exists. This may speed up file operations\n   if the file doesnt currently exist, but may result in a corrupted version\n   of the new file if the system crashes while writing it.\n\n Flags to pass to g_file_set_contents_full() to affect its safety and\n performance.\n\n Since: 2.66"]
pub type GFileSetContentsFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:\n @malloc: function to use for allocating memory.\n @realloc: function to use for reallocating memory.\n @free: function to use to free memory.\n @calloc: function to use for allocating zero-filled memory.\n @try_malloc: function to use for allocating memory without a default error handler.\n @try_realloc: function to use for reallocating memory without a default error handler.\n\n A set of functions used to perform memory allocation. The same #GMemVTable must\n be used for all allocations in the same program; a call to g_mem_set_vtable(),\n if it exists, should be prior to any use of GLib.\n\n This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_free_sized(mem: gpointer, size: size_t);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_free(mem: gpointer);
}
extern "C" {
    pub fn g_aligned_free_sized(mem: gpointer, alignment: size_t, size: size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemVTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_malloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_realloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    const UNINIT: ::std::mem::MaybeUninit<_GNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    const UNINIT: ::std::mem::MaybeUninit<_GList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GHashTableIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy6) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal_all_keys(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_steal_all_values(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_get_values_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:\n\n An opaque structure representing a HMAC operation.\n To create a new GHmac, use g_hmac_new(). To free\n a GHmac, use g_hmac_unref().\n\n Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    const UNINIT: ::std::mem::MaybeUninit<_GHookList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize_hook) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    const UNINIT: ::std::mem::MaybeUninit<_GHook> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hook_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:\n @ufds: an array of #GPollFD elements\n @nfsd: the number of elements in @ufds\n @timeout_: the maximum time to wait for an event of the file descriptors.\n     A negative value indicates an infinite timeout.\n\n Specifies the type of function passed to g_main_context_set_poll_func().\n The semantics of the function should match those of the poll() system call.\n\n Returns: the number of #GPollFD elements which have events or errors\n     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollFD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:\n\n A format specifier that can be used in printf()-style format strings\n when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    const UNINIT: ::std::mem::MaybeUninit<_GSList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
#[doc = " GMainContextFlags:\n @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.\n @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will\n free the thread to process other jobs. That's useful if you're using\n `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in\n other event loops.\n\n Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n of a #GMainContext.\n\n Since: 2.72"]
pub type GMainContextFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:\n\n The `GMainContext` struct is an opaque data\n type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:\n\n The `GMainLoop` struct is an opaque data type\n representing the main event loop of a GLib or GTK application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:\n\n The `GSource` struct is an opaque data type\n representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:\n @ref: Called when a reference is added to the callback object\n @unref: Called when a reference to the callback object is dropped\n @get: Called to extract the callback function and data from the\n     callback object.\n\n The `GSourceCallbackFuncs` struct contains\n functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:\n @prepare: Called before all the file descriptors are polled. If the\n     source can determine that it is ready here (without waiting for the\n     results of the poll() call) it should return %TRUE. It can also return\n     a @timeout_ value which should be the maximum timeout (in milliseconds)\n     which should be passed to the poll() call. The actual timeout used will\n     be -1 if all sources returned -1, or it will be the minimum of all\n     the @timeout_ values returned which were >= 0.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE with a timeout of -1.  If @prepare returns a\n     timeout and the source also has a ready time set, then the\n     lower of the two will be used.\n @check: Called after all the file descriptors are polled. The source\n     should return %TRUE if it is ready to be dispatched. Note that some\n     time may have passed since the previous prepare function was called,\n     so the source should be checked again here.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE.\n @dispatch: Called to dispatch the event source, after it has returned\n     %TRUE in either its @prepare or its @check function, or if a ready time\n     has been reached. The @dispatch function receives a callback function and\n     user data. The callback function may be %NULL if the source was never\n     connected to a callback using g_source_set_callback(). The @dispatch\n     function should call the callback function with @user_data and whatever\n     additional parameters are needed for this type of event source. The\n     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n     source should be removed or %G_SOURCE_CONTINUE to keep it.\n @finalize: Called when the source is finalized. At this point, the source\n     will have been destroyed, had its callback cleared, and have been removed\n     from its #GMainContext, but it will still have its final reference count,\n     so methods can be called on it from within this function.\n\n The `GSourceFuncs` struct contains a table of\n functions used to handle event sources in a generic manner.\n\n For idle sources, the prepare and check functions always return %TRUE\n to indicate that the source is always ready to be processed. The prepare\n function also returns a timeout value of 0 to ensure that the poll() call\n doesn't block (since that would be time wasted which could have been spent\n running the idle function).\n\n For timeout sources, the prepare and check functions both return %TRUE\n if the timeout interval has expired. The prepare function also returns\n a timeout value to ensure that the poll() call doesn't block too long\n and miss the next timeout.\n\n For file descriptor sources, the prepare function typically returns %FALSE,\n since it must wait until poll() has been called before it knows whether\n any events need to be processed. It sets the returned timeout to -1 to\n indicate that it doesn't mind how long the poll() call blocks. In the\n check function, it tests the results of the poll() call to see if the\n required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:\n @user_data: data passed to the function, set when the source was\n     created with one of the above functions\n\n Specifies the type of function passed to g_timeout_add(),\n g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n\n When calling g_source_set_callback(), you may need to cast a function of a\n different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n incompatible function types.\n\n Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n %G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GSourceOnceFunc:\n @user_data: data passed to the function, set when the source was\n   created\n\n A source function that is only called once before being removed from the main\n context automatically.\n\n See: g_idle_add_once(), g_timeout_add_once()\n\n Since: 2.74"]
pub type GSourceOnceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[doc = " GChildWatchFunc:\n @pid: the process id of the child process\n @wait_status: Status information about the child process, encoded\n               in a platform-specific manner\n @user_data: user data passed to g_child_watch_add()\n\n Prototype of a #GChildWatchSource callback, called when a child\n process has exited.\n\n To interpret @wait_status, see the documentation\n for g_spawn_check_wait_status(). In particular,\n on Unix platforms, note that it is usually not equal\n to the integer passed to `exit()` or returned from `main()`."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:\n @source: #GSource that is currently being disposed\n\n Dispose function for @source. See g_source_set_dispose_function() for\n details.\n\n Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    const UNINIT: ::std::mem::MaybeUninit<_GSource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_funcs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_fds) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GSourceCallbackFuncs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unref) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
#[doc = " GSourceDummyMarshal:\n\n This is just a placeholder for #GClosureMarshal,\n which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GSourceFuncs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure_marshal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:\n\n Opaque type. See g_main_context_pusher_new() for details.\n\n Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_static_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:\n @handle_id: the handle ID to clear\n\n Specifies the type of function passed to g_clear_handle_id().\n The implementation is expected to free the resource identified\n by @handle_id; for instance, if @handle_id is a #GSource ID,\n g_source_remove() can be used.\n\n Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_once(
        interval: guint,
        function: GSourceOnceFunc,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:\n\n A type which can hold any UTF-16 code\n point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called\n <firstterm>surrogate pairs</firstterm> to encode characters beyond\n the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored\n in a single gunichar2 field, but all GLib functions accepting gunichar2\n arrays will correctly interpret surrogate pairs.</footnote>.\n\n To print/scan values of this type to/from text you need to convert\n to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().\n\n To print/scan values of this type as integer, use\n %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:\n @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)\n @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)\n @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)\n @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)\n @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)\n @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)\n @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)\n @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)\n @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)\n @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)\n @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)\n @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)\n @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)\n @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)\n @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)\n @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)\n @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)\n @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)\n @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)\n @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)\n @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)\n @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)\n @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)\n @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)\n @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)\n @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)\n @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)\n @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)\n @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)\n @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)\n\n These are the possible character classifications from the\n Unicode specification.\n See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:\n @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)\n @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)\n @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)\n @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)\n @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)\n @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)\n @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)\n @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)\n @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)\n @G_UNICODE_BREAK_SPACE: Space (SP)\n @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)\n @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)\n @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)\n @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)\n @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)\n @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)\n @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)\n @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)\n @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)\n @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)\n @G_UNICODE_BREAK_NUMERIC: Numeric (NU)\n @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)\n @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)\n @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)\n @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)\n @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)\n @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)\n @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)\n @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)\n @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)\n @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)\n @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)\n @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)\n @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)\n @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)\n @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)\n @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.\n @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70\n @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32\n @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32\n @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36\n @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50\n @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50\n @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50\n\n These are the possible line break classifications.\n\n Since new unicode versions may add new types here, applications should be ready\n to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.\n\n See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n @G_UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74\n @G_UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_truncate_middle(string: *const gchar, truncate_length: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:\n @G_NORMALIZE_DEFAULT: standardize differences that do not affect the\n     text content, such as the above-mentioned accent representation\n @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT\n @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with\n     composed forms rather than a maximally decomposed form\n @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE\n @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the\n     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE\n     to the standard forms (in this case DIGIT THREE). Formatting\n     information may be lost but for most text operations such\n     characters should be considered the same\n @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL\n @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed\n     forms rather than a maximally decomposed form\n @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE\n\n Defines how a Unicode string is transformed in a canonical\n form, standardizing such issues as whether a character with\n an accent is represented as a base character and combining\n accent or as a single precomposed character. Unicode strings\n should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
extern "C" {
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
extern "C" {
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:\n @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.\n @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.\n\n Error codes returned by functions converting a string to a number.\n\n Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    const UNINIT: ::std::mem::MaybeUninit<_GString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_take(init: *mut gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_and_steal(string: *mut GString) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const GIOFlags_G_IO_FLAG_NONE: GIOFlags = 0;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOChannel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_cd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_cd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_term) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_term_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_read_buf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_write_buf) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOFuncs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_create_watch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_set_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_get_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:\n @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8\n @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace\n @G_MARKUP_ERROR_PARSE: document was ill-formed\n @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser\n     functions; element wasn't known\n @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; attribute wasn't known\n @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser\n     functions; content was invalid\n @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; a required attribute was missing\n\n Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:\n @G_MARKUP_DEFAULT_FLAGS: No special behaviour. Since: 2.74\n @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use\n @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked\n     sections are not passed literally to the @passthrough function of\n     the parser. Instead, the content of the section (without the\n     `<![CDATA[` and `]]>`) is\n     passed to the @text function. This flag was added in GLib 2.12\n @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup\n     itself have line/column information prefixed to them to let the\n     caller know the location of the error. When this flag is set the\n     location information is also prefixed to errors generated by the\n     #GMarkupParser implementation functions\n @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified\n     attributes and tags, along with their contents.  A qualified\n     attribute or tag is one that contains ':' in its name (ie: is in\n     another namespace).  Since: 2.40.\n\n Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    const UNINIT: ::std::mem::MaybeUninit<_GMarkupParser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_element) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).passthrough) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:\n\n A type in the GVariant type system.\n\n Two types may not be compared by value; use g_variant_type_equal() or\n g_variant_type_is_subtype_of().  May be copied using\n g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVariantIter {
    pub x: [guintptr; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [guintptr; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [guintptr; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
impl ::std::fmt::Debug for _GVariantBuilder__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GVariantBuilder__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
impl ::std::fmt::Debug for _GVariantBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GVariantBuilder {{ u: {:?} }}", self.u)
    }
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [guintptr; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [guintptr; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
impl ::std::fmt::Debug for _GVariantDict__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GVariantDict__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
impl ::std::fmt::Debug for _GVariantDict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GVariantDict {{ u: {:?} }}", self.u)
    }
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: va_list) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: va_list,
    );
}
extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:\n @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.\n @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.\n\n Return values from #GLogWriterFuncs to indicate whether the given log entry\n was successfully handled by the writer, or whether there was an error in\n handling it (and hence a fallback writer should be used).\n\n If a #GLogWriterFunc ignores a log entry, it should return\n %G_LOG_WRITER_HANDLED.\n\n Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_uint;
#[doc = " GLogField:\n @key: field name (UTF-8 string)\n @value: field value (arbitrary bytes)\n @length: length of @value, in bytes, or -1 if it is nul-terminated\n\n Structure representing a single field in a structured log entry. See\n g_log_structured() for details.\n\n Log fields may contain arbitrary values, including binary with embedded nul\n bytes. If the field contains a string, the string must be UTF-8 encoded and\n have a trailing nul byte. Otherwise, @length must be set to a non-negative\n value.\n\n Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    const UNINIT: ::std::mem::MaybeUninit<_GLogField> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " GLogWriterFunc:\n @log_level: log level of the message\n @fields: (array length=n_fields): fields forming the message\n @n_fields: number of @fields\n @user_data: user data passed to g_log_set_writer_func()\n\n Writer function for log entries. A log entry is a collection of one or more\n #GLogFields, using the standard [field names from journal\n specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).\n See g_log_structured() for more information.\n\n Writer functions must ignore fields which they do not recognise, unless they\n can write arbitrary binary output, as field values may be arbitrary binary.\n\n @log_level is guaranteed to be included in @fields as the `PRIORITY` field,\n but is provided separately for convenience of deciding whether or where to\n output the log entry.\n\n Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log\n message successfully or if they deliberately ignored it. If there was an\n error handling the message (for example, if the writer function is meant to\n send messages to a remote logging server and there is a network error), it\n should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be\n chained and fall back to simpler handlers in case of failure.\n\n Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;\n   %G_LOG_WRITER_UNHANDLED otherwise\n\n Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
}
extern "C" {
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_log_get_debug_enabled() -> gboolean;
}
extern "C" {
    pub fn g_log_set_debug_enabled(enabled: gboolean);
}
extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:\n @string: the message to output\n\n Specifies the type of the print handler functions.\n These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:\n\n A `GOptionContext` struct defines which options\n are accepted by the commandline option parser. The struct has only private\n fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:\n\n A `GOptionGroup` struct defines the options in a single\n group. The struct has only private fields and should not be directly accessed.\n\n All options in a group share the same translation function. Libraries which\n need to parse commandline options are expected to provide a function for\n getting a `GOptionGroup` holding their options, which\n the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n      - %G_OPTION_ARG_NONE: %gboolean\n      - %G_OPTION_ARG_STRING: %gchar*\n      - %G_OPTION_ARG_INT: %gint\n      - %G_OPTION_ARG_FILENAME: %gchar*\n      - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n      - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n      - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:\n @G_OPTION_FLAG_NONE: No flags. Since: 2.42.\n @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.\n @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the\n     `--help` output, even if it is defined in a group.\n @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this\n     flag indicates that the sense of the option is reversed. i.e. %FALSE will\n     be stored into the argument rather than %TRUE.\n @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,\n     this flag indicates that the callback does not take any argument\n     (like a %G_OPTION_ARG_NONE option). Since 2.8\n @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument should be passed to the\n     callback in the GLib filename encoding rather than UTF-8. Since 2.8\n @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument supply is optional.\n     If no argument is given then data of %GOptionParseFunc will be\n     set to NULL. Since 2.8\n @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict\n     resolution which prefixes long option names with `groupname-` if\n     there is a conflict. This option should only be used in situations\n     where aliasing is necessary to model some legacy commandline interface.\n     It is not safe to use this option, unless all option groups are under\n     your direct control. Since 2.8.\n\n Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:\n @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags or booleans.\n @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.\n @G_OPTION_ARG_INT: The option takes an integer argument.\n @G_OPTION_ARG_CALLBACK: The option provides a callback (of type\n     #GOptionArgFunc) to parse the extra argument.\n @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will\nbe in the GLib filename encoding rather than UTF-8.\n @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple\n     uses of the option are collected into an array of strings.\n @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,\n     multiple uses of the option are collected into an array of strings.\n @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument\n     can be formatted either for the user's locale or for the \"C\" locale.\n     Since 2.12\n @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like\n     %G_OPTION_ARG_INT but for larger numbers. The number can be in\n     decimal base, or in hexadecimal (when prefixed with `0x`, for\n     example, `0xffffffff`). Since 2.12\n\n The #GOptionArg enum values determine which type of extra argument the\n options expect to find. If an option expects an extra argument, it can\n be specified in several ways; with a short option: `-x arg`, with a long\n option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_uint;
#[doc = " GOptionArgFunc:\n @option_name: The name of the option being parsed. This will be either a\n  single dash followed by a single letter (for a short name) or two dashes\n  followed by a long option name.\n @value: The value to be parsed.\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED\n  is intended to be used for errors in #GOptionArgFunc callbacks.\n\n The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK\n options.\n\n Returns: %TRUE if the option was successfully parsed, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for error details\n\n The type of function that can be called before and after parsing.\n\n Returns: %TRUE if the function completed successfully, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: The #GError containing details about the parse error\n\n The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:\n @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.\n  This error will only be reported, if the parser hasn't been instructed\n  to ignore unknown options, see g_option_context_set_ignore_unknown_options().\n @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.\n @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.\n\n Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n      - %G_OPTION_ARG_NONE: %gboolean\n      - %G_OPTION_ARG_STRING: %gchar*\n      - %G_OPTION_ARG_INT: %gint\n      - %G_OPTION_ARG_FILENAME: %gchar*\n      - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n      - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n      - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GOptionEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
pub type GPathBuf = _GPathBuf;
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPathBuf {
    pub dummy: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GPathBuf() {
    const UNINIT: ::std::mem::MaybeUninit<_GPathBuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPathBuf>(),
        64usize,
        concat!("Size of: ", stringify!(_GPathBuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPathBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPathBuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPathBuf),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub fn g_path_buf_new() -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_new_from_path(path: *const ::std::os::raw::c_char) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_init(buf: *mut GPathBuf) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_init_from_path(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_clear(buf: *mut GPathBuf);
}
extern "C" {
    pub fn g_path_buf_clear_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_free(buf: *mut GPathBuf);
}
extern "C" {
    pub fn g_path_buf_free_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_copy(buf: *mut GPathBuf) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_push(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_pop(buf: *mut GPathBuf) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_set_filename(
        buf: *mut GPathBuf,
        file_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_set_extension(
        buf: *mut GPathBuf,
        extension: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    const UNINIT: ::std::mem::MaybeUninit<_GQueue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:\n\n A typedef for a reference-counted string. A pointer to a #GRefString can be\n treated like a standard `char*` array by all code, but can additionally have\n `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be\n called on `char*` arrays not allocated using g_ref_string_new().\n\n If using #GRefString with autocleanups, g_autoptr() must be used rather than\n g_autofree(), so that the reference counting metadata is also freed.\n\n Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:\n @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.\n @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.\n @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement\n     string.\n @G_REGEX_ERROR_MATCH: The match process failed.\n @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.\n     Since 2.16\n @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\".\n     Since 2.16\n @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\"\n     quantifier. Since 2.16\n @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier.\n     Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for\n     character class. Since 2.16\n @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence\n     in character class. Since 2.16\n @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.\n     Since 2.16\n @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\",\n     \"(?<\" or \"(?P\". Since 2.16\n @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are\n     supported only within a class. Since 2.16\n @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\"\n     without opening \"(\". Since 2.16\n @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent\n     subpattern. Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment.\n     Since 2.16\n @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.\n     Since 2.16\n @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16\n @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not\n     fixed length. Since 2.16\n @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains\n     more than two branches. Since 2.16\n @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.\n     Since 2.16\n @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating\n     elements are not supported. Since 2.16\n @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence\n     is too large. Since 2.16\n @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16\n @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in\n     lookbehind assertion. Since 2.16\n @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator\n     in subpattern name. Since 2.16\n @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have\n     the same name. Since 2.16\n @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence.\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or\n     \"\\\\p\". Since 2.16\n @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long\n     (maximum 32 characters). Since 2.16\n @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum\n     10,000). Since 2.16\n @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more\n     than one branch. Since 2.16\n @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed.\n     This error is never raised. Since: 2.16 Deprecated: 2.34\n @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,\n      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16\n @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing\n     control verb used does not allow an argument. Since: 2.34\n @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing\n     control verb. Since: 2.34\n @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34\n @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34\n @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,\n     \"[\" is an invalid data character. Since: 2.34\n @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the\n     same number are not allowed. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control\n     verb requires an argument. Since: 2.34\n @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII\n     character. Since: 2.34\n @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or\n     quoted name. Since: 2.34\n @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34\n @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34\n @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\",\n     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34\n @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is\n     too large. Since: 2.34\n\n Error codes returned by regular expressions functions.\n\n Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:\n @G_REGEX_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_CASELESS: Letters in the pattern match both upper- and\n     lowercase letters. This option can be changed within a pattern\n     by a \"(?i)\" option setting.\n @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting\n     of a single line of characters (even if it actually contains\n     newlines). The \"start of line\" metacharacter (\"^\") matches only\n     at the start of the string, while the \"end of line\" metacharacter\n     (\"$\") matches only at the end of the string, or before a terminating\n     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When\n     %G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\"\n     constructs match immediately following or immediately before any\n     newline in the string, respectively, as well as at the very start\n     and end. This can be changed within a pattern by a \"(?m)\" option\n     setting.\n @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all\n     characters, including newlines. Without it, newlines are excluded.\n     This option can be changed within a pattern by a (\"?s\") option setting.\n @G_REGEX_EXTENDED: Whitespace data characters in the pattern are\n     totally ignored except when escaped or inside a character class.\n     Whitespace does not include the VT character (code 11). In addition,\n     characters between an unescaped \"#\" outside a character class and\n     the next newline character, inclusive, are also ignored. This can\n     be changed within a pattern by a \"(?x)\" option setting.\n @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern\n     matches only at the end of the string. Without this option, a\n     dollar also matches immediately before the final character if\n     it is a newline (but not before any other newlines). This option\n     is ignored if %G_REGEX_MULTILINE is set.\n @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that\n     they are not greedy by default, but become greedy if followed by \"?\".\n     It can also be set by a \"(?U)\" option setting within the pattern.\n @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this\n     flag they are considered as a raw sequence of bytes.\n @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing\n     parentheses in the pattern. Any opening parenthesis that is not\n     followed by \"?\" behaves as if it were followed by \"?:\" but named\n     parentheses can still be used for capturing (and they acquire numbers\n     in the usual way).\n @G_REGEX_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT\n     compilation, which, if the just-in-time compiler is available, further\n     processes a compiled pattern into machine code that executes much\n     faster. However, it comes at the cost of extra processing before the\n     match is performed, so it is most beneficial to use this when the same\n     compiled pattern is used for matching many times. Before 2.74 this\n     option used the built-in non-JIT optimizations in pcre1.\n @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the\n     first newline. Since: 2.34\n @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not\n     be unique. This can be helpful for certain types of pattern when it\n     is known that only one instance of the named subpattern can ever be\n     matched.\n @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\r'.\n @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\n'.\n @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     sequence is '\\r\\n'.\n @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence\n     is recognized. If this option is set, the only recognized newline character\n     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34\n @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence\n     is recognised. If this option is set, then \"\\R\" only recognizes the newline\n    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34\n @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with\n     JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,\n     as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74\n\n Flags specifying compile-time options.\n\n Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:\n @G_REGEX_MATCH_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is\n     not the beginning of a line, so the circumflex metacharacter should\n     not match before it. Setting this without %G_REGEX_MULTILINE (at\n     compile time) causes circumflex never to match. This option affects\n     only the behaviour of the circumflex metacharacter, it does not\n     affect \"\\A\".\n @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is\n     not the end of a line, so the dollar metacharacter should not match\n     it nor (except in multiline mode) a newline immediately before it.\n     Setting this without %G_REGEX_MULTILINE (at compile time) causes\n     dollar never to match. This option affects only the behaviour of\n     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\".\n @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid\n     match if this option is set. If there are alternatives in the pattern,\n     they are tried. If all the alternatives match the empty string, the\n     entire match fails. For example, if the pattern \"a?b?\" is applied to\n     a string not beginning with \"a\" or \"b\", it matches the empty string\n     at the start of the string. With this flag set, this match is not\n     valid, so GRegex searches further into the string for occurrences\n     of \"a\" or \"b\".\n @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more\n     documentation on partial matching see g_match_info_is_partial_match().\n @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\n' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator.\n @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when\n     creating a new #GRegex, any Unicode newline sequence\n     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR.\n @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when\n     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence\n     is recognized as a newline. Since: 2.34\n @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences\n     are recognized as a newline by \"\\R\". Since: 2.34\n @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; any Unicode newline character or character sequence\n     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to\n     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match\n     is found, without continuing to search for a possible complete match. See\n     g_match_info_is_partial_match() for more information. Since: 2.34\n @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to\n     the start of the matched string. For anchored\n     patterns this can only happen for pattern containing \"\\K\". Since: 2.34\n\n Flags specifying match-time options.\n\n Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:\n\n A GRegex is the \"compiled\" form of a regular expression pattern.\n This structure is opaque and its fields cannot be accessed directly.\n\n Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:\n\n A GMatchInfo is an opaque struct used to return information about\n matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:\n @match_info: the #GMatchInfo generated by the match.\n     Use g_match_info_get_regex() and g_match_info_get_string() if you\n     need the #GRegex or the matched string.\n @result: a #GString containing the new string\n @user_data: user data passed to g_regex_replace_eval()\n\n Specifies the type of the function passed to g_regex_replace_eval().\n It is called for each occurrence of the pattern in the string passed\n to g_regex_replace_eval(), and it should append the replacement to\n @result.\n\n Returns: %FALSE to continue the replacement process, %TRUE to stop it\n\n Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GTokenValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_symbol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_binary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_octal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_comment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_char) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
impl ::std::fmt::Debug for _GTokenValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GTokenValue {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    const UNINIT: ::std::mem::MaybeUninit<_GScannerConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_skip_characters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_identifier_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_identifier_nth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpair_comment_single) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_dummy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    const UNINIT: ::std::mem::MaybeUninit<_GScanner> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_parse_errors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_token) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_line) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_position) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_table) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_fd) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_end) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scope_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_handler) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
impl ::std::fmt::Debug for _GScanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_GScanner {{ user_data: {:?}, max_parse_errors: {:?}, parse_errors: {:?}, input_name: {:?}, qdata: {:?}, config: {:?}, token: {:?}, value: {:?}, line: {:?}, position: {:?}, next_token: {:?}, next_value: {:?}, next_line: {:?}, next_position: {:?}, symbol_table: {:?}, input_fd: {:?}, text: {:?}, text_end: {:?}, buffer: {:?}, scope_id: {:?}, msg_handler: {:?} }}" , self . user_data , self . max_parse_errors , self . parse_errors , self . input_name , self . qdata , self . config , self . token , self . value , self . line , self . position , self . next_token , self . next_value , self . next_line , self . next_position , self . symbol_table , self . input_fd , self . text , self . text_end , self . buffer , self . scope_id , self . msg_handler)
    }
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:\n @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.\n @G_SPAWN_ERROR_READ: Read or select on pipes failed.\n @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.\n @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`\n @G_SPAWN_ERROR_PERM: execv() returned `EPERM`\n @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`\n @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)\n @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`\n @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`\n @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`\n @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`\n @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`\n @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`\n @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`\n @G_SPAWN_ERROR_IO: execv() returned `EIO`\n @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`\n @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`\n @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`\n @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`\n @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`\n @G_SPAWN_ERROR_FAILED: Some other fatal failure,\n   `error->message` should explain.\n\n Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_uint;
#[doc = " GSpawnChildSetupFunc:\n @data: user data passed to the function.\n\n Specifies the type of the setup function passed to g_spawn_async(),\n g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very\n limited ways, be used to affect the child's execution.\n\n On POSIX platforms, the function is called in the child after GLib\n has performed all the setup it plans to perform, but before calling\n exec(). Actions taken in this function will only affect the child,\n not the parent.\n\n On Windows, the function is called in the parent. Its usefulness on\n Windows is thus questionable. In many cases executing the child setup\n function in the parent can have ill effects, and you should be very\n careful when porting software to Windows that uses child setup\n functions.\n\n However, even on POSIX, you are extremely limited in what you can\n safely do from a #GSpawnChildSetupFunc, because any mutexes that were\n held by other threads in the parent process at the time of the fork()\n will still be locked in the child process, and they will never be\n unlocked (since the threads that held them don't exist in the child).\n POSIX allows only async-signal-safe functions (see signal(7)) to be\n called in the child between fork() and exec(), which drastically limits\n the usefulness of child setup functions.\n\n In particular, it is not safe to call any function which may\n call malloc(), which includes POSIX functions such as setenv().\n If you need to set up the child environment differently from\n the parent, you should use g_get_environ(), g_environ_setenv(),\n and g_environ_unsetenv(), and then pass the complete environment\n list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " G_SPAWN_CHILD_INHERITS_STDOUT:\n\n The child will inherit the parent's standard output.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
#[doc = " G_SPAWN_CHILD_INHERITS_STDERR:\n\n The child will inherit the parent's standard error.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
#[doc = " G_SPAWN_STDIN_FROM_DEV_NULL:\n\n The child's standard input is attached to `/dev/null`.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;
#[doc = " GSpawnFlags:\n @G_SPAWN_DEFAULT: no flags, default behaviour\n @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will\n     be inherited by the child; otherwise all descriptors except stdin,\n     stdout and stderr will be closed before calling exec() in the child.\n @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;\n     you must use g_child_watch_add() yourself (or call waitpid() or handle\n     `SIGCHLD` yourself), or the child will become a zombie.\n @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be\n     looked for in the user's `PATH`.\n @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,\n     instead of going to the same location as the parent's standard output.\n @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.\n @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard\n     input (by default, the child's standard input is attached to `/dev/null`).\n @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to\n     execute, while the remaining elements are the actual argument vector\n     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`\n     as the file to execute, and passes all of `argv` to the child.\n @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,\n     it will be looked for in the `PATH` from the passed child environment.\n     Since: 2.34\n @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.\n     Since: 2.40\n @G_SPAWN_CHILD_INHERITS_STDOUT: the child will inherit the parent's standard output.\n     Since: 2.74\n @G_SPAWN_CHILD_INHERITS_STDERR: the child will inherit the parent's standard error.\n     Since: 2.74\n @G_SPAWN_STDIN_FROM_DEV_NULL: the child's standard input is attached to `/dev/null`.\n     Since: 2.74\n\n Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
#[doc = " GStrvBuilder:\n\n A helper object to build a %NULL-terminated string array\n by appending. See g_strv_builder_new().\n\n Since: 2.68"]
pub type GStrvBuilder = _GStrvBuilder;
extern "C" {
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
}
extern "C" {
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
}
extern "C" {
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
}
extern "C" {
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_strv_builder_addv(
        builder: *mut GStrvBuilder,
        value: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
}
extern "C" {
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_get_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_fail_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_incomplete_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_disable_crash_reporting();
}
extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:\n @G_TEST_TRAP_DEFAULT: Default behaviour. Since: 2.74\n @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stdout().\n @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stderr().\n @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the\n     child process is shared with stdin of its parent process.\n     It is redirected to `/dev/null` otherwise.\n\n Test traps are guards around forked tests.\n These flags determine what traps to set.\n\n Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),\n which is deprecated. g_test_trap_subprocess() uses\n #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_case_free(test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_free(suite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstrv(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        first_wrong_idx: gsize,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpint(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: guint64,
        cmp: *const ::std::os::raw::c_char,
        arg2: guint64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: f64,
        cmp: *const ::std::os::raw::c_char,
        arg2: f64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    const UNINIT: ::std::mem::MaybeUninit<GTestConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_quick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_perf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_verbose) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_quiet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_undefined) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_uint;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut f64,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    const UNINIT: ::std::mem::MaybeUninit<GTestLogMsg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_nums) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nums) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<GTestLogBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:\n @log_domain: the log domain of the message\n @log_level: the log level of the message (including the fatal and recursion flags)\n @message: the message to process\n @user_data: user data, set in g_test_log_set_fatal_handler()\n\n Specifies the prototype of fatal log handler functions.\n\n Returns: %TRUE if the program should abort, %FALSE otherwise\n\n Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadPool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclusive) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    const UNINIT: ::std::mem::MaybeUninit<_GTrashStack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
#[doc = " GTreeNode:\n\n An opaque type which identifies a specific node in a #GTree.\n\n Since: 2.68"]
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
#[doc = " GTraverseNodeFunc:\n @node: a #GTreeNode\n @data: user data passed to g_tree_foreach_node()\n\n Specifies the type of function passed to g_tree_foreach_node(). It is\n passed each node, together with the @user_data parameter passed to\n g_tree_foreach_node(). If the function returns %TRUE, the traversal is\n stopped.\n\n Returns: %TRUE to stop the traversal\n Since: 2.68"]
pub type GTraverseNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GTreeNode, data: gpointer) -> gboolean>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_remove_all(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
}
extern "C" {
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
extern "C" {
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_unref(uri: *mut GUri);
}
pub const GUriFlags_G_URI_FLAGS_NONE: GUriFlags = 0;
pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const GUriFlags_G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const GUriFlags_G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
#[doc = " GUriFlags:\n @G_URI_FLAGS_NONE: No flags set.\n @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the\n     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,\n     fixing up or ignoring common mistakes in URIs coming from external\n     sources. This is also needed for some obscure URI schemes where `;`\n     separates the host from the path. Dont use this flag unless you need to.\n @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,\n     which will be separated from the username by `:`.\n @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional\n     authentication-related parameters, which will be separated from\n     the username and/or password by `;`.\n @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a\n     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS\n     hostnames).\n @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded\n     characters in the userinfo, path, query, and fragment fields\n     should not be decoded. (And likewise the host field if\n     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates\n     that you have already `%`-encoded the components, and so #GUri\n     should not do any encoding itself.\n @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query\n     field only.\n @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.\n @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the\n     fragment only.\n @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.\n     For example, when parsing an HTTP URI changing omitted path to `/` and\n     omitted port to `80`; and when building a URI, changing empty path to `/`\n     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)\n\n Flags that describe a URI.\n\n When parsing a URI, if you need to choose different flags based on\n the type of URI, you can use g_uri_peek_scheme() on the URI string\n to check the scheme first, and use that to decide what flags to\n parse it with.\n\n Since: 2.66"]
pub type GUriFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
pub const GUriHideFlags_G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const GUriHideFlags_G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const GUriHideFlags_G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const GUriHideFlags_G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const GUriHideFlags_G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
#[doc = " GUriHideFlags:\n @G_URI_HIDE_NONE: No flags set.\n @G_URI_HIDE_USERINFO: Hide the userinfo.\n @G_URI_HIDE_PASSWORD: Hide the password.\n @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.\n @G_URI_HIDE_QUERY: Hide the query.\n @G_URI_HIDE_FRAGMENT: Hide the fragment.\n\n Flags describing what parts of the URI to hide in\n g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and\n %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with\n the corresponding flags.\n\n Since: 2.66"]
pub type GUriHideFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_to_string_partial(
        uri: *mut GUri,
        flags: GUriHideFlags,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
}
extern "C" {
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
}
pub const GUriParamsFlags_G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
#[doc = " GUriParamsFlags:\n @G_URI_PARAMS_NONE: No flags set.\n @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.\n @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for\n     URLs on the web, using the `https` or `http` schemas.\n @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.\n\n Flags modifying the way parameters are handled by g_uri_parse_params() and\n #GUriParamsIter.\n\n Since: 2.66"]
pub type GUriParamsFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[test]
fn bindgen_test_layout__GUriParamsIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GUriParamsIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUriParamsIter>(),
        280usize,
        concat!("Size of: ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUriParamsIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy3)
        )
    );
}
extern "C" {
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
}
extern "C" {
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_error_quark() -> GQuark;
}
pub const GUriError_G_URI_ERROR_FAILED: GUriError = 0;
pub const GUriError_G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const GUriError_G_URI_ERROR_BAD_USER: GUriError = 2;
pub const GUriError_G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const GUriError_G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const GUriError_G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const GUriError_G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const GUriError_G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const GUriError_G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
#[doc = " GUriError:\n @G_URI_ERROR_FAILED: Generic error if no more specific error is available.\n     See the error message for details.\n @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.\n @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.\n @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.\n @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.\n @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.\n @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.\n @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.\n @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.\n @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.\n\n Error codes returned by #GUri methods.\n\n Since: 2.66"]
pub type GUriError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_peek_scheme(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_bytes(
        escaped_string: *const ::std::os::raw::c_char,
        length: gssize,
        illegal_characters: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    pub static glib_major_version: guint;
}
extern "C" {
    pub static glib_minor_version: guint;
}
extern "C" {
    pub static glib_micro_version: guint;
}
extern "C" {
    pub static glib_interface_age: guint;
}
extern "C" {
    pub static glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    const UNINIT: ::std::mem::MaybeUninit<_GCompletion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strncmp_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    const UNINIT: ::std::mem::MaybeUninit<_GTuples> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    const UNINIT: ::std::mem::MaybeUninit<_GThread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).joinable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadFunctions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_new) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_trylock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_unlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_new) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_signal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_broadcast) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_wait) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_timed_wait) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_free) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_get) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_set) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_create) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_yield) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_join) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_exit) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_set_priority) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_self) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_equal) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> size_t;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut size_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    const UNINIT: ::std::mem::MaybeUninit<GStaticMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        72usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRecMutex__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
impl ::std::fmt::Debug for _GStaticRecMutex__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GStaticRecMutex__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        88usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
impl ::std::fmt::Debug for _GStaticRecMutex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_GStaticRecMutex {{ mutex: {:?}, depth: {:?}, unused: {:?} }}",
            self.mutex, self.depth, self.unused
        )
    }
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRWLock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        104usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_cond) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_cond) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_counter) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_writer) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_to_read) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_to_write) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticPrivate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GStrvBuilder_autoptr = *mut GStrvBuilder;
pub type GStrvBuilder_listautoptr = *mut GList;
pub type GStrvBuilder_slistautoptr = *mut GSList;
pub type GStrvBuilder_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub type GUri_autoptr = *mut GUri;
pub type GUri_listautoptr = *mut GList;
pub type GUri_slistautoptr = *mut GSList;
pub type GUri_queueautoptr = *mut GQueue;
pub type GPathBuf_autoptr = *mut GPathBuf;
pub type GPathBuf_listautoptr = *mut GList;
pub type GPathBuf_slistautoptr = *mut GSList;
pub type GPathBuf_queueautoptr = *mut GQueue;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_printf(format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_fprintf(file: *mut FILE, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_sprintf(string: *mut gchar, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vprintf(format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_vfprintf(file: *mut FILE, format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_vsprintf(string: *mut gchar, format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_vasprintf(string: *mut *mut gchar, format: *const gchar, args: va_list) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[test]
fn bindgen_test_layout_ostat() {
    const UNINIT: ::std::mem::MaybeUninit<ostat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ostat>(),
        96usize,
        concat!("Size of: ", stringify!(ostat))
    );
    assert_eq!(
        ::std::mem::align_of::<ostat>(),
        8usize,
        concat!("Alignment of ", stringify!(ostat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_birthtimespec) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_birthtimespec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_lspare) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_lspare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_qspare) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_qspare)
        )
    );
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
extern "C" {
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
pub type GStatBuf = stat;
extern "C" {
    pub fn g_access(filename: *const gchar, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_chdir(path: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_unlink(filename: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_rmdir(filename: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_close(fd: gint, error: *mut *mut GError) -> gboolean;
}
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
#[doc = " GModuleFlags:\n @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when\n     needed. The default action is to bind all symbols when the module\n     is loaded.\n @G_MODULE_BIND_LOCAL: specifies that symbols in the module should\n     not be added to the global name space. The default action on most\n     platforms is to place symbols in the module in the global name space,\n     which may cause conflicts with existing symbols.\n @G_MODULE_BIND_MASK: mask for all flags.\n\n Flags passed to g_module_open().\n Note that these flags are not supported on all platforms."]
pub type GModuleFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
extern "C" {
    pub fn g_module_error_quark() -> GQuark;
}
pub const GModuleError_G_MODULE_ERROR_FAILED: GModuleError = 0;
pub const GModuleError_G_MODULE_ERROR_CHECK_FAILED: GModuleError = 1;
#[doc = " GModuleError:\n @G_MODULE_ERROR_FAILED: there was an error loading or opening a module file\n @G_MODULE_ERROR_CHECK_FAILED: a module returned an error from its `g_module_check_init()` function\n\n Errors returned by g_module_open_full().\n\n Since: 2.70"]
pub type GModuleError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_module_supported() -> gboolean;
}
extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    pub fn g_module_open_full(
        file_name: *const gchar,
        flags: GModuleFlags,
        error: *mut *mut GError,
    ) -> *mut GModule;
}
extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
extern "C" {
    pub fn g_module_error() -> *const gchar;
}
extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
pub type GType = gsize;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
pub type GValue = _GValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
impl ::std::fmt::Debug for _GTypeCValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GTypeCValue {{ union }}")
    }
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
pub type GTypeInterface = _GTypeInterface;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
pub type GTypeInfo = _GTypeInfo;
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
pub type GInterfaceInfo = _GInterfaceInfo;
#[doc = " GTypeValueTable:\n @value_init: Function to initialize a GValue\n @value_free: Function to free a GValue\n @value_copy: Function to copy a GValue\n @value_peek_pointer: Function to peek the contents of a GValue if they fit\n   into a pointer\n @collect_format: A string format describing how to collect the contents of\n   this value bit-by-bit. Each character in the format represents\n   an argument to be collected, and the characters themselves indicate\n   the type of the argument. Currently supported arguments are:\n    - `'i'`: Integers, passed as `collect_values[].v_int`\n    - `'l'`: Longs, passed as `collect_values[].v_long`\n    - `'d'`: Doubles, passed as `collect_values[].v_double`\n    - `'p'`: Pointers, passed as `collect_values[].v_pointer`\n   It should be noted that for variable argument list construction,\n   ANSI C promotes every type smaller than an integer to an int, and\n   floats to doubles. So for collection of short int or char, `'i'`\n   needs to be used, and for collection of floats `'d'`.\n @collect_value: Function to initialize a GValue from the values\n   collected from variadic arguments\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n   analogous to @collect_format. Usually, @lcopy_format string consists\n   only of `'p'`s to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: Function to store the contents of a value into the\n   locations collected from variadic arguments\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
pub type GTypeValueTable = _GTypeValueTable;
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
pub type GTypeQuery = _GTypeQuery;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_instance_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_instance_type)
        )
    );
}
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[test]
fn bindgen_test_layout__GTypeQuery() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeQuery> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeQuery>(),
        24usize,
        concat!("Size of: ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(instance_size)
        )
    );
}
pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;
#[doc = " GTypeDebugFlags:\n @G_TYPE_DEBUG_NONE: Print no messages\n @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping\n @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions\n @G_TYPE_DEBUG_MASK: Mask covering all debug flags\n @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type\n\n These flags used to be passed to g_type_init_with_debug_flags() which\n is now deprecated.\n\n If you need to enable debugging features, use the `GOBJECT_DEBUG`\n environment variable.\n\n Deprecated: 2.36: g_type_init() is now done automatically"]
pub type GTypeDebugFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_type_init();
}
extern "C" {
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
extern "C" {
    pub fn g_type_name(type_: GType) -> *const gchar;
}
extern "C" {
    pub fn g_type_qname(type_: GType) -> GQuark;
}
extern "C" {
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
extern "C" {
    pub fn g_type_parent(type_: GType) -> GType;
}
extern "C" {
    pub fn g_type_depth(type_: GType) -> guint;
}
extern "C" {
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
extern "C" {
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_unref(g_class: gpointer);
}
extern "C" {
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
extern "C" {
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
extern "C" {
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
#[doc = " GBaseInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize\n\n A callback function used by the type system to do base initialization\n of the class structures of derived types.\n\n This function is called as part of the initialization process of all derived\n classes and should reallocate or reset all dynamic class members copied over\n from the parent class.\n\n For example, class members (such as strings) that are not sufficiently\n handled by a plain memory copy of the parent class into the derived class\n have to be altered. See GClassInitFunc() for a discussion of the class\n initialization process."]
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GBaseFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n\n A callback function used by the type system to finalize those portions\n of a derived types class structure that were setup from the corresponding\n GBaseInitFunc() function.\n\n Class finalization basically works the inverse way in which class\n initialization is performed.\n\n See GClassInitFunc() for a discussion of the class initialization process."]
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GClassInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.\n @class_data: The @class_data member supplied via the #GTypeInfo structure.\n\n A callback function used by the type system to initialize the class\n of a specific type.\n\n This function should initialize all static class members.\n\n The initialization process of a class involves:\n\n - Copying common members from the parent class over to the\n   derived class structure.\n - Zero initialization of the remaining members not copied\n   over from the parent class.\n - Invocation of the GBaseInitFunc() initializers of all parent\n   types and the class' type.\n - Invocation of the class' GClassInitFunc() initializer.\n\n Since derived classes are partially initialized through a memory copy\n of the parent class, the general rule is that GBaseInitFunc() and\n GBaseFinalizeFunc() should take care of necessary reinitialization\n and release of those class members that were introduced by the type\n that specified these GBaseInitFunc()/GBaseFinalizeFunc().\n GClassInitFunc() should only care about initializing static\n class members, while dynamic class members (such as allocated strings\n or reference counted resources) are better handled by a GBaseInitFunc()\n for this type, so proper initialization of the dynamic class members\n is performed for class initialization of derived types as well.\n\n An example may help to correspond the intend of the different class\n initializers:\n\n |[<!-- language=\"C\" -->\n typedef struct {\n   GObjectClass parent_class;\n   gint         static_integer;\n   gchar       *dynamic_string;\n } TypeAClass;\n static void\n type_a_base_class_init (TypeAClass *class)\n {\n   class->dynamic_string = g_strdup (\"some string\");\n }\n static void\n type_a_base_class_finalize (TypeAClass *class)\n {\n   g_free (class->dynamic_string);\n }\n static void\n type_a_class_init (TypeAClass *class)\n {\n   class->static_integer = 42;\n }\n\n typedef struct {\n   TypeAClass   parent_class;\n   gfloat       static_float;\n   GString     *dynamic_gstring;\n } TypeBClass;\n static void\n type_b_base_class_init (TypeBClass *class)\n {\n   class->dynamic_gstring = g_string_new (\"some other string\");\n }\n static void\n type_b_base_class_finalize (TypeBClass *class)\n {\n   g_string_free (class->dynamic_gstring);\n }\n static void\n type_b_class_init (TypeBClass *class)\n {\n   class->static_float = 3.14159265358979323846;\n }\n ]|\n\n Initialization of TypeBClass will first cause initialization of\n TypeAClass (derived classes reference their parent classes, see\n g_type_class_ref() on this).\n\n Initialization of TypeAClass roughly involves zero-initializing its fields,\n then calling its GBaseInitFunc() type_a_base_class_init() to allocate\n its dynamic members (dynamic_string), and finally calling its GClassInitFunc()\n type_a_class_init() to initialize its static members (static_integer).\n The first step in the initialization process of TypeBClass is then\n a plain memory copy of the contents of TypeAClass into TypeBClass and\n zero-initialization of the remaining fields in TypeBClass.\n The dynamic members of TypeAClass within TypeBClass now need\n reinitialization which is performed by calling type_a_base_class_init()\n with an argument of TypeBClass.\n\n After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()\n is called to allocate the dynamic members of TypeBClass (dynamic_gstring),\n and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),\n is called to complete the initialization process with the static members\n (static_float).\n\n Corresponding finalization counter parts to the GBaseInitFunc() functions\n have to be provided to release allocated resources at class finalization\n time."]
pub type GClassInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GClassFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n @class_data: The @class_data member supplied via the #GTypeInfo structure\n\n A callback function used by the type system to finalize a class.\n\n This function is rarely needed, as dynamically allocated class resources\n should be handled by GBaseInitFunc() and GBaseFinalizeFunc().\n\n Also, specification of a GClassFinalizeFunc() in the #GTypeInfo\n structure of a static type is invalid, because classes of static types\n will never be finalized (they are artificially kept alive when their\n reference count drops to zero)."]
pub type GClassFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GInstanceInitFunc:\n @instance: The instance to initialize\n @g_class: (type GObject.TypeClass): The class of the type the instance is\n    created for\n\n A callback function used by the type system to initialize a new\n instance of a type.\n\n This function initializes all instance members and allocates any resources\n required by it.\n\n Initialization of a derived instance involves calling all its parent\n types instance initializers, so the class member of the instance\n is altered during its initialization to always point to the class that\n belongs to the type the current initializer was introduced for.\n\n The extended members of @instance are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
#[doc = " GInterfaceInitFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to initialize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to initialize a new\n interface.\n\n This function should initialize all internal data and* allocate any\n resources required by the interface.\n\n The members of @iface_data are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInterfaceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GInterfaceFinalizeFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to finalize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to finalize an interface.\n\n This function should destroy any internal data and release any resources\n allocated by the corresponding GInterfaceInitFunc() function."]
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GTypeClassCacheFunc:\n @cache_data: data that was given to the g_type_add_class_cache_func() call\n @g_class: (type GObject.TypeClass): The #GTypeClass structure which is\n    unreferenced\n\n A callback function which is called when the reference count of a class\n drops to zero.\n\n It may use g_type_class_ref() to prevent the class from being freed. You\n should not call g_type_class_unref() from a #GTypeClassCacheFunc function\n to prevent infinite recursion, use g_type_class_unref_uncached() instead.\n\n The functions have to check the class id passed in to figure\n whether they actually want to cache the class of this type, since all\n classes are routed through the same #GTypeClassCacheFunc chain.\n\n Returns: %TRUE to stop further #GTypeClassCacheFuncs from being\n  called, %FALSE to continue"]
pub type GTypeClassCacheFunc = ::std::option::Option<
    unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean,
>;
#[doc = " GTypeInterfaceCheckFunc:\n @check_data: data passed to g_type_add_interface_check()\n @g_iface: (type GObject.TypeInterface): the interface that has been\n    initialized\n\n A callback called after an interface vtable is initialized.\n\n See g_type_add_interface_check().\n\n Since: 2.4"]
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;
#[doc = " GTypeFundamentalFlags:\n @G_TYPE_FLAG_CLASSED: Indicates a classed type\n @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiatable type (implies classed)\n @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type\n @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)\n\n Bit masks used to check or determine specific characteristics of a\n fundamental type."]
pub type GTypeFundamentalFlags = ::std::os::raw::c_uint;
pub const GTypeFlags_G_TYPE_FLAG_NONE: GTypeFlags = 0;
pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
pub const GTypeFlags_G_TYPE_FLAG_FINAL: GTypeFlags = 64;
pub const GTypeFlags_G_TYPE_FLAG_DEPRECATED: GTypeFlags = 128;
#[doc = " GTypeFlags:\n @G_TYPE_FLAG_NONE: No special flags. Since: 2.74\n @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be\n  created for an abstract type\n @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type\n  that introduces a value table, but can't be used for\n  g_value_init()\n @G_TYPE_FLAG_FINAL: Indicates a final type. A final type is a non-derivable\n  leaf node in a deep derivable type hierarchy tree. Since: 2.70\n @G_TYPE_FLAG_DEPRECATED: The type is deprecated and may be removed in a\n  future version. A warning will be emitted if it is instantiated while\n  running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76\n\n Bit masks used to check or determine characteristics of a type."]
pub type GTypeFlags = ::std::os::raw::c_uint;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[test]
fn bindgen_test_layout__GTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_finalize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_init) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_finalize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_preallocs) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_init) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_table) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(value_table)
        )
    );
}
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[test]
fn bindgen_test_layout__GTypeFundamentalInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeFundamentalInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Size of: ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeFundamentalInfo),
            "::",
            stringify!(type_flags)
        )
    );
}
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[test]
fn bindgen_test_layout__GInterfaceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GInterfaceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInterfaceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_finalize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_data)
        )
    );
}
#[doc = " GTypeValueInitFunc:\n @value: the value to initialize\n\n Initializes the value contents by setting the fields of the `value->data`\n array.\n\n The data array of the #GValue passed into this function was zero-filled\n with `memset()`, so no care has to be taken to free any old contents.\n For example, in the case of a string value that may never be %NULL, the\n implementation might look like:\n\n |[<!-- language=\"C\" -->\n value->data[0].v_pointer = g_strdup (\"\");\n ]|\n\n Since: 2.78"]
pub type GTypeValueInitFunc = ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>;
#[doc = " GTypeValueFreeFunc:\n @value: the value to free\n\n Frees any old contents that might be left in the `value->data` array of\n the given value.\n\n No resources may remain allocated through the #GValue contents after this\n function returns. E.g. for our above string type:\n\n |[<!-- language=\"C\" -->\n // only free strings without a specific flag for static storage\n if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))\n   g_free (value->data[0].v_pointer);\n ]|\n\n Since: 2.78"]
pub type GTypeValueFreeFunc = ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>;
#[doc = " GTypeValueCopyFunc:\n @src_value: the value to copy\n @dest_value: (out): the location of the copy\n\n Copies the content of a #GValue into another.\n\n The @dest_value is a #GValue with zero-filled data section and @src_value\n is a properly initialized #GValue of same type, or derived type.\n\n The purpose of this function is to copy the contents of @src_value\n into @dest_value in a way, that even after @src_value has been freed, the\n contents of @dest_value remain valid. String type example:\n\n |[<!-- language=\"C\" -->\n dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);\n ]|\n\n Since: 2.78"]
pub type GTypeValueCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GTypeValuePeekPointerFunc:\n @value: the value to peek\n\n If the value contents fit into a pointer, such as objects or strings,\n return this pointer, so the caller can peek at the current contents.\n\n To extend on our above string example:\n\n |[<!-- language=\"C\" -->\n return value->data[0].v_pointer;\n ]|\n\n Returns: (transfer none): a pointer to the value contents\n\n Since: 2.78"]
pub type GTypeValuePeekPointerFunc =
    ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>;
#[doc = " GTypeValueCollectFunc:\n @value: the value to initialize\n @n_collect_values: the number of collected values\n @collect_values: (array length=n_collect_values): the collected values\n @collect_flags: optional flags\n\n This function is responsible for converting the values collected from\n a variadic argument list into contents suitable for storage in a #GValue.\n\n This function should setup @value similar to #GTypeValueInitFunc; e.g.\n for a string value that does not allow `NULL` pointers, it needs to either\n emit an error, or do an implicit conversion by storing an empty string.\n\n The @value passed in to this function has a zero-filled data array, so\n just like for #GTypeValueInitFunc it is guaranteed to not contain any old\n contents that might need freeing.\n\n The @n_collect_values argument is the string length of the `collect_format`\n field of #GTypeValueTable, and `collect_values` is an array of #GTypeCValue\n with length of @n_collect_values, containing the collected values according\n to `collect_format`.\n\n The @collect_flags argument provided as a hint by the caller. It may\n contain the flag %G_VALUE_NOCOPY_CONTENTS indicating that the collected\n value contents may be considered static for the duration of the @value\n lifetime. Thus an extra copy of the contents stored in @collect_values is\n not required for assignment to @value.\n\n For our above string example, we continue with:\n\n |[<!-- language=\"C\" -->\n if (!collect_values[0].v_pointer)\n   value->data[0].v_pointer = g_strdup (\"\");\n else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n   {\n     value->data[0].v_pointer = collect_values[0].v_pointer;\n     // keep a flag for the value_free() implementation to not free this string\n     value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;\n   }\n else\n   value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);\n return NULL;\n ]|\n\n It should be noted, that it is generally a bad idea to follow the\n %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to\n reentrancy requirements and reference count assertions performed\n by the signal emission code, reference counts should always be\n incremented for reference counted contents stored in the `value->data`\n array. To deviate from our string example for a moment, and taking\n a look at an exemplary implementation for `GTypeValueTable.collect_value()`\n of `GObject`:\n\n |[<!-- language=\"C\" -->\n GObject *object = G_OBJECT (collect_values[0].v_pointer);\n g_return_val_if_fail (object != NULL,\n    g_strdup_printf (\"Object %p passed as invalid NULL pointer\", object));\n // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types\n value->data[0].v_pointer = g_object_ref (object);\n return NULL;\n ]|\n\n The reference count for valid objects is always incremented, regardless\n of `collect_flags`. For invalid objects, the example returns a newly\n allocated string without altering `value`.\n\n Upon success, `collect_value()` needs to return `NULL`. If, however,\n an error condition occurred, `collect_value()` should return a newly\n allocated string containing an error diagnostic.\n\n The calling code makes no assumptions about the `value` contents being\n valid upon error returns, `value` is simply thrown away without further\n freeing. As such, it is a good idea to not allocate `GValue` contents\n prior to returning an error; however, `collect_values()` is not obliged\n to return a correctly setup @value for error returns, simply because\n any non-`NULL` return is considered a fatal programming error, and\n further program behaviour is undefined.\n\n Returns: (transfer full) (nullable): `NULL` on success, otherwise a\n   newly allocated error string on failure\n\n Since: 2.78"]
pub type GTypeValueCollectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GValue,
        n_collect_values: guint,
        collect_values: *mut GTypeCValue,
        collect_flags: guint,
    ) -> *mut gchar,
>;
#[doc = " GTypeValueLCopyFunc:\n @value: the value to lcopy\n @n_collect_values: the number of collected values\n @collect_values: (array length=n_collect_values): the collected\n   locations for storage\n @collect_flags: optional flags\n\n This function is responsible for storing the `value`\n contents into arguments passed through a variadic argument list which\n got collected into `collect_values` according to `lcopy_format`.\n\n The `n_collect_values` argument equals the string length of\n `lcopy_format`, and `collect_flags` may contain %G_VALUE_NOCOPY_CONTENTS.\n\n In contrast to #GTypeValueCollectFunc, this function is obliged to always\n properly support %G_VALUE_NOCOPY_CONTENTS.\n\n Similar to #GTypeValueCollectFunc the function may prematurely abort by\n returning a newly allocated string describing an error condition. To\n complete the string example:\n\n |[<!-- language=\"C\" -->\n gchar **string_p = collect_values[0].v_pointer;\n g_return_val_if_fail (string_p != NULL,\n   g_strdup (\"string location passed as NULL\"));\n\n if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n   *string_p = value->data[0].v_pointer;\n else\n   *string_p = g_strdup (value->data[0].v_pointer);\n ]|\n\n And an illustrative version of this function for reference-counted\n types:\n\n |[<!-- language=\"C\" -->\n GObject **object_p = collect_values[0].v_pointer;\n g_return_val_if_fail (object_p != NULL,\n   g_strdup (\"object location passed as NULL\"));\n\n if (value->data[0].v_pointer == NULL)\n   *object_p = NULL;\n else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour\n   *object_p = value->data[0].v_pointer;\n else\n   *object_p = g_object_ref (value->data[0].v_pointer);\n\n return NULL;\n ]|\n\n Returns: (transfer full) (nullable): `NULL` on success, otherwise\n   a newly allocated error string on failure\n\n Since: 2.78"]
pub type GTypeValueLCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const GValue,
        n_collect_values: guint,
        collect_values: *mut GTypeCValue,
        collect_flags: guint,
    ) -> *mut gchar,
>;
#[doc = " GTypeValueTable:\n @value_init: Function to initialize a GValue\n @value_free: Function to free a GValue\n @value_copy: Function to copy a GValue\n @value_peek_pointer: Function to peek the contents of a GValue if they fit\n   into a pointer\n @collect_format: A string format describing how to collect the contents of\n   this value bit-by-bit. Each character in the format represents\n   an argument to be collected, and the characters themselves indicate\n   the type of the argument. Currently supported arguments are:\n    - `'i'`: Integers, passed as `collect_values[].v_int`\n    - `'l'`: Longs, passed as `collect_values[].v_long`\n    - `'d'`: Doubles, passed as `collect_values[].v_double`\n    - `'p'`: Pointers, passed as `collect_values[].v_pointer`\n   It should be noted that for variable argument list construction,\n   ANSI C promotes every type smaller than an integer to an int, and\n   floats to doubles. So for collection of short int or char, `'i'`\n   needs to be used, and for collection of floats `'d'`.\n @collect_value: Function to initialize a GValue from the values\n   collected from variadic arguments\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n   analogous to @collect_format. Usually, @lcopy_format string consists\n   only of `'p'`s to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: Function to store the contents of a value into the\n   locations collected from variadic arguments\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeValueTable {
    pub value_init: GTypeValueInitFunc,
    pub value_free: GTypeValueFreeFunc,
    pub value_copy: GTypeValueCopyFunc,
    pub value_peek_pointer: GTypeValuePeekPointerFunc,
    pub collect_format: *const gchar,
    pub collect_value: GTypeValueCollectFunc,
    pub lcopy_format: *const gchar,
    pub lcopy_value: GTypeValueLCopyFunc,
}
#[test]
fn bindgen_test_layout__GTypeValueTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeValueTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeValueTable>(),
        64usize,
        concat!("Size of: ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeValueTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_copy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_peek_pointer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_peek_pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).collect_format) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).collect_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lcopy_format) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lcopy_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_value)
        )
    );
}
extern "C" {
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const gchar,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
}
extern "C" {
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
}
extern "C" {
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
extern "C" {
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut guint,
    ) -> *mut GType;
}
extern "C" {
    pub fn g_type_interface_instantiatable_prerequisite(interface_type: GType) -> GType;
}
extern "C" {
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
extern "C" {
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
extern "C" {
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;
}
extern "C" {
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
extern "C" {
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
extern "C" {
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
extern "C" {
    pub fn g_type_ensure(type_: GType);
}
extern "C" {
    pub fn g_type_get_type_registration_serial() -> guint;
}
extern "C" {
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
extern "C" {
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
}
extern "C" {
    pub fn g_type_fundamental_next() -> GType;
}
extern "C" {
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
extern "C" {
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
extern "C" {
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
extern "C" {
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
extern "C" {
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
extern "C" {
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
extern "C" {
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
}
extern "C" {
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
extern "C" {
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_value(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_type_check_value_holds(value: *const GValue, type_: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
extern "C" {
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
extern "C" {
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
#[doc = " GValueTransform:\n @src_value: Source value.\n @dest_value: Target value.\n\n The type of value transformation functions which can be registered with\n g_value_register_transform_func().\n\n @dest_value will be initialized to the correct destination type."]
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GValue__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_uint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_ulong) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_ulong)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_pointer)
        )
    );
}
impl ::std::fmt::Debug for _GValue__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_GValue__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(data)
        )
    );
}
impl ::std::fmt::Debug for _GValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_GValue {{ g_type: {:?}, data: {:?} }}",
            self.g_type, self.data
        )
    }
}
extern "C" {
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
extern "C" {
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
extern "C" {
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
extern "C" {
    pub fn g_value_unset(value: *mut GValue);
}
extern "C" {
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
#[doc = " GParamFlags:\n @G_PARAM_READABLE: the parameter is readable\n @G_PARAM_WRITABLE: the parameter is writable\n @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE\n @G_PARAM_CONSTRUCT: the parameter will be set upon object construction\n @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction\n @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())\n  strict validation is not required\n @G_PARAM_STATIC_NAME: the string used as name when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_NICK: the string used as nick when constructing the\n  parameter is guaranteed to remain valid and\n  unmmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this\n   property will not automatically result in a \"notify\" signal being\n   emitted: the implementation must call g_object_notify() themselves\n   in case the property actually changes.  Since: 2.42.\n @G_PARAM_PRIVATE: internal\n @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed\n  in a future version. A warning will be generated if it is used\n  while running with G_ENABLE_DIAGNOSTIC=1.\n  Since 2.26\n\n Through the #GParamFlags flag values, certain aspects of parameters\n can be configured.\n\n See also: %G_PARAM_STATIC_STRINGS"]
pub type GParamFlags = ::std::os::raw::c_int;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n @g_type_instance: private #GTypeInstance portion\n @name: name of this parameter: always an interned string\n @flags: #GParamFlags flags for this parameter\n @value_type: the #GValue type for this parameter\n @owner_type: #GType type that uses (introduces) this parameter\n\n All other fields of the GParamSpec struct are private and\n should not be used directly."]
pub type GParamSpec = _GParamSpec;
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
pub type GParamSpecClass = _GParamSpecClass;
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n @g_type_instance: private #GTypeInstance portion\n @name: name of this parameter: always an interned string\n @flags: #GParamFlags flags for this parameter\n @value_type: the #GValue type for this parameter\n @owner_type: #GType type that uses (introduces) this parameter\n\n All other fields of the GParamSpec struct are private and\n should not be used directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpec>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(owner_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nick) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_nick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blurb) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_blurb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_id) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(param_id)
        )
    );
}
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
    pub value_is_valid: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *const GValue) -> gboolean,
    >,
    pub dummy: [gpointer; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecClass>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_set_default) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_validate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_cmp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(values_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_is_valid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_is_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(dummy)
        )
    );
}
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[test]
fn bindgen_test_layout__GParameter() {
    const UNINIT: ::std::mem::MaybeUninit<_GParameter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParameter>(),
        32usize,
        concat!("Size of: ", stringify!(_GParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParameter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(value)
        )
    );
}
impl ::std::fmt::Debug for _GParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_GParameter {{ name: {:?}, value: {:?} }}",
            self.name, self.value
        )
    }
}
extern "C" {
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
extern "C" {
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_is_valid(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gint;
}
extern "C" {
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
extern "C" {
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
}
#[test]
fn bindgen_test_layout__GParamSpecTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecTypeInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_preallocs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_set_default) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_validate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_cmp) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(values_cmp)
        )
    );
}
extern "C" {
    pub fn g_param_type_register_static(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
}
extern "C" {
    pub fn g_param_spec_is_valid_name(name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn _g_param_type_register_static_constant(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
        opt_type: GType,
    ) -> GType;
}
extern "C" {
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
extern "C" {
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
}
extern "C" {
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType)
        -> *mut GList;
}
extern "C" {
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
#[doc = " GClosure:\n @in_marshal: Indicates whether the closure is currently being invoked with\n  g_closure_invoke()\n @is_invalid: Indicates whether the closure has been invalidated by\n  g_closure_invalidate()\n\n A #GClosure represents a callback supplied by the programmer."]
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
#[doc = " GCallback:\n\n The type used for callback functions in structure definitions and function\n signatures.\n\n This doesn't mean that all callback functions must take no  parameters and\n return void. The required signature of a callback function is determined by\n the context in which is used (e.g. the signal to which it is connected).\n\n Use G_CALLBACK() to cast the callback function to a #GCallback."]
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " GClosureNotify:\n @data: data specified when registering the notification callback\n @closure: the #GClosure on which the notification is emitted\n\n The type used for the various notification callbacks which can be registered\n on closures."]
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
#[doc = " GClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @n_param_values: the length of the @param_values array\n @param_values: (array length=n_param_values): an array of\n  #GValues holding the arguments on which to invoke the\n  callback of @closure\n @invocation_hint: (nullable): the invocation hint given as the\n  last argument to g_closure_invoke()\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n\n The type used for marshaller functions."]
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
#[doc = " GVaClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @instance: (type GObject.TypeInstance): the instance on which the closure is\n  invoked.\n @args: va_list of arguments to be passed to the closure.\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n @n_params: the length of the @param_types array\n @param_types: (array length=n_params): the #GType of each argument from\n  @args.\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
#[doc = " GCClosure:\n @closure: the #GClosure\n @callback: the callback function\n\n A #GCClosure is a specialization of #GClosure for C function callbacks."]
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[test]
fn bindgen_test_layout__GClosureNotifyData() {
    const UNINIT: ::std::mem::MaybeUninit<_GClosureNotifyData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GClosureNotifyData>(),
        16usize,
        concat!("Size of: ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosureNotifyData>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(notify)
        )
    );
}
#[doc = " GClosure:\n @in_marshal: Indicates whether the closure is currently being invoked with\n  g_closure_invoke()\n @is_invalid: Indicates whether the closure has been invalidated by\n  g_closure_invalidate()\n\n A #GClosure represents a callback supplied by the programmer."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GClosure {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[test]
fn bindgen_test_layout__GClosure() {
    const UNINIT: ::std::mem::MaybeUninit<_GClosure> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GClosure>(),
        32usize,
        concat!("Size of: ", stringify!(_GClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marshal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(marshal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notifiers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(notifiers)
        )
    );
}
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[test]
fn bindgen_test_layout__GCClosure() {
    const UNINIT: ::std::mem::MaybeUninit<_GCClosure> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCClosure>(),
        40usize,
        concat!("Size of: ", stringify!(_GCClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCClosure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_sink(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_unref(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
extern "C" {
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
}
extern "C" {
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: va_list,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
pub type GSignalQuery = _GSignalQuery;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
pub type GSignalInvocationHint = _GSignalInvocationHint;
#[doc = " GSignalCMarshaller:\n\n This is the signature of marshaller functions, required to marshall\n arrays of parameter values to signal emissions into C language callback\n invocations.\n\n It is merely an alias to #GClosureMarshal since the #GClosure mechanism\n takes over responsibility of actual function invocation for the signal\n system."]
pub type GSignalCMarshaller = GClosureMarshal;
#[doc = " GSignalCVaMarshaller:\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GSignalCVaMarshaller = GVaClosureMarshal;
#[doc = " GSignalEmissionHook:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @n_param_values: the number of parameters to the function, including\n  the instance on which the signal was emitted.\n @param_values: (array length=n_param_values): the instance on which\n  the signal was emitted, followed by the parameters of the emission.\n @data: user data associated with the hook.\n\n A simple function pointer to get invoked when the signal is emitted.\n\n Emission hooks allow you to tie a hook to the signal type, so that it will\n trap all emissions of that signal, from any object.\n\n You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.\n\n Returns: whether it wants to stay connected. If it returns %FALSE, the signal\n  hook is disconnected (and destroyed)."]
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        n_param_values: guint,
        param_values: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSignalAccumulator:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @return_accu: Accumulator to collect callback return values in, this\n  is the return value of the current signal emission.\n @handler_return: A #GValue holding the return value of the signal handler.\n @data: Callback data that was specified when creating the signal.\n\n The signal accumulator is a special callback function that can be used\n to collect return values of the various callbacks that are called\n during a signal emission.\n\n The signal accumulator is specified at signal creation time, if it is\n left %NULL, no accumulation of callback return values is performed.\n The return value of signal emissions is then the value returned by the\n last callback.\n\n Returns: The accumulator function returns whether the signal emission\n  should be aborted. Returning %TRUE will continue with\n  the signal emission. Returning %FALSE will abort the current emission.\n  Since 2.62, returning %FALSE will skip to the CLEANUP stage. In this case,\n  emission will occur as normal in the CLEANUP stage and the handler's\n  return value will be accumulated."]
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
pub const GSignalFlags_G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const GSignalFlags_G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const GSignalFlags_G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const GSignalFlags_G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const GSignalFlags_G_SIGNAL_ACTION: GSignalFlags = 32;
pub const GSignalFlags_G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const GSignalFlags_G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const GSignalFlags_G_SIGNAL_DEPRECATED: GSignalFlags = 256;
pub const GSignalFlags_G_SIGNAL_ACCUMULATOR_FIRST_RUN: GSignalFlags = 131072;
#[doc = " GSignalFlags:\n @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.\n @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.\n @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.\n @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in\n  emission for this very object will not be emitted recursively,\n  but instead cause the first emission to be restarted.\n @G_SIGNAL_DETAILED: This signal supports \"::detail\" appendices to the signal name\n  upon handler connections and emissions.\n @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive\n  objects from user code via g_signal_emit() and friends, without\n  the need of being embedded into extra code that performs pre or\n  post emission adjustments on the object. They can also be thought\n  of as object methods which can be called generically by\n  third-party code.\n @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.\n @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the\n   arguments, even if there are no signal handlers connected.  Since 2.30.\n @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed\n   in a future version. A warning will be generated if it is connected while\n   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.\n @G_SIGNAL_ACCUMULATOR_FIRST_RUN: Only used in #GSignalAccumulator accumulator\n   functions for the #GSignalInvocationHint::run_type field to mark the first\n   call to the accumulator function for a signal emission.  Since 2.68.\n\n The signal flags are used to specify a signal's behaviour."]
pub type GSignalFlags = ::std::os::raw::c_uint;
pub const GConnectFlags_G_CONNECT_DEFAULT: GConnectFlags = 0;
pub const GConnectFlags_G_CONNECT_AFTER: GConnectFlags = 1;
pub const GConnectFlags_G_CONNECT_SWAPPED: GConnectFlags = 2;
#[doc = " GConnectFlags:\n @G_CONNECT_DEFAULT: Default behaviour (no special flags). Since: 2.74\n @G_CONNECT_AFTER: If set, the handler should be called after the\n  default handler of the signal. Normally, the handler is called before\n  the default handler.\n @G_CONNECT_SWAPPED: If set, the instance and data should be swapped when\n  calling the handler; see g_signal_connect_swapped() for an example.\n\n The connection flags are used to specify the behaviour of a signal's\n connection."]
pub type GConnectFlags = ::std::os::raw::c_uint;
pub const GSignalMatchType_G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const GSignalMatchType_G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;
#[doc = " GSignalMatchType:\n @G_SIGNAL_MATCH_ID: The signal id must be equal.\n @G_SIGNAL_MATCH_DETAIL: The signal detail must be equal.\n @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.\n @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.\n @G_SIGNAL_MATCH_DATA: The closure data must be the same.\n @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may be matched.\n\n The match types specify what g_signal_handlers_block_matched(),\n g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()\n match signals by."]
pub type GSignalMatchType = ::std::os::raw::c_uint;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[test]
fn bindgen_test_layout__GSignalInvocationHint() {
    const UNINIT: ::std::mem::MaybeUninit<_GSignalInvocationHint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSignalInvocationHint>(),
        12usize,
        concat!("Size of: ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalInvocationHint>(),
        4usize,
        concat!("Alignment of ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(run_type)
        )
    );
}
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[test]
fn bindgen_test_layout__GSignalQuery() {
    const UNINIT: ::std::mem::MaybeUninit<_GSignalQuery> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSignalQuery>(),
        56usize,
        concat!("Size of: ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(n_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_types) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(param_types)
        )
    );
}
extern "C" {
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: va_list,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    pub fn g_signal_set_va_marshaller(
        signal_id: guint,
        instance_type: GType,
        va_marshaller: GSignalCVaMarshaller,
    );
}
extern "C" {
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: guint,
        detail: GQuark,
        return_value: *mut GValue,
    );
}
extern "C" {
    pub fn g_signal_emit_valist(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        var_args: va_list,
    );
}
extern "C" {
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
extern "C" {
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
extern "C" {
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
extern "C" {
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
extern "C" {
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
extern "C" {
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
extern "C" {
    pub fn g_signal_is_valid_name(name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
extern "C" {
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
extern "C" {
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
extern "C" {
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
extern "C" {
    pub fn g_signal_has_handler_pending(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_connect_closure(
        instance: gpointer,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_clear_signal_handler(handler_id_ptr: *mut gulong, instance: gpointer);
}
extern "C" {
    pub fn g_signal_override_class_closure(
        signal_id: guint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
}
extern "C" {
    pub fn g_signal_override_class_handler(
        signal_name: *const gchar,
        instance_type: GType,
        class_handler: GCallback,
    );
}
extern "C" {
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
}
extern "C" {
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
extern "C" {
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
extern "C" {
    pub fn _g_signals_destroy(itype: GType);
}
extern "C" {
    pub fn g_date_get_type() -> GType;
}
extern "C" {
    pub fn g_strv_get_type() -> GType;
}
extern "C" {
    pub fn g_gstring_get_type() -> GType;
}
extern "C" {
    pub fn g_hash_table_get_type() -> GType;
}
extern "C" {
    pub fn g_array_get_type() -> GType;
}
extern "C" {
    pub fn g_byte_array_get_type() -> GType;
}
extern "C" {
    pub fn g_ptr_array_get_type() -> GType;
}
extern "C" {
    pub fn g_bytes_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_type_get_gtype() -> GType;
}
extern "C" {
    pub fn g_regex_get_type() -> GType;
}
extern "C" {
    pub fn g_match_info_get_type() -> GType;
}
extern "C" {
    pub fn g_error_get_type() -> GType;
}
extern "C" {
    pub fn g_date_time_get_type() -> GType;
}
extern "C" {
    pub fn g_time_zone_get_type() -> GType;
}
extern "C" {
    pub fn g_io_channel_get_type() -> GType;
}
extern "C" {
    pub fn g_io_condition_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_builder_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_dict_get_type() -> GType;
}
extern "C" {
    pub fn g_key_file_get_type() -> GType;
}
extern "C" {
    pub fn g_main_loop_get_type() -> GType;
}
extern "C" {
    pub fn g_main_context_get_type() -> GType;
}
extern "C" {
    pub fn g_source_get_type() -> GType;
}
extern "C" {
    pub fn g_pollfd_get_type() -> GType;
}
extern "C" {
    pub fn g_thread_get_type() -> GType;
}
extern "C" {
    pub fn g_checksum_get_type() -> GType;
}
extern "C" {
    pub fn g_markup_parse_context_get_type() -> GType;
}
extern "C" {
    pub fn g_mapped_file_get_type() -> GType;
}
extern "C" {
    pub fn g_option_group_get_type() -> GType;
}
extern "C" {
    pub fn g_uri_get_type() -> GType;
}
extern "C" {
    pub fn g_tree_get_type() -> GType;
}
extern "C" {
    pub fn g_pattern_spec_get_type() -> GType;
}
extern "C" {
    pub fn g_bookmark_file_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_get_gtype() -> GType;
}
#[doc = " GBoxedCopyFunc:\n @boxed: (not nullable): The boxed structure to be copied.\n\n This function is provided by the user and should produce a copy\n of the passed in boxed structure.\n\n Returns: (not nullable): The newly created copy of the boxed structure."]
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
#[doc = " GBoxedFreeFunc:\n @boxed: (not nullable): The boxed structure to be freed.\n\n This function is provided by the user and should free the boxed\n structure passed."]
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
extern "C" {
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
extern "C" {
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_boxed_type_register_static(
        name: *const gchar,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
}
extern "C" {
    pub fn g_closure_get_type() -> GType;
}
extern "C" {
    pub fn g_value_get_type() -> GType;
}
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GObject = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GObjectClass = _GObjectClass;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GInitiallyUnowned = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GInitiallyUnownedClass = _GObjectClass;
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
pub type GObjectConstructParam = _GObjectConstructParam;
#[doc = " GObjectGetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: a #GValue to return the property value in\n @pspec: the #GParamSpec describing the property\n\n The type of the @get_property function of #GObjectClass."]
pub type GObjectGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectSetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: the new value for the property\n @pspec: the #GParamSpec describing the property\n\n The type of the @set_property function of #GObjectClass."]
pub type GObjectSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectFinalizeFunc:\n @object: the #GObject being finalized\n\n The type of the @finalize function of #GObjectClass."]
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
#[doc = " GWeakNotify:\n @data: data that was provided when the weak reference was established\n @where_the_object_was: the object being disposed\n\n A #GWeakNotify function can be added to an object as a callback that gets\n triggered when the object is finalized.\n\n Since the object is already being disposed when the #GWeakNotify is called,\n there's not much you could do with the object, apart from e.g. using its\n address as hash-index or the like.\n\n In particular, this means its invalid to call g_object_ref(),\n g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),\n g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls\n them on the object from this callback."]
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub n_construct_properties: gsize,
    pub pspecs: gpointer,
    pub n_pspecs: gsize,
    pub pdummy: [gpointer; 3usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GObjectClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObjectClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).construct_properties) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(construct_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constructor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_property) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_property) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispose) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch_properties_changed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispatch_properties_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constructed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_construct_properties) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(n_construct_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pspecs) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pspecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_pspecs) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(n_pspecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    const UNINIT: ::std::mem::MaybeUninit<_GObjectConstructParam> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObjectConstructParam>(),
        16usize,
        concat!("Size of: ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectConstructParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pspec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(pspec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " GInitiallyUnowned:\n\n A type for objects that have an initially floating reference.\n\n All the fields in the `GInitiallyUnowned` structure are private to the\n implementation and should never be accessed directly.\n/\n/**\n GInitiallyUnownedClass:\n\n The class structure for the GInitiallyUnowned type."]
    pub fn g_initially_unowned_get_type() -> GType;
}
extern "C" {
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        name: *const gchar,
    );
}
extern "C" {
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: guint,
        pspecs: *mut *mut GParamSpec,
    );
}
extern "C" {
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    pub fn g_object_get_type() -> GType;
}
extern "C" {
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
extern "C" {
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: guint,
        names: *mut *const ::std::os::raw::c_char,
        values: *const GValue,
    ) -> *mut GObject;
}
extern "C" {
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
    ) -> gpointer;
}
extern "C" {
    pub fn g_object_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: va_list,
    ) -> *mut GObject;
}
extern "C" {
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
extern "C" {
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
extern "C" {
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *const GValue,
    );
}
extern "C" {
    pub fn g_object_set_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: va_list,
    );
}
extern "C" {
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *mut GValue,
    );
}
extern "C" {
    pub fn g_object_get_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: va_list,
    );
}
extern "C" {
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *const GValue,
    );
}
extern "C" {
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *mut GValue,
    );
}
extern "C" {
    pub fn g_object_freeze_notify(object: *mut GObject);
}
extern "C" {
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
extern "C" {
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_thaw_notify(object: *mut GObject);
}
extern "C" {
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_take_ref(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_unref(object: gpointer);
}
extern "C" {
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
extern "C" {
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
#[doc = " GToggleNotify:\n @data: Callback data passed to g_object_add_toggle_ref()\n @object: The object on which g_object_add_toggle_ref() was called.\n @is_last_ref: %TRUE if the toggle reference is now the\n  last reference to the object. %FALSE if the toggle\n  reference was the last reference and there are now other\n  references.\n\n A callback function used for notification when the state\n of a toggle reference changes.\n\n See also: g_object_add_toggle_ref()"]
pub type GToggleNotify = ::std::option::Option<
    unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean),
>;
extern "C" {
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
extern "C" {
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const gchar,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const gchar,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
extern "C" {
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    pub fn g_object_force_floating(object: *mut GObject);
}
extern "C" {
    pub fn g_object_run_dispose(object: *mut GObject);
}
extern "C" {
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
extern "C" {
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
}
#[test]
fn bindgen_test_layout_GWeakRef__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<GWeakRef__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
impl ::std::fmt::Debug for GWeakRef__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "GWeakRef__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_GWeakRef() {
    const UNINIT: ::std::mem::MaybeUninit<GWeakRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GWeakRef>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef),
            "::",
            stringify!(priv_)
        )
    );
}
impl ::std::fmt::Debug for GWeakRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "GWeakRef {{ priv: {:?} }}", self.priv_)
    }
}
extern "C" {
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
extern "C" {
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
extern "C" {
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
extern "C" {
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
#[doc = " GBinding:\n\n GBinding is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.26"]
pub type GBinding = _GBinding;
#[doc = " GBindingTransformFunc:\n @binding: a #GBinding\n @from_value: the #GValue containing the value to transform\n @to_value: the #GValue in which to store the transformed value\n @user_data: data passed to the transform function\n\n A function to be called to transform @from_value to @to_value.\n\n If this is the @transform_to function of a binding, then @from_value\n is the @source_property on the @source object, and @to_value is the\n @target_property on the @target object. If this is the\n @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,\n then those roles are reversed.\n\n Returns: %TRUE if the transformation was successful, and %FALSE\n   otherwise\n\n Since: 2.26"]
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GBinding,
        from_value: *const GValue,
        to_value: *mut GValue,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GBindingFlags_G_BINDING_DEFAULT: GBindingFlags = 0;
pub const GBindingFlags_G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const GBindingFlags_G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;
#[doc = " GBindingFlags:\n @G_BINDING_DEFAULT: The default binding; if the source property\n   changes, the target property is updated with its value.\n @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the\n   property of the source or the property of the target changes,\n   the other is updated.\n @G_BINDING_SYNC_CREATE: Synchronize the values of the source and\n   target properties when creating the binding; the direction of\n   the synchronization is always from the source to the target.\n @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are\n   booleans, setting one to %TRUE will result in the other being\n   set to %FALSE and vice versa. This flag will only work for\n   boolean properties, and cannot be used when passing custom\n   transformation functions to g_object_bind_property_full().\n\n Flags to be passed to g_object_bind_property() or\n g_object_bind_property_full().\n\n This enumeration can be extended at later date.\n\n Since: 2.26"]
pub type GBindingFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_binding_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
extern "C" {
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_dup_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_dup_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    pub fn g_binding_unbind(binding: *mut GBinding);
}
extern "C" {
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
extern "C" {
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
extern "C" {
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBindingGroup {
    _unused: [u8; 0],
}
#[doc = " GBindingGroup:\n\n GBindingGroup is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.72"]
pub type GBindingGroup = _GBindingGroup;
extern "C" {
    pub fn g_binding_group_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_group_new() -> *mut GBindingGroup;
}
extern "C" {
    pub fn g_binding_group_dup_source(self_: *mut GBindingGroup) -> gpointer;
}
extern "C" {
    pub fn g_binding_group_set_source(self_: *mut GBindingGroup, source: gpointer);
}
extern "C" {
    pub fn g_binding_group_bind(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    );
}
extern "C" {
    pub fn g_binding_group_bind_full(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        user_data_destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_binding_group_bind_with_closures(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    );
}
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
pub type GEnumClass = _GEnumClass;
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
pub type GFlagsClass = _GFlagsClass;
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
pub type GEnumValue = _GEnumValue;
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
pub type GFlagsValue = _GFlagsValue;
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[test]
fn bindgen_test_layout__GEnumClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GEnumClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEnumClass>(),
        32usize,
        concat!("Size of: ", stringify!(_GEnumClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[test]
fn bindgen_test_layout__GFlagsClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFlagsClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFlagsClass>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GEnumValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GEnumValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEnumValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GEnumValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_nick) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_nick)
        )
    );
}
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GFlagsValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GFlagsValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFlagsValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_nick) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_nick)
        )
    );
}
extern "C" {
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint)
        -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_enum_to_string(g_enum_type: GType, value: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_flags_to_string(flags_type: GType, value: guint) -> *mut gchar;
}
extern "C" {
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
extern "C" {
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
extern "C" {
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
extern "C" {
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
extern "C" {
    pub fn g_enum_register_static(
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    pub fn g_flags_register_static(
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
extern "C" {
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
}
extern "C" {
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
}
extern "C" {
    pub fn g_unicode_type_get_type() -> GType;
}
extern "C" {
    pub fn g_unicode_break_type_get_type() -> GType;
}
extern "C" {
    pub fn g_unicode_script_get_type() -> GType;
}
extern "C" {
    pub fn g_normalize_mode_get_type() -> GType;
}
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
pub type GParamSpecChar = _GParamSpecChar;
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
pub type GParamSpecUChar = _GParamSpecUChar;
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
pub type GParamSpecBoolean = _GParamSpecBoolean;
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
pub type GParamSpecInt = _GParamSpecInt;
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
pub type GParamSpecUInt = _GParamSpecUInt;
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
pub type GParamSpecLong = _GParamSpecLong;
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
pub type GParamSpecULong = _GParamSpecULong;
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
pub type GParamSpecInt64 = _GParamSpecInt64;
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
pub type GParamSpecUInt64 = _GParamSpecUInt64;
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
pub type GParamSpecUnichar = _GParamSpecUnichar;
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
pub type GParamSpecEnum = _GParamSpecEnum;
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
pub type GParamSpecFlags = _GParamSpecFlags;
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
pub type GParamSpecFloat = _GParamSpecFloat;
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
pub type GParamSpecDouble = _GParamSpecDouble;
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
pub type GParamSpecString = _GParamSpecString;
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
pub type GParamSpecParam = _GParamSpecParam;
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
pub type GParamSpecBoxed = _GParamSpecBoxed;
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
pub type GParamSpecPointer = _GParamSpecPointer;
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
pub type GParamSpecValueArray = _GParamSpecValueArray;
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
pub type GParamSpecObject = _GParamSpecObject;
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
pub type GParamSpecOverride = _GParamSpecOverride;
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
pub type GParamSpecGType = _GParamSpecGType;
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
pub type GParamSpecVariant = _GParamSpecVariant;
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[test]
fn bindgen_test_layout__GParamSpecChar() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecChar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[test]
fn bindgen_test_layout__GParamSpecUChar() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUChar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[test]
fn bindgen_test_layout__GParamSpecBoolean() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecBoolean> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoolean>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecInt() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecInt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUInt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[test]
fn bindgen_test_layout__GParamSpecLong() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecLong> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecLong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecLong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[test]
fn bindgen_test_layout__GParamSpecULong() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecULong> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecULong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecULong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[test]
fn bindgen_test_layout__GParamSpecInt64() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecInt64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt64() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUInt64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[test]
fn bindgen_test_layout__GParamSpecUnichar() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUnichar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUnichar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUnichar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecEnum() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecEnum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecEnum>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecEnum>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_class) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(enum_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecFlags() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecFlags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFlags>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_class) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(flags_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[test]
fn bindgen_test_layout__GParamSpecFloat() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFloat>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epsilon) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(epsilon)
        )
    );
}
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[test]
fn bindgen_test_layout__GParamSpecDouble() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecDouble>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epsilon) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(epsilon)
        )
    );
}
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecString() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecString>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_first) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_nth) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_nth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substitutor) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(substitutor)
        )
    );
}
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        null_fold_if_empty: guint,
        ensure_non_null: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecParam() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecParam>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecParam),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecBoxed() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecBoxed> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoxed>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoxed>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoxed),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecPointer() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecPointer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecPointer>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecPointer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecPointer),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecValueArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecValueArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecValueArray>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_spec) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(element_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_n_elements) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(fixed_n_elements)
        )
    );
}
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecObject>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecObject),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecOverride() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecOverride> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecOverride>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecOverride>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overridden) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(overridden)
        )
    );
}
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[test]
fn bindgen_test_layout__GParamSpecGType() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecGType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecGType>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecGType>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_a_type) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(is_a_type)
        )
    );
}
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecVariant() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecVariant> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecVariant>(),
        120usize,
        concat!("Size of: ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecVariant>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_pointer(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_override(
        name: *const gchar,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub static mut g_param_spec_types: *mut GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalGroup {
    _unused: [u8; 0],
}
#[doc = " GSignalGroup:\n\n #GSignalGroup is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.72"]
pub type GSignalGroup = _GSignalGroup;
extern "C" {
    pub fn g_signal_group_get_type() -> GType;
}
extern "C" {
    pub fn g_signal_group_new(target_type: GType) -> *mut GSignalGroup;
}
extern "C" {
    pub fn g_signal_group_set_target(self_: *mut GSignalGroup, target: gpointer);
}
extern "C" {
    pub fn g_signal_group_dup_target(self_: *mut GSignalGroup) -> gpointer;
}
extern "C" {
    pub fn g_signal_group_block(self_: *mut GSignalGroup);
}
extern "C" {
    pub fn g_signal_group_unblock(self_: *mut GSignalGroup);
}
extern "C" {
    pub fn g_signal_group_connect_closure(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    );
}
extern "C" {
    pub fn g_signal_group_connect_object(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        object: gpointer,
        flags: GConnectFlags,
    );
}
extern "C" {
    pub fn g_signal_group_connect_data(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        notify: GClosureNotify,
        flags: GConnectFlags,
    );
}
extern "C" {
    pub fn g_signal_group_connect(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_signal_group_connect_after(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_signal_group_connect_swapped(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
extern "C" {
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
#[doc = " GTypeModule:\n @name: the name of the module\n\n The members of the GTypeModule structure should not\n be accessed directly, except for the @name field."]
pub type GTypeModule = _GTypeModule;
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
pub type GTypeModuleClass = _GTypeModuleClass;
pub type GTypeModule_autoptr = *mut GTypeModule;
pub type GTypeModule_listautoptr = *mut GList;
pub type GTypeModule_slistautoptr = *mut GSList;
pub type GTypeModule_queueautoptr = *mut GQueue;
#[doc = " GTypeModule:\n @name: the name of the module\n\n The members of the GTypeModule structure should not\n be accessed directly, except for the @name field."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[test]
fn bindgen_test_layout__GTypeModule() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeModule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeModule>(),
        56usize,
        concat!("Size of: ", stringify!(_GTypeModule))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModule>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(use_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_infos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(type_infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_infos) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(interface_infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GTypeModuleClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeModuleClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeModuleClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModuleClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unload) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved4)
        )
    );
}
extern "C" {
    pub fn g_type_module_get_type() -> GType;
}
extern "C" {
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
extern "C" {
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
extern "C" {
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
extern "C" {
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
extern "C" {
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
#[doc = " GTypePlugin:\n\n The GTypePlugin typedef is used as a placeholder\n for objects that implement the GTypePlugin interface.\n/\n/**\n GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
pub type GTypePluginClass = _GTypePluginClass;
#[doc = " GTypePluginUse:\n @plugin: the #GTypePlugin whose use count should be increased\n\n The type of the @use_plugin function of #GTypePluginClass, which gets called\n to increase the use count of @plugin."]
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginUnuse:\n @plugin: the #GTypePlugin whose use count should be decreased\n\n The type of the @unuse_plugin function of #GTypePluginClass."]
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginCompleteTypeInfo:\n @plugin: the #GTypePlugin\n @g_type: the #GType whose info is completed\n @info: the #GTypeInfo struct to fill in\n @value_table: the #GTypeValueTable to fill in\n\n The type of the @complete_type_info function of #GTypePluginClass."]
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    ),
>;
#[doc = " GTypePluginCompleteInterfaceInfo:\n @plugin: the #GTypePlugin\n @instance_type: the #GType of an instantiatable type to which the interface\n  is added\n @interface_type: the #GType of the interface whose info is completed\n @info: the #GInterfaceInfo to fill in\n\n The type of the @complete_interface_info function of #GTypePluginClass."]
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    ),
>;
#[doc = " GTypePlugin:\n\n The GTypePlugin typedef is used as a placeholder\n for objects that implement the GTypePlugin interface.\n/\n/**\n GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[test]
fn bindgen_test_layout__GTypePluginClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypePluginClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypePluginClass>(),
        48usize,
        concat!("Size of: ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypePluginClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(base_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_plugin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(use_plugin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unuse_plugin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(unuse_plugin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complete_type_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_type_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complete_interface_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_interface_info)
        )
    );
}
extern "C" {
    pub fn g_type_plugin_get_type() -> GType;
}
extern "C" {
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
extern "C" {
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
#[doc = " GValueArray:\n @n_values: number of values contained in the array\n @values: array of values\n\n A #GValueArray contains an array of #GValue elements."]
pub type GValueArray = _GValueArray;
#[doc = " GValueArray:\n @n_values: number of values contained in the array\n @values: array of values\n\n A #GValueArray contains an array of #GValue elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[test]
fn bindgen_test_layout__GValueArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GValueArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GValueArray>(),
        24usize,
        concat!("Size of: ", stringify!(_GValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValueArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_prealloced) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_prealloced)
        )
    );
}
extern "C" {
    pub fn g_value_array_get_type() -> GType;
}
extern "C" {
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
extern "C" {
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
extern "C" {
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: guint,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: GCompareFunc,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
extern "C" {
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
extern "C" {
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
extern "C" {
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
extern "C" {
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
extern "C" {
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
extern "C" {
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
extern "C" {
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
extern "C" {
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
extern "C" {
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
extern "C" {
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
extern "C" {
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
extern "C" {
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
extern "C" {
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
extern "C" {
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
extern "C" {
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
extern "C" {
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
extern "C" {
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
extern "C" {
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
extern "C" {
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
extern "C" {
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
extern "C" {
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
extern "C" {
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
extern "C" {
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_set_interned_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
extern "C" {
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
extern "C" {
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
extern "C" {
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_gtype_get_type() -> GType;
}
extern "C" {
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
extern "C" {
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
extern "C" {
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
extern "C" {
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
extern "C" {
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
extern "C" {
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
#[doc = " gchararray:\n\n A C representable type name for %G_TYPE_STRING."]
pub type gchararray = *mut gchar;
pub type GClosure_autoptr = *mut GClosure;
pub type GClosure_listautoptr = *mut GList;
pub type GClosure_slistautoptr = *mut GSList;
pub type GClosure_queueautoptr = *mut GQueue;
pub type GEnumClass_autoptr = *mut GEnumClass;
pub type GEnumClass_listautoptr = *mut GList;
pub type GEnumClass_slistautoptr = *mut GSList;
pub type GEnumClass_queueautoptr = *mut GQueue;
pub type GFlagsClass_autoptr = *mut GFlagsClass;
pub type GFlagsClass_listautoptr = *mut GList;
pub type GFlagsClass_slistautoptr = *mut GSList;
pub type GFlagsClass_queueautoptr = *mut GQueue;
pub type GObject_autoptr = *mut GObject;
pub type GObject_listautoptr = *mut GList;
pub type GObject_slistautoptr = *mut GSList;
pub type GObject_queueautoptr = *mut GQueue;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type GInitiallyUnowned_listautoptr = *mut GList;
pub type GInitiallyUnowned_slistautoptr = *mut GSList;
pub type GInitiallyUnowned_queueautoptr = *mut GQueue;
pub type GParamSpec_autoptr = *mut GParamSpec;
pub type GParamSpec_listautoptr = *mut GList;
pub type GParamSpec_slistautoptr = *mut GSList;
pub type GParamSpec_queueautoptr = *mut GQueue;
pub type GTypeClass_autoptr = *mut GTypeClass;
pub type GTypeClass_listautoptr = *mut GList;
pub type GTypeClass_slistautoptr = *mut GSList;
pub type GTypeClass_queueautoptr = *mut GQueue;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NONE: GAppInfoCreateFlags = 0;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NEEDS_TERMINAL: GAppInfoCreateFlags = 1;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_URIS: GAppInfoCreateFlags = 2;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: GAppInfoCreateFlags =
    4;
#[doc = " GAppInfoCreateFlags:\n @G_APP_INFO_CREATE_NONE: No flags.\n @G_APP_INFO_CREATE_NEEDS_TERMINAL: Application opens in a terminal window.\n @G_APP_INFO_CREATE_SUPPORTS_URIS: Application supports URI arguments.\n @G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: Application supports startup notification. Since 2.26\n\n Flags used when creating a #GAppInfo."]
pub type GAppInfoCreateFlags = ::std::os::raw::c_uint;
pub const GConverterFlags_G_CONVERTER_NO_FLAGS: GConverterFlags = 0;
pub const GConverterFlags_G_CONVERTER_INPUT_AT_END: GConverterFlags = 1;
pub const GConverterFlags_G_CONVERTER_FLUSH: GConverterFlags = 2;
#[doc = " GConverterFlags:\n @G_CONVERTER_NO_FLAGS: No flags.\n @G_CONVERTER_INPUT_AT_END: At end of input data\n @G_CONVERTER_FLUSH: Flush data\n\n Flags used when calling a g_converter_convert().\n\n Since: 2.24"]
pub type GConverterFlags = ::std::os::raw::c_uint;
pub const GConverterResult_G_CONVERTER_ERROR: GConverterResult = 0;
pub const GConverterResult_G_CONVERTER_CONVERTED: GConverterResult = 1;
pub const GConverterResult_G_CONVERTER_FINISHED: GConverterResult = 2;
pub const GConverterResult_G_CONVERTER_FLUSHED: GConverterResult = 3;
#[doc = " GConverterResult:\n @G_CONVERTER_ERROR: There was an error during conversion.\n @G_CONVERTER_CONVERTED: Some data was consumed or produced\n @G_CONVERTER_FINISHED: The conversion is finished\n @G_CONVERTER_FLUSHED: Flushing is finished\n\n Results returned from g_converter_convert().\n\n Since: 2.24"]
pub type GConverterResult = ::std::os::raw::c_uint;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: GDataStreamByteOrder = 0;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: GDataStreamByteOrder = 1;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: GDataStreamByteOrder = 2;
#[doc = " GDataStreamByteOrder:\n @G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: Selects Big Endian byte order.\n @G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: Selects Little Endian byte order.\n @G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: Selects endianness based on host machine's architecture.\n\n #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources\n across various machine architectures.\n"]
pub type GDataStreamByteOrder = ::std::os::raw::c_uint;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_LF: GDataStreamNewlineType = 0;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR: GDataStreamNewlineType = 1;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR_LF: GDataStreamNewlineType = 2;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_ANY: GDataStreamNewlineType = 3;
#[doc = " GDataStreamNewlineType:\n @G_DATA_STREAM_NEWLINE_TYPE_LF: Selects \"LF\" line endings, common on most modern UNIX platforms.\n @G_DATA_STREAM_NEWLINE_TYPE_CR: Selects \"CR\" line endings.\n @G_DATA_STREAM_NEWLINE_TYPE_CR_LF: Selects \"CR, LF\" line ending, common on Microsoft Windows.\n @G_DATA_STREAM_NEWLINE_TYPE_ANY: Automatically try to handle any line ending type.\n\n #GDataStreamNewlineType is used when checking for or setting the line endings for a given file."]
pub type GDataStreamNewlineType = ::std::os::raw::c_uint;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INVALID: GFileAttributeType = 0;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRING: GFileAttributeType = 1;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: GFileAttributeType = 2;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BOOLEAN: GFileAttributeType = 3;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT32: GFileAttributeType = 4;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT32: GFileAttributeType = 5;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT64: GFileAttributeType = 6;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT64: GFileAttributeType = 7;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_OBJECT: GFileAttributeType = 8;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRINGV: GFileAttributeType = 9;
#[doc = " GFileAttributeType:\n @G_FILE_ATTRIBUTE_TYPE_INVALID: indicates an invalid or uninitialized type.\n @G_FILE_ATTRIBUTE_TYPE_STRING: a null terminated UTF8 string.\n @G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: a zero terminated string of non-zero bytes.\n @G_FILE_ATTRIBUTE_TYPE_BOOLEAN: a boolean value.\n @G_FILE_ATTRIBUTE_TYPE_UINT32: an unsigned 4-byte/32-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_INT32: a signed 4-byte/32-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_UINT64: an unsigned 8-byte/64-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_INT64: a signed 8-byte/64-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_OBJECT: a #GObject.\n @G_FILE_ATTRIBUTE_TYPE_STRINGV: a %NULL terminated char **. Since 2.22\n\n The data types for file attributes."]
pub type GFileAttributeType = ::std::os::raw::c_uint;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_NONE: GFileAttributeInfoFlags = 0;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: GFileAttributeInfoFlags = 1;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: GFileAttributeInfoFlags =
    2;
#[doc = " GFileAttributeInfoFlags:\n @G_FILE_ATTRIBUTE_INFO_NONE: no flags set.\n @G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: copy the attribute values when the file is copied.\n @G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: copy the attribute values when the file is moved.\n\n Flags specifying the behaviour of an attribute."]
pub type GFileAttributeInfoFlags = ::std::os::raw::c_uint;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_UNSET: GFileAttributeStatus = 0;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_SET: GFileAttributeStatus = 1;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: GFileAttributeStatus = 2;
#[doc = " GFileAttributeStatus:\n @G_FILE_ATTRIBUTE_STATUS_UNSET: Attribute value is unset (empty).\n @G_FILE_ATTRIBUTE_STATUS_SET: Attribute value is set.\n @G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: Indicates an error in setting the value.\n\n Used by g_file_set_attributes_from_info() when setting file attributes."]
pub type GFileAttributeStatus = ::std::os::raw::c_uint;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NONE: GFileQueryInfoFlags = 0;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: GFileQueryInfoFlags = 1;
#[doc = " GFileQueryInfoFlags:\n @G_FILE_QUERY_INFO_NONE: No flags set.\n @G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: Don't follow symlinks.\n\n Flags used when querying a #GFileInfo."]
pub type GFileQueryInfoFlags = ::std::os::raw::c_uint;
pub const GFileCreateFlags_G_FILE_CREATE_NONE: GFileCreateFlags = 0;
pub const GFileCreateFlags_G_FILE_CREATE_PRIVATE: GFileCreateFlags = 1;
pub const GFileCreateFlags_G_FILE_CREATE_REPLACE_DESTINATION: GFileCreateFlags = 2;
#[doc = " GFileCreateFlags:\n @G_FILE_CREATE_NONE: No flags set.\n @G_FILE_CREATE_PRIVATE: Create a file that can only be\n    accessed by the current user.\n @G_FILE_CREATE_REPLACE_DESTINATION: Replace the destination\n    as if it didn't exist before. Don't try to keep any old\n    permissions, replace instead of following links. This\n    is generally useful if you're doing a \"copy over\"\n    rather than a \"save new version of\" replace operation.\n    You can think of it as \"unlink destination\" before\n    writing to it, although the implementation may not\n    be exactly like that. This flag can only be used with\n    g_file_replace() and its variants, including g_file_replace_contents().\n    Since 2.20\n\n Flags used when an operation may create a file."]
pub type GFileCreateFlags = ::std::os::raw::c_uint;
pub const GFileMeasureFlags_G_FILE_MEASURE_NONE: GFileMeasureFlags = 0;
pub const GFileMeasureFlags_G_FILE_MEASURE_REPORT_ANY_ERROR: GFileMeasureFlags = 2;
pub const GFileMeasureFlags_G_FILE_MEASURE_APPARENT_SIZE: GFileMeasureFlags = 4;
pub const GFileMeasureFlags_G_FILE_MEASURE_NO_XDEV: GFileMeasureFlags = 8;
#[doc = " GFileMeasureFlags:\n @G_FILE_MEASURE_NONE: No flags set.\n @G_FILE_MEASURE_REPORT_ANY_ERROR: Report any error encountered\n   while traversing the directory tree.  Normally errors are only\n   reported for the toplevel file.\n @G_FILE_MEASURE_APPARENT_SIZE: Tally usage based on apparent file\n   sizes.  Normally, the block-size is used, if available, as this is a\n   more accurate representation of disk space used.\n   Compare with `du --apparent-size`.\n   Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will\n   ignore the sizes of file types other than regular files and links, as the\n   sizes of other file types are not specified in a standard way.\n @G_FILE_MEASURE_NO_XDEV: Do not cross mount point boundaries.\n   Compare with `du -x`.\n\n Flags that can be used with g_file_measure_disk_usage().\n\n Since: 2.38"]
pub type GFileMeasureFlags = ::std::os::raw::c_uint;
pub const GMountMountFlags_G_MOUNT_MOUNT_NONE: GMountMountFlags = 0;
#[doc = " GMountMountFlags:\n @G_MOUNT_MOUNT_NONE: No flags set.\n\n Flags used when mounting a mount."]
pub type GMountMountFlags = ::std::os::raw::c_uint;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_NONE: GMountUnmountFlags = 0;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_FORCE: GMountUnmountFlags = 1;
#[doc = " GMountUnmountFlags:\n @G_MOUNT_UNMOUNT_NONE: No flags set.\n @G_MOUNT_UNMOUNT_FORCE: Unmount even if there are outstanding\n  file operations on the mount.\n\n Flags used when an unmounting a mount."]
pub type GMountUnmountFlags = ::std::os::raw::c_uint;
pub const GDriveStartFlags_G_DRIVE_START_NONE: GDriveStartFlags = 0;
#[doc = " GDriveStartFlags:\n @G_DRIVE_START_NONE: No flags set.\n\n Flags used when starting a drive.\n\n Since: 2.22"]
pub type GDriveStartFlags = ::std::os::raw::c_uint;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_UNKNOWN: GDriveStartStopType = 0;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_SHUTDOWN: GDriveStartStopType = 1;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_NETWORK: GDriveStartStopType = 2;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_MULTIDISK: GDriveStartStopType = 3;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_PASSWORD: GDriveStartStopType = 4;
#[doc = " GDriveStartStopType:\n @G_DRIVE_START_STOP_TYPE_UNKNOWN: Unknown or drive doesn't support\n    start/stop.\n @G_DRIVE_START_STOP_TYPE_SHUTDOWN: The stop method will physically\n    shut down the drive and e.g. power down the port the drive is\n    attached to.\n @G_DRIVE_START_STOP_TYPE_NETWORK: The start/stop methods are used\n    for connecting/disconnect to the drive over the network.\n @G_DRIVE_START_STOP_TYPE_MULTIDISK: The start/stop methods will\n    assemble/disassemble a virtual drive from several physical\n    drives.\n @G_DRIVE_START_STOP_TYPE_PASSWORD: The start/stop methods will\n    unlock/lock the disk (for example using the ATA <quote>SECURITY\n    UNLOCK DEVICE</quote> command)\n\n Enumeration describing how a drive can be started/stopped.\n\n Since: 2.22"]
pub type GDriveStartStopType = ::std::os::raw::c_uint;
pub const GFileCopyFlags_G_FILE_COPY_NONE: GFileCopyFlags = 0;
pub const GFileCopyFlags_G_FILE_COPY_OVERWRITE: GFileCopyFlags = 1;
pub const GFileCopyFlags_G_FILE_COPY_BACKUP: GFileCopyFlags = 2;
pub const GFileCopyFlags_G_FILE_COPY_NOFOLLOW_SYMLINKS: GFileCopyFlags = 4;
pub const GFileCopyFlags_G_FILE_COPY_ALL_METADATA: GFileCopyFlags = 8;
pub const GFileCopyFlags_G_FILE_COPY_NO_FALLBACK_FOR_MOVE: GFileCopyFlags = 16;
pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_PERMS: GFileCopyFlags = 32;
#[doc = " GFileCopyFlags:\n @G_FILE_COPY_NONE: No flags set.\n @G_FILE_COPY_OVERWRITE: Overwrite any existing files\n @G_FILE_COPY_BACKUP: Make a backup of any existing files.\n @G_FILE_COPY_NOFOLLOW_SYMLINKS: Don't follow symlinks.\n @G_FILE_COPY_ALL_METADATA: Copy all file metadata instead of just default set used for copy (see #GFileInfo).\n @G_FILE_COPY_NO_FALLBACK_FOR_MOVE: Don't use copy and delete fallback if native move not supported.\n @G_FILE_COPY_TARGET_DEFAULT_PERMS: Leaves target file with default perms, instead of setting the source file perms.\n\n Flags used when copying or moving files."]
pub type GFileCopyFlags = ::std::os::raw::c_uint;
pub const GFileMonitorFlags_G_FILE_MONITOR_NONE: GFileMonitorFlags = 0;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOUNTS: GFileMonitorFlags = 1;
pub const GFileMonitorFlags_G_FILE_MONITOR_SEND_MOVED: GFileMonitorFlags = 2;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_HARD_LINKS: GFileMonitorFlags = 4;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOVES: GFileMonitorFlags = 8;
#[doc = " GFileMonitorFlags:\n @G_FILE_MONITOR_NONE: No flags set.\n @G_FILE_MONITOR_WATCH_MOUNTS: Watch for mount events.\n @G_FILE_MONITOR_SEND_MOVED: Pair DELETED and CREATED events caused\n   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED\n   event instead (NB: not supported on all backends; the default\n   behaviour -without specifying this flag- is to send single DELETED\n   and CREATED events).  Deprecated since 2.46: use\n   %G_FILE_MONITOR_WATCH_MOVES instead.\n @G_FILE_MONITOR_WATCH_HARD_LINKS: Watch for changes to the file made\n   via another hard link. Since 2.36.\n @G_FILE_MONITOR_WATCH_MOVES: Watch for rename operations on a\n   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,\n   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT\n   events to be emitted when possible.  Since: 2.46.\n\n Flags used to set what a #GFileMonitor will watch for."]
pub type GFileMonitorFlags = ::std::os::raw::c_uint;
pub const GFileType_G_FILE_TYPE_UNKNOWN: GFileType = 0;
pub const GFileType_G_FILE_TYPE_REGULAR: GFileType = 1;
pub const GFileType_G_FILE_TYPE_DIRECTORY: GFileType = 2;
pub const GFileType_G_FILE_TYPE_SYMBOLIC_LINK: GFileType = 3;
pub const GFileType_G_FILE_TYPE_SPECIAL: GFileType = 4;
pub const GFileType_G_FILE_TYPE_SHORTCUT: GFileType = 5;
pub const GFileType_G_FILE_TYPE_MOUNTABLE: GFileType = 6;
#[doc = " GFileType:\n @G_FILE_TYPE_UNKNOWN: File's type is unknown.\n @G_FILE_TYPE_REGULAR: File handle represents a regular file.\n @G_FILE_TYPE_DIRECTORY: File handle represents a directory.\n @G_FILE_TYPE_SYMBOLIC_LINK: File handle represents a symbolic link\n    (Unix systems).\n @G_FILE_TYPE_SPECIAL: File is a \"special\" file, such as a socket, fifo,\n    block device, or character device.\n @G_FILE_TYPE_SHORTCUT: File is a shortcut (Windows systems).\n @G_FILE_TYPE_MOUNTABLE: File is a mountable location.\n\n Indicates the file's on-disk type.\n\n On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;\n use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine\n whether a file is a symlink or not. This is due to the fact that NTFS does\n not have a single filesystem object type for symbolic links - it has\n files that symlink to files, and directories that symlink to directories.\n #GFileType enumeration cannot precisely represent this important distinction,\n which is why all Windows symlinks will continue to be reported as\n %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY."]
pub type GFileType = ::std::os::raw::c_uint;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: GFilesystemPreviewType = 0;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: GFilesystemPreviewType = 1;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_NEVER: GFilesystemPreviewType = 2;
#[doc = " GFilesystemPreviewType:\n @G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: Only preview files if user has explicitly requested it.\n @G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: Preview files if user has requested preview of \"local\" files.\n @G_FILESYSTEM_PREVIEW_TYPE_NEVER: Never preview files.\n\n Indicates a hint from the file system whether files should be\n previewed in a file manager. Returned as the value of the key\n %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW."]
pub type GFilesystemPreviewType = ::std::os::raw::c_uint;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGED: GFileMonitorEvent = 0;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: GFileMonitorEvent = 1;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_DELETED: GFileMonitorEvent = 2;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CREATED: GFileMonitorEvent = 3;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: GFileMonitorEvent = 4;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_PRE_UNMOUNT: GFileMonitorEvent = 5;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_UNMOUNTED: GFileMonitorEvent = 6;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED: GFileMonitorEvent = 7;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_RENAMED: GFileMonitorEvent = 8;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_IN: GFileMonitorEvent = 9;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_OUT: GFileMonitorEvent = 10;
#[doc = " GFileMonitorEvent:\n @G_FILE_MONITOR_EVENT_CHANGED: a file changed.\n @G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: a hint that this was probably the last change in a set of changes.\n @G_FILE_MONITOR_EVENT_DELETED: a file was deleted.\n @G_FILE_MONITOR_EVENT_CREATED: a file was created.\n @G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: a file attribute was changed.\n @G_FILE_MONITOR_EVENT_PRE_UNMOUNT: the file location will soon be unmounted.\n @G_FILE_MONITOR_EVENT_UNMOUNTED: the file location was unmounted.\n @G_FILE_MONITOR_EVENT_MOVED: the file was moved -- only sent if the\n   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set\n @G_FILE_MONITOR_EVENT_RENAMED: the file was renamed within the\n   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES\n   flag is set.  Since: 2.46.\n @G_FILE_MONITOR_EVENT_MOVED_IN: the file was moved into the\n   monitored directory from another location -- only sent if the\n   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.\n @G_FILE_MONITOR_EVENT_MOVED_OUT: the file was moved out of the\n   monitored directory to another location -- only sent if the\n   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46\n\n Specifies what type of event a monitor event is."]
pub type GFileMonitorEvent = ::std::os::raw::c_uint;
pub const GIOErrorEnum_G_IO_ERROR_FAILED: GIOErrorEnum = 0;
pub const GIOErrorEnum_G_IO_ERROR_NOT_FOUND: GIOErrorEnum = 1;
pub const GIOErrorEnum_G_IO_ERROR_EXISTS: GIOErrorEnum = 2;
pub const GIOErrorEnum_G_IO_ERROR_IS_DIRECTORY: GIOErrorEnum = 3;
pub const GIOErrorEnum_G_IO_ERROR_NOT_DIRECTORY: GIOErrorEnum = 4;
pub const GIOErrorEnum_G_IO_ERROR_NOT_EMPTY: GIOErrorEnum = 5;
pub const GIOErrorEnum_G_IO_ERROR_NOT_REGULAR_FILE: GIOErrorEnum = 6;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SYMBOLIC_LINK: GIOErrorEnum = 7;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTABLE_FILE: GIOErrorEnum = 8;
pub const GIOErrorEnum_G_IO_ERROR_FILENAME_TOO_LONG: GIOErrorEnum = 9;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_FILENAME: GIOErrorEnum = 10;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_LINKS: GIOErrorEnum = 11;
pub const GIOErrorEnum_G_IO_ERROR_NO_SPACE: GIOErrorEnum = 12;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_ARGUMENT: GIOErrorEnum = 13;
pub const GIOErrorEnum_G_IO_ERROR_PERMISSION_DENIED: GIOErrorEnum = 14;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SUPPORTED: GIOErrorEnum = 15;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTED: GIOErrorEnum = 16;
pub const GIOErrorEnum_G_IO_ERROR_ALREADY_MOUNTED: GIOErrorEnum = 17;
pub const GIOErrorEnum_G_IO_ERROR_CLOSED: GIOErrorEnum = 18;
pub const GIOErrorEnum_G_IO_ERROR_CANCELLED: GIOErrorEnum = 19;
pub const GIOErrorEnum_G_IO_ERROR_PENDING: GIOErrorEnum = 20;
pub const GIOErrorEnum_G_IO_ERROR_READ_ONLY: GIOErrorEnum = 21;
pub const GIOErrorEnum_G_IO_ERROR_CANT_CREATE_BACKUP: GIOErrorEnum = 22;
pub const GIOErrorEnum_G_IO_ERROR_WRONG_ETAG: GIOErrorEnum = 23;
pub const GIOErrorEnum_G_IO_ERROR_TIMED_OUT: GIOErrorEnum = 24;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_RECURSE: GIOErrorEnum = 25;
pub const GIOErrorEnum_G_IO_ERROR_BUSY: GIOErrorEnum = 26;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_BLOCK: GIOErrorEnum = 27;
pub const GIOErrorEnum_G_IO_ERROR_HOST_NOT_FOUND: GIOErrorEnum = 28;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_MERGE: GIOErrorEnum = 29;
pub const GIOErrorEnum_G_IO_ERROR_FAILED_HANDLED: GIOErrorEnum = 30;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_OPEN_FILES: GIOErrorEnum = 31;
pub const GIOErrorEnum_G_IO_ERROR_NOT_INITIALIZED: GIOErrorEnum = 32;
pub const GIOErrorEnum_G_IO_ERROR_ADDRESS_IN_USE: GIOErrorEnum = 33;
pub const GIOErrorEnum_G_IO_ERROR_PARTIAL_INPUT: GIOErrorEnum = 34;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_DATA: GIOErrorEnum = 35;
pub const GIOErrorEnum_G_IO_ERROR_DBUS_ERROR: GIOErrorEnum = 36;
pub const GIOErrorEnum_G_IO_ERROR_HOST_UNREACHABLE: GIOErrorEnum = 37;
pub const GIOErrorEnum_G_IO_ERROR_NETWORK_UNREACHABLE: GIOErrorEnum = 38;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_REFUSED: GIOErrorEnum = 39;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_FAILED: GIOErrorEnum = 40;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_AUTH_FAILED: GIOErrorEnum = 41;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NEED_AUTH: GIOErrorEnum = 42;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NOT_ALLOWED: GIOErrorEnum = 43;
pub const GIOErrorEnum_G_IO_ERROR_BROKEN_PIPE: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_CLOSED: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_NOT_CONNECTED: GIOErrorEnum = 45;
pub const GIOErrorEnum_G_IO_ERROR_MESSAGE_TOO_LARGE: GIOErrorEnum = 46;
pub const GIOErrorEnum_G_IO_ERROR_NO_SUCH_DEVICE: GIOErrorEnum = 47;
#[doc = " GIOErrorEnum:\n @G_IO_ERROR_FAILED: Generic error condition for when an operation fails\n     and no more specific #GIOErrorEnum value is defined.\n @G_IO_ERROR_NOT_FOUND: File not found.\n @G_IO_ERROR_EXISTS: File already exists.\n @G_IO_ERROR_IS_DIRECTORY: File is a directory.\n @G_IO_ERROR_NOT_DIRECTORY: File is not a directory.\n @G_IO_ERROR_NOT_EMPTY: File is a directory that isn't empty.\n @G_IO_ERROR_NOT_REGULAR_FILE: File is not a regular file.\n @G_IO_ERROR_NOT_SYMBOLIC_LINK: File is not a symbolic link.\n @G_IO_ERROR_NOT_MOUNTABLE_FILE: File cannot be mounted.\n @G_IO_ERROR_FILENAME_TOO_LONG: Filename is too many characters.\n @G_IO_ERROR_INVALID_FILENAME: Filename is invalid or contains invalid characters.\n @G_IO_ERROR_TOO_MANY_LINKS: File contains too many symbolic links.\n @G_IO_ERROR_NO_SPACE: No space left on drive.\n @G_IO_ERROR_INVALID_ARGUMENT: Invalid argument.\n @G_IO_ERROR_PERMISSION_DENIED: Permission denied.\n @G_IO_ERROR_NOT_SUPPORTED: Operation (or one of its parameters) not supported\n @G_IO_ERROR_NOT_MOUNTED: File isn't mounted.\n @G_IO_ERROR_ALREADY_MOUNTED: File is already mounted.\n @G_IO_ERROR_CLOSED: File was closed.\n @G_IO_ERROR_CANCELLED: Operation was cancelled. See #GCancellable.\n @G_IO_ERROR_PENDING: Operations are still pending.\n @G_IO_ERROR_READ_ONLY: File is read only.\n @G_IO_ERROR_CANT_CREATE_BACKUP: Backup couldn't be created.\n @G_IO_ERROR_WRONG_ETAG: File's Entity Tag was incorrect.\n @G_IO_ERROR_TIMED_OUT: Operation timed out.\n @G_IO_ERROR_WOULD_RECURSE: Operation would be recursive.\n @G_IO_ERROR_BUSY: File is busy.\n @G_IO_ERROR_WOULD_BLOCK: Operation would block.\n @G_IO_ERROR_HOST_NOT_FOUND: Host couldn't be found (remote operations).\n @G_IO_ERROR_WOULD_MERGE: Operation would merge files.\n @G_IO_ERROR_FAILED_HANDLED: Operation failed and a helper program has\n     already interacted with the user. Do not display any error dialog.\n @G_IO_ERROR_TOO_MANY_OPEN_FILES: The current process has too many files\n     open and can't open any more. Duplicate descriptors do count toward\n     this limit. Since 2.20\n @G_IO_ERROR_NOT_INITIALIZED: The object has not been initialized. Since 2.22\n @G_IO_ERROR_ADDRESS_IN_USE: The requested address is already in use. Since 2.22\n @G_IO_ERROR_PARTIAL_INPUT: Need more input to finish operation. Since 2.24\n @G_IO_ERROR_INVALID_DATA: The input data was invalid. Since 2.24\n @G_IO_ERROR_DBUS_ERROR: A remote object generated an error that\n     doesn't correspond to a locally registered #GError error\n     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus\n     error name and g_dbus_error_strip_remote_error() to fix up the\n     message so it matches what was received on the wire. Since 2.26.\n @G_IO_ERROR_HOST_UNREACHABLE: Host unreachable. Since 2.26\n @G_IO_ERROR_NETWORK_UNREACHABLE: Network unreachable. Since 2.26\n @G_IO_ERROR_CONNECTION_REFUSED: Connection refused. Since 2.26\n @G_IO_ERROR_PROXY_FAILED: Connection to proxy server failed. Since 2.26\n @G_IO_ERROR_PROXY_AUTH_FAILED: Proxy authentication failed. Since 2.26\n @G_IO_ERROR_PROXY_NEED_AUTH: Proxy server needs authentication. Since 2.26\n @G_IO_ERROR_PROXY_NOT_ALLOWED: Proxy connection is not allowed by ruleset.\n     Since 2.26\n @G_IO_ERROR_BROKEN_PIPE: Broken pipe. Since 2.36\n @G_IO_ERROR_CONNECTION_CLOSED: Connection closed by peer. Note that this\n     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some\n     \"connection closed\" errors returned %G_IO_ERROR_BROKEN_PIPE, but others\n     returned %G_IO_ERROR_FAILED. Now they should all return the same\n     value, which has this more logical name. Since 2.44.\n @G_IO_ERROR_NOT_CONNECTED: Transport endpoint is not connected. Since 2.44\n @G_IO_ERROR_MESSAGE_TOO_LARGE: Message too large. Since 2.48.\n @G_IO_ERROR_NO_SUCH_DEVICE: No such device found. Since 2.74\n\n Error codes returned by GIO functions.\n\n Note that this domain may be extended in future GLib releases. In\n general, new error codes either only apply to new APIs, or else\n replace %G_IO_ERROR_FAILED in cases that were not explicitly\n distinguished before. You should therefore avoid writing code like\n |[<!-- language=\"C\" -->\n if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))\n   {\n     // Assume that this is EPRINTERONFIRE\n     ...\n   }\n ]|\n but should instead treat all unrecognized error codes the same as\n %G_IO_ERROR_FAILED.\n\n See also #GPollableReturn for a cheaper way of returning\n %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError."]
pub type GIOErrorEnum = ::std::os::raw::c_uint;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_PASSWORD: GAskPasswordFlags = 1;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_USERNAME: GAskPasswordFlags = 2;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_DOMAIN: GAskPasswordFlags = 4;
pub const GAskPasswordFlags_G_ASK_PASSWORD_SAVING_SUPPORTED: GAskPasswordFlags = 8;
pub const GAskPasswordFlags_G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: GAskPasswordFlags = 16;
pub const GAskPasswordFlags_G_ASK_PASSWORD_TCRYPT: GAskPasswordFlags = 32;
#[doc = " GAskPasswordFlags:\n @G_ASK_PASSWORD_NEED_PASSWORD: operation requires a password.\n @G_ASK_PASSWORD_NEED_USERNAME: operation requires a username.\n @G_ASK_PASSWORD_NEED_DOMAIN: operation requires a domain.\n @G_ASK_PASSWORD_SAVING_SUPPORTED: operation supports saving settings.\n @G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: operation supports anonymous users.\n @G_ASK_PASSWORD_TCRYPT: operation takes TCRYPT parameters (Since: 2.58)\n\n #GAskPasswordFlags are used to request specific information from the\n user, or to notify the user of their choices in an authentication\n situation."]
pub type GAskPasswordFlags = ::std::os::raw::c_uint;
pub const GPasswordSave_G_PASSWORD_SAVE_NEVER: GPasswordSave = 0;
pub const GPasswordSave_G_PASSWORD_SAVE_FOR_SESSION: GPasswordSave = 1;
pub const GPasswordSave_G_PASSWORD_SAVE_PERMANENTLY: GPasswordSave = 2;
#[doc = " GPasswordSave:\n @G_PASSWORD_SAVE_NEVER: never save a password.\n @G_PASSWORD_SAVE_FOR_SESSION: save a password for the session.\n @G_PASSWORD_SAVE_PERMANENTLY: save a password permanently.\n\n #GPasswordSave is used to indicate the lifespan of a saved password.\n\n #Gvfs stores passwords in the Gnome keyring when this flag allows it\n to, and later retrieves it again from there."]
pub type GPasswordSave = ::std::os::raw::c_uint;
pub const GMountOperationResult_G_MOUNT_OPERATION_HANDLED: GMountOperationResult = 0;
pub const GMountOperationResult_G_MOUNT_OPERATION_ABORTED: GMountOperationResult = 1;
pub const GMountOperationResult_G_MOUNT_OPERATION_UNHANDLED: GMountOperationResult = 2;
#[doc = " GMountOperationResult:\n @G_MOUNT_OPERATION_HANDLED: The request was fulfilled and the\n     user specified data is now available\n @G_MOUNT_OPERATION_ABORTED: The user requested the mount operation\n     to be aborted\n @G_MOUNT_OPERATION_UNHANDLED: The request was unhandled (i.e. not\n     implemented)\n\n #GMountOperationResult is returned as a result when a request for\n information is send by the mounting operation."]
pub type GMountOperationResult = ::std::os::raw::c_uint;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_NONE: GOutputStreamSpliceFlags = 0;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: GOutputStreamSpliceFlags =
    1;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: GOutputStreamSpliceFlags =
    2;
#[doc = " GOutputStreamSpliceFlags:\n @G_OUTPUT_STREAM_SPLICE_NONE: Do not close either stream.\n @G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: Close the source stream after\n     the splice.\n @G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: Close the target stream after\n     the splice.\n\n GOutputStreamSpliceFlags determine how streams should be spliced."]
pub type GOutputStreamSpliceFlags = ::std::os::raw::c_uint;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_NONE: GIOStreamSpliceFlags = 0;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM1: GIOStreamSpliceFlags = 1;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM2: GIOStreamSpliceFlags = 2;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: GIOStreamSpliceFlags = 4;
#[doc = " GIOStreamSpliceFlags:\n @G_IO_STREAM_SPLICE_NONE: Do not close either stream.\n @G_IO_STREAM_SPLICE_CLOSE_STREAM1: Close the first stream after\n     the splice.\n @G_IO_STREAM_SPLICE_CLOSE_STREAM2: Close the second stream after\n     the splice.\n @G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: Wait for both splice operations to finish\n     before calling the callback.\n\n GIOStreamSpliceFlags determine how streams should be spliced.\n\n Since: 2.28"]
pub type GIOStreamSpliceFlags = ::std::os::raw::c_uint;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_UNKNOWN: GEmblemOrigin = 0;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_DEVICE: GEmblemOrigin = 1;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_LIVEMETADATA: GEmblemOrigin = 2;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_TAG: GEmblemOrigin = 3;
#[doc = " GEmblemOrigin:\n @G_EMBLEM_ORIGIN_UNKNOWN: Emblem of unknown origin\n @G_EMBLEM_ORIGIN_DEVICE: Emblem adds device-specific information\n @G_EMBLEM_ORIGIN_LIVEMETADATA: Emblem depicts live metadata, such as \"readonly\"\n @G_EMBLEM_ORIGIN_TAG: Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)\n\n GEmblemOrigin is used to add information about the origin of the emblem\n to #GEmblem.\n\n Since: 2.18"]
pub type GEmblemOrigin = ::std::os::raw::c_uint;
pub const GResolverError_G_RESOLVER_ERROR_NOT_FOUND: GResolverError = 0;
pub const GResolverError_G_RESOLVER_ERROR_TEMPORARY_FAILURE: GResolverError = 1;
pub const GResolverError_G_RESOLVER_ERROR_INTERNAL: GResolverError = 2;
#[doc = " GResolverError:\n @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not\n     found\n @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not\n     be looked up due to a network error or similar problem\n @G_RESOLVER_ERROR_INTERNAL: unknown error\n\n An error code used with %G_RESOLVER_ERROR in a #GError returned\n from a #GResolver routine.\n\n Since: 2.22"]
pub type GResolverError = ::std::os::raw::c_uint;
pub const GResolverRecordType_G_RESOLVER_RECORD_SRV: GResolverRecordType = 1;
pub const GResolverRecordType_G_RESOLVER_RECORD_MX: GResolverRecordType = 2;
pub const GResolverRecordType_G_RESOLVER_RECORD_TXT: GResolverRecordType = 3;
pub const GResolverRecordType_G_RESOLVER_RECORD_SOA: GResolverRecordType = 4;
pub const GResolverRecordType_G_RESOLVER_RECORD_NS: GResolverRecordType = 5;
#[doc = " GResolverRecordType:\n @G_RESOLVER_RECORD_SRV: look up DNS SRV records for a domain\n @G_RESOLVER_RECORD_MX: look up DNS MX records for a domain\n @G_RESOLVER_RECORD_TXT: look up DNS TXT records for a name\n @G_RESOLVER_RECORD_SOA: look up DNS SOA records for a zone\n @G_RESOLVER_RECORD_NS: look up DNS NS records for a domain\n\n The type of record that g_resolver_lookup_records() or\n g_resolver_lookup_records_async() should retrieve. The records are returned\n as lists of #GVariant tuples. Each record type has different values in\n the variant tuples returned.\n\n %G_RESOLVER_RECORD_SRV records are returned as variants with the signature\n `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the\n weight, a `guint16` with the port, and a string of the hostname.\n\n %G_RESOLVER_RECORD_MX records are returned as variants with the signature\n `(qs)`, representing a `guint16` with the preference, and a string containing\n the mail exchanger hostname.\n\n %G_RESOLVER_RECORD_TXT records are returned as variants with the signature\n `(as)`, representing an array of the strings in the text record. Note: Most TXT\n records only contain a single string, but\n [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a\n record to contain multiple strings. The RFC which defines the interpretation\n of a specific TXT record will likely require concatenation of multiple\n strings if they are present, as with\n [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).\n\n %G_RESOLVER_RECORD_SOA records are returned as variants with the signature\n `(ssuuuuu)`, representing a string containing the primary name server, a\n string containing the administrator, the serial as a `guint32`, the refresh\n interval as a `guint32`, the retry interval as a `guint32`, the expire timeout\n as a `guint32`, and the TTL as a `guint32`.\n\n %G_RESOLVER_RECORD_NS records are returned as variants with the signature\n `(s)`, representing a string of the hostname of the name server.\n\n Since: 2.34"]
pub type GResolverRecordType = ::std::os::raw::c_uint;
pub const GResourceError_G_RESOURCE_ERROR_NOT_FOUND: GResourceError = 0;
pub const GResourceError_G_RESOURCE_ERROR_INTERNAL: GResourceError = 1;
#[doc = " GResourceError:\n @G_RESOURCE_ERROR_NOT_FOUND: no file was found at the requested path\n @G_RESOURCE_ERROR_INTERNAL: unknown error\n\n An error code used with %G_RESOURCE_ERROR in a #GError returned\n from a #GResource routine.\n\n Since: 2.32"]
pub type GResourceError = ::std::os::raw::c_uint;
pub const GResourceFlags_G_RESOURCE_FLAGS_NONE: GResourceFlags = 0;
pub const GResourceFlags_G_RESOURCE_FLAGS_COMPRESSED: GResourceFlags = 1;
#[doc = " GResourceFlags:\n @G_RESOURCE_FLAGS_NONE: No flags set.\n @G_RESOURCE_FLAGS_COMPRESSED: The file is compressed.\n\n GResourceFlags give information about a particular file inside a resource\n bundle.\n\n Since: 2.32"]
pub type GResourceFlags = ::std::os::raw::c_uint;
pub const GResourceLookupFlags_G_RESOURCE_LOOKUP_FLAGS_NONE: GResourceLookupFlags = 0;
#[doc = " GResourceLookupFlags:\n @G_RESOURCE_LOOKUP_FLAGS_NONE: No flags set.\n\n GResourceLookupFlags determine how resource path lookups are handled.\n\n Since: 2.32"]
pub type GResourceLookupFlags = ::std::os::raw::c_uint;
pub const GSocketFamily_G_SOCKET_FAMILY_INVALID: GSocketFamily = 0;
pub const GSocketFamily_G_SOCKET_FAMILY_UNIX: GSocketFamily = 1;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV4: GSocketFamily = 2;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV6: GSocketFamily = 30;
#[doc = " GSocketFamily:\n @G_SOCKET_FAMILY_INVALID: no address family\n @G_SOCKET_FAMILY_IPV4: the IPv4 family\n @G_SOCKET_FAMILY_IPV6: the IPv6 family\n @G_SOCKET_FAMILY_UNIX: the UNIX domain family\n\n The protocol family of a #GSocketAddress. (These values are\n identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,\n if available.)\n\n Since: 2.22"]
pub type GSocketFamily = ::std::os::raw::c_uint;
pub const GSocketType_G_SOCKET_TYPE_INVALID: GSocketType = 0;
pub const GSocketType_G_SOCKET_TYPE_STREAM: GSocketType = 1;
pub const GSocketType_G_SOCKET_TYPE_DATAGRAM: GSocketType = 2;
pub const GSocketType_G_SOCKET_TYPE_SEQPACKET: GSocketType = 3;
#[doc = " GSocketType:\n @G_SOCKET_TYPE_INVALID: Type unknown or wrong\n @G_SOCKET_TYPE_STREAM: Reliable connection-based byte streams (e.g. TCP).\n @G_SOCKET_TYPE_DATAGRAM: Connectionless, unreliable datagram passing.\n     (e.g. UDP)\n @G_SOCKET_TYPE_SEQPACKET: Reliable connection-based passing of datagrams\n     of fixed maximum length (e.g. SCTP).\n\n Flags used when creating a #GSocket. Some protocols may not implement\n all the socket types.\n\n Since: 2.22"]
pub type GSocketType = ::std::os::raw::c_uint;
pub const GSocketMsgFlags_G_SOCKET_MSG_NONE: GSocketMsgFlags = 0;
pub const GSocketMsgFlags_G_SOCKET_MSG_OOB: GSocketMsgFlags = 1;
pub const GSocketMsgFlags_G_SOCKET_MSG_PEEK: GSocketMsgFlags = 2;
pub const GSocketMsgFlags_G_SOCKET_MSG_DONTROUTE: GSocketMsgFlags = 4;
#[doc = " GSocketMsgFlags:\n @G_SOCKET_MSG_NONE: No flags.\n @G_SOCKET_MSG_OOB: Request to send/receive out of band data.\n @G_SOCKET_MSG_PEEK: Read data from the socket without removing it from\n     the queue.\n @G_SOCKET_MSG_DONTROUTE: Don't use a gateway to send out the packet,\n     only send to hosts on directly connected networks.\n\n Flags used in g_socket_receive_message() and g_socket_send_message().\n The flags listed in the enum are some commonly available flags, but the\n values used for them are the same as on the platform, and any other flags\n are passed in/out as is. So to use a platform specific flag, just include\n the right system header and pass in the flag.\n\n Since: 2.22"]
pub type GSocketMsgFlags = ::std::os::raw::c_uint;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UNKNOWN: GSocketProtocol = -1;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_DEFAULT: GSocketProtocol = 0;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_TCP: GSocketProtocol = 6;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UDP: GSocketProtocol = 17;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_SCTP: GSocketProtocol = 132;
#[doc = " GSocketProtocol:\n @G_SOCKET_PROTOCOL_UNKNOWN: The protocol type is unknown\n @G_SOCKET_PROTOCOL_DEFAULT: The default protocol for the family/type\n @G_SOCKET_PROTOCOL_TCP: TCP over IP\n @G_SOCKET_PROTOCOL_UDP: UDP over IP\n @G_SOCKET_PROTOCOL_SCTP: SCTP over IP\n\n A protocol identifier is specified when creating a #GSocket, which is a\n family/type specific identifier, where 0 means the default protocol for\n the particular family/type.\n\n This enum contains a set of commonly available and used protocols. You\n can also pass any other identifiers handled by the platform in order to\n use protocols not listed here.\n\n Since: 2.22"]
pub type GSocketProtocol = ::std::os::raw::c_int;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_ZLIB: GZlibCompressorFormat = 0;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_GZIP: GZlibCompressorFormat = 1;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_RAW: GZlibCompressorFormat = 2;
#[doc = " GZlibCompressorFormat:\n @G_ZLIB_COMPRESSOR_FORMAT_ZLIB: deflate compression with zlib header\n @G_ZLIB_COMPRESSOR_FORMAT_GZIP: gzip file format\n @G_ZLIB_COMPRESSOR_FORMAT_RAW: deflate compression with no header\n\n Used to select the type of data format to use for #GZlibDecompressor\n and #GZlibCompressor.\n\n Since: 2.24"]
pub type GZlibCompressorFormat = ::std::os::raw::c_uint;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_INVALID: GUnixSocketAddressType = 0;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ANONYMOUS: GUnixSocketAddressType = 1;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_PATH: GUnixSocketAddressType = 2;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT: GUnixSocketAddressType = 3;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: GUnixSocketAddressType = 4;
#[doc = " GUnixSocketAddressType:\n @G_UNIX_SOCKET_ADDRESS_INVALID: invalid\n @G_UNIX_SOCKET_ADDRESS_ANONYMOUS: anonymous\n @G_UNIX_SOCKET_ADDRESS_PATH: a filesystem path\n @G_UNIX_SOCKET_ADDRESS_ABSTRACT: an abstract name\n @G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: an abstract name, 0-padded\n   to the full length of a unix socket name\n\n The type of name used by a #GUnixSocketAddress.\n %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain\n socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS\n indicates a socket not bound to any name (eg, a client-side socket,\n or a socket created with socketpair()).\n\n For abstract sockets, there are two incompatible ways of naming\n them; the man pages suggest using the entire `struct sockaddr_un`\n as the name, padding the unused parts of the %sun_path field with\n zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.\n However, many programs instead just use a portion of %sun_path, and\n pass an appropriate smaller length to bind() or connect(). This is\n %G_UNIX_SOCKET_ADDRESS_ABSTRACT.\n\n Since: 2.26"]
pub type GUnixSocketAddressType = ::std::os::raw::c_uint;
pub const GBusType_G_BUS_TYPE_STARTER: GBusType = -1;
pub const GBusType_G_BUS_TYPE_NONE: GBusType = 0;
pub const GBusType_G_BUS_TYPE_SYSTEM: GBusType = 1;
pub const GBusType_G_BUS_TYPE_SESSION: GBusType = 2;
#[doc = " GBusType:\n @G_BUS_TYPE_STARTER: An alias for the message bus that activated the process, if any.\n @G_BUS_TYPE_NONE: Not a message bus.\n @G_BUS_TYPE_SYSTEM: The system-wide message bus.\n @G_BUS_TYPE_SESSION: The login session message bus.\n\n An enumeration for well-known message buses.\n\n Since: 2.26"]
pub type GBusType = ::std::os::raw::c_int;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_NONE: GBusNameOwnerFlags = 0;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: GBusNameOwnerFlags = 1;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_REPLACE: GBusNameOwnerFlags = 2;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: GBusNameOwnerFlags = 4;
#[doc = " GBusNameOwnerFlags:\n @G_BUS_NAME_OWNER_FLAGS_NONE: No flags set.\n @G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: Allow another message bus connection to claim the name.\n @G_BUS_NAME_OWNER_FLAGS_REPLACE: If another message bus connection owns the name and have\n specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.\n @G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: If another message bus connection owns the name, immediately\n return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)\n\n Flags used in g_bus_own_name().\n\n Since: 2.26"]
pub type GBusNameOwnerFlags = ::std::os::raw::c_uint;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_NONE: GBusNameWatcherFlags = 0;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_AUTO_START: GBusNameWatcherFlags = 1;
#[doc = " GBusNameWatcherFlags:\n @G_BUS_NAME_WATCHER_FLAGS_NONE: No flags set.\n @G_BUS_NAME_WATCHER_FLAGS_AUTO_START: If no-one owns the name when\n beginning to watch the name, ask the bus to launch an owner for the\n name.\n\n Flags used in g_bus_watch_name().\n\n Since: 2.26"]
pub type GBusNameWatcherFlags = ::std::os::raw::c_uint;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NONE: GDBusProxyFlags = 0;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: GDBusProxyFlags = 1;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: GDBusProxyFlags = 2;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: GDBusProxyFlags = 4;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: GDBusProxyFlags = 8;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: GDBusProxyFlags =
    16;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: GDBusProxyFlags = 32;
#[doc = " GDBusProxyFlags:\n @G_DBUS_PROXY_FLAGS_NONE: No flags set.\n @G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: Don't load properties.\n @G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: Don't connect to signals on the remote object.\n @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: If the proxy is for a well-known name,\n do not ask the bus to launch an owner during proxy initialization or a method call.\n This flag is only meaningful in proxies for well-known names.\n @G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.\n @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: If the proxy is for a well-known name,\n do not ask the bus to launch an owner during proxy initialization, but allow it to be\n autostarted by a method call. This flag is only meaningful in proxies for well-known names,\n and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.\n @G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch D-Bus\n    call for this signal subscription. This gives you more control\n    over which match rules you add (but you must add them manually). (Since: 2.72)\n\n Flags used when constructing an instance of a #GDBusProxy derived class.\n\n Since: 2.26"]
pub type GDBusProxyFlags = ::std::os::raw::c_uint;
pub const GDBusError_G_DBUS_ERROR_FAILED: GDBusError = 0;
pub const GDBusError_G_DBUS_ERROR_NO_MEMORY: GDBusError = 1;
pub const GDBusError_G_DBUS_ERROR_SERVICE_UNKNOWN: GDBusError = 2;
pub const GDBusError_G_DBUS_ERROR_NAME_HAS_NO_OWNER: GDBusError = 3;
pub const GDBusError_G_DBUS_ERROR_NO_REPLY: GDBusError = 4;
pub const GDBusError_G_DBUS_ERROR_IO_ERROR: GDBusError = 5;
pub const GDBusError_G_DBUS_ERROR_BAD_ADDRESS: GDBusError = 6;
pub const GDBusError_G_DBUS_ERROR_NOT_SUPPORTED: GDBusError = 7;
pub const GDBusError_G_DBUS_ERROR_LIMITS_EXCEEDED: GDBusError = 8;
pub const GDBusError_G_DBUS_ERROR_ACCESS_DENIED: GDBusError = 9;
pub const GDBusError_G_DBUS_ERROR_AUTH_FAILED: GDBusError = 10;
pub const GDBusError_G_DBUS_ERROR_NO_SERVER: GDBusError = 11;
pub const GDBusError_G_DBUS_ERROR_TIMEOUT: GDBusError = 12;
pub const GDBusError_G_DBUS_ERROR_NO_NETWORK: GDBusError = 13;
pub const GDBusError_G_DBUS_ERROR_ADDRESS_IN_USE: GDBusError = 14;
pub const GDBusError_G_DBUS_ERROR_DISCONNECTED: GDBusError = 15;
pub const GDBusError_G_DBUS_ERROR_INVALID_ARGS: GDBusError = 16;
pub const GDBusError_G_DBUS_ERROR_FILE_NOT_FOUND: GDBusError = 17;
pub const GDBusError_G_DBUS_ERROR_FILE_EXISTS: GDBusError = 18;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_METHOD: GDBusError = 19;
pub const GDBusError_G_DBUS_ERROR_TIMED_OUT: GDBusError = 20;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: GDBusError = 21;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_INVALID: GDBusError = 22;
pub const GDBusError_G_DBUS_ERROR_SPAWN_EXEC_FAILED: GDBusError = 23;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FORK_FAILED: GDBusError = 24;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_EXITED: GDBusError = 25;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: GDBusError = 26;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FAILED: GDBusError = 27;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SETUP_FAILED: GDBusError = 28;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CONFIG_INVALID: GDBusError = 29;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_INVALID: GDBusError = 30;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: GDBusError = 31;
pub const GDBusError_G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: GDBusError = 32;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FILE_INVALID: GDBusError = 33;
pub const GDBusError_G_DBUS_ERROR_SPAWN_NO_MEMORY: GDBusError = 34;
pub const GDBusError_G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: GDBusError = 35;
pub const GDBusError_G_DBUS_ERROR_INVALID_SIGNATURE: GDBusError = 36;
pub const GDBusError_G_DBUS_ERROR_INVALID_FILE_CONTENT: GDBusError = 37;
pub const GDBusError_G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: GDBusError = 38;
pub const GDBusError_G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: GDBusError = 39;
pub const GDBusError_G_DBUS_ERROR_OBJECT_PATH_IN_USE: GDBusError = 40;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_OBJECT: GDBusError = 41;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_INTERFACE: GDBusError = 42;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_PROPERTY: GDBusError = 43;
pub const GDBusError_G_DBUS_ERROR_PROPERTY_READ_ONLY: GDBusError = 44;
#[doc = " GDBusError:\n @G_DBUS_ERROR_FAILED:\n A generic error; \"something went wrong\" - see the error message for\n more.\n @G_DBUS_ERROR_NO_MEMORY:\n There was not enough memory to complete an operation.\n @G_DBUS_ERROR_SERVICE_UNKNOWN:\n The bus doesn't know how to launch a service to supply the bus name\n you wanted.\n @G_DBUS_ERROR_NAME_HAS_NO_OWNER:\n The bus name you referenced doesn't exist (i.e. no application owns\n it).\n @G_DBUS_ERROR_NO_REPLY:\n No reply to a message expecting one, usually means a timeout occurred.\n @G_DBUS_ERROR_IO_ERROR:\n Something went wrong reading or writing to a socket, for example.\n @G_DBUS_ERROR_BAD_ADDRESS:\n A D-Bus bus address was malformed.\n @G_DBUS_ERROR_NOT_SUPPORTED:\n Requested operation isn't supported (like ENOSYS on UNIX).\n @G_DBUS_ERROR_LIMITS_EXCEEDED:\n Some limited resource is exhausted.\n @G_DBUS_ERROR_ACCESS_DENIED:\n Security restrictions don't allow doing what you're trying to do.\n @G_DBUS_ERROR_AUTH_FAILED:\n Authentication didn't work.\n @G_DBUS_ERROR_NO_SERVER:\n Unable to connect to server (probably caused by ECONNREFUSED on a\n socket).\n @G_DBUS_ERROR_TIMEOUT:\n Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that\n %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:\n this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also\n exists. We can't fix it for compatibility reasons so just be\n careful.\n @G_DBUS_ERROR_NO_NETWORK:\n No network access (probably ENETUNREACH on a socket).\n @G_DBUS_ERROR_ADDRESS_IN_USE:\n Can't bind a socket since its address is in use (i.e. EADDRINUSE).\n @G_DBUS_ERROR_DISCONNECTED:\n The connection is disconnected and you're trying to use it.\n @G_DBUS_ERROR_INVALID_ARGS:\n Invalid arguments passed to a method call.\n @G_DBUS_ERROR_FILE_NOT_FOUND:\n Missing file.\n @G_DBUS_ERROR_FILE_EXISTS:\n Existing file and the operation you're using does not silently overwrite.\n @G_DBUS_ERROR_UNKNOWN_METHOD:\n Method name you invoked isn't known by the object you invoked it on.\n @G_DBUS_ERROR_UNKNOWN_OBJECT:\n Object you invoked a method on isn't known. Since 2.42\n @G_DBUS_ERROR_UNKNOWN_INTERFACE:\n Interface you invoked a method on isn't known by the object. Since 2.42\n @G_DBUS_ERROR_UNKNOWN_PROPERTY:\n Property you tried to access isn't known by the object. Since 2.42\n @G_DBUS_ERROR_PROPERTY_READ_ONLY:\n Property you tried to set is read-only. Since 2.42\n @G_DBUS_ERROR_TIMED_OUT:\n Certain timeout errors, e.g. while starting a service. Warning: this is\n confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We\n can't fix it for compatibility reasons so just be careful.\n @G_DBUS_ERROR_MATCH_RULE_NOT_FOUND:\n Tried to remove or modify a match rule that didn't exist.\n @G_DBUS_ERROR_MATCH_RULE_INVALID:\n The match rule isn't syntactically valid.\n @G_DBUS_ERROR_SPAWN_EXEC_FAILED:\n While starting a new process, the exec() call failed.\n @G_DBUS_ERROR_SPAWN_FORK_FAILED:\n While starting a new process, the fork() call failed.\n @G_DBUS_ERROR_SPAWN_CHILD_EXITED:\n While starting a new process, the child exited with a status code.\n @G_DBUS_ERROR_SPAWN_CHILD_SIGNALED:\n While starting a new process, the child exited on a signal.\n @G_DBUS_ERROR_SPAWN_FAILED:\n While starting a new process, something went wrong.\n @G_DBUS_ERROR_SPAWN_SETUP_FAILED:\n We failed to setup the environment correctly.\n @G_DBUS_ERROR_SPAWN_CONFIG_INVALID:\n We failed to setup the config parser correctly.\n @G_DBUS_ERROR_SPAWN_SERVICE_INVALID:\n Bus name was not valid.\n @G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND:\n Service file not found in system-services directory.\n @G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID:\n Permissions are incorrect on the setuid helper.\n @G_DBUS_ERROR_SPAWN_FILE_INVALID:\n Service file invalid (Name, User or Exec missing).\n @G_DBUS_ERROR_SPAWN_NO_MEMORY:\n Tried to get a UNIX process ID and it wasn't available.\n @G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN:\n Tried to get a UNIX process ID and it wasn't available.\n @G_DBUS_ERROR_INVALID_SIGNATURE:\n A type signature is not valid.\n @G_DBUS_ERROR_INVALID_FILE_CONTENT:\n A file contains invalid syntax or is otherwise broken.\n @G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:\n Asked for SELinux security context and it wasn't available.\n @G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN:\n Asked for ADT audit data and it wasn't available.\n @G_DBUS_ERROR_OBJECT_PATH_IN_USE:\n There's already an object with the requested object path.\n\n Error codes for the %G_DBUS_ERROR error domain.\n\n Since: 2.26"]
pub type GDBusError = ::std::os::raw::c_uint;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_NONE: GDBusConnectionFlags = 0;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: GDBusConnectionFlags =
    1;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: GDBusConnectionFlags =
    2;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS:
    GDBusConnectionFlags = 4;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION:
    GDBusConnectionFlags = 8;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING:
    GDBusConnectionFlags = 16;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER:
    GDBusConnectionFlags = 32;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: GDBusConnectionFlags = 64;
#[doc = " GDBusConnectionFlags:\n @G_DBUS_CONNECTION_FLAGS_NONE: No flags set.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: Perform authentication against server.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: Perform authentication against client.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: When\n authenticating as a server, allow the anonymous authentication\n method.\n @G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: Pass this flag if connecting to a peer that is a\n message bus. This means that the Hello() method will be invoked as part of the connection setup.\n @G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: If set, processing of D-Bus messages is\n delayed until g_dbus_connection_start_message_processing() is called.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: When authenticating\n as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)\n @G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: When authenticating, try to use\n  protocols that work across a Linux user namespace boundary, even if this\n  reduces interoperability with older D-Bus implementations. This currently\n  affects client-side `EXTERNAL` authentication, for which this flag makes\n  connections to a server in another user namespace succeed, but causes\n  a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74\n\n Flags used when creating a new #GDBusConnection.\n\n Since: 2.26"]
pub type GDBusConnectionFlags = ::std::os::raw::c_uint;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_NONE: GDBusCapabilityFlags = 0;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: GDBusCapabilityFlags = 1;
#[doc = " GDBusCapabilityFlags:\n @G_DBUS_CAPABILITY_FLAGS_NONE: No flags set.\n @G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: The connection\n supports exchanging UNIX file descriptors with the remote peer.\n\n Capabilities negotiated with the remote peer.\n\n Since: 2.26"]
pub type GDBusCapabilityFlags = ::std::os::raw::c_uint;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NONE: GDBusCallFlags = 0;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NO_AUTO_START: GDBusCallFlags = 1;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: GDBusCallFlags = 2;
#[doc = " GDBusCallFlags:\n @G_DBUS_CALL_FLAGS_NONE: No flags set.\n @G_DBUS_CALL_FLAGS_NO_AUTO_START: The bus must not launch\n an owner for the destination name in response to this method\n invocation.\n @G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: the caller is prepared to\n wait for interactive authorization. Since 2.46.\n\n Flags used in g_dbus_connection_call() and similar APIs.\n\n Since: 2.26"]
pub type GDBusCallFlags = ::std::os::raw::c_uint;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_INVALID: GDBusMessageType = 0;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_CALL: GDBusMessageType = 1;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_RETURN: GDBusMessageType = 2;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_ERROR: GDBusMessageType = 3;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_SIGNAL: GDBusMessageType = 4;
#[doc = " GDBusMessageType:\n @G_DBUS_MESSAGE_TYPE_INVALID: Message is of invalid type.\n @G_DBUS_MESSAGE_TYPE_METHOD_CALL: Method call.\n @G_DBUS_MESSAGE_TYPE_METHOD_RETURN: Method reply.\n @G_DBUS_MESSAGE_TYPE_ERROR: Error reply.\n @G_DBUS_MESSAGE_TYPE_SIGNAL: Signal emission.\n\n Message types used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageType = ::std::os::raw::c_uint;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NONE: GDBusMessageFlags = 0;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: GDBusMessageFlags = 1;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: GDBusMessageFlags = 2;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION:
    GDBusMessageFlags = 4;
#[doc = " GDBusMessageFlags:\n @G_DBUS_MESSAGE_FLAGS_NONE: No flags set.\n @G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: A reply is not expected.\n @G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: The bus must not launch an\n owner for the destination name in response to this message.\n @G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: If set on a method\n call, this flag means that the caller is prepared to wait for interactive\n authorization. Since 2.46.\n\n Message flags used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageFlags = ::std::os::raw::c_uint;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INVALID: GDBusMessageHeaderField = 0;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_PATH: GDBusMessageHeaderField = 1;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: GDBusMessageHeaderField =
    2;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: GDBusMessageHeaderField = 3;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: GDBusMessageHeaderField =
    4;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL:
    GDBusMessageHeaderField = 5;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: GDBusMessageHeaderField =
    6;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SENDER: GDBusMessageHeaderField = 7;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: GDBusMessageHeaderField =
    8;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS:
    GDBusMessageHeaderField = 9;
#[doc = " GDBusMessageHeaderField:\n @G_DBUS_MESSAGE_HEADER_FIELD_INVALID: Not a valid header field.\n @G_DBUS_MESSAGE_HEADER_FIELD_PATH: The object path.\n @G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: The interface name.\n @G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: The method or signal name.\n @G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: The name of the error that occurred.\n @G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: The serial number the message is a reply to.\n @G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: The name the message is intended for.\n @G_DBUS_MESSAGE_HEADER_FIELD_SENDER: Unique name of the sender of the message (filled in by the bus).\n @G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: The signature of the message body.\n @G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: The number of UNIX file descriptors that accompany the message.\n\n Header fields used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageHeaderField = ::std::os::raw::c_uint;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_NONE: GDBusPropertyInfoFlags = 0;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_READABLE: GDBusPropertyInfoFlags = 1;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: GDBusPropertyInfoFlags = 2;
#[doc = " GDBusPropertyInfoFlags:\n @G_DBUS_PROPERTY_INFO_FLAGS_NONE: No flags set.\n @G_DBUS_PROPERTY_INFO_FLAGS_READABLE: Property is readable.\n @G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: Property is writable.\n\n Flags describing the access control of a D-Bus property.\n\n Since: 2.26"]
pub type GDBusPropertyInfoFlags = ::std::os::raw::c_uint;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_NONE: GDBusSubtreeFlags = 0;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: GDBusSubtreeFlags =
    1;
#[doc = " GDBusSubtreeFlags:\n @G_DBUS_SUBTREE_FLAGS_NONE: No flags set.\n @G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: Method calls to objects not in the enumerated range\n                                                       will still be dispatched. This is useful if you want\n                                                       to dynamically spawn objects in the subtree.\n\n Flags passed to g_dbus_connection_register_subtree().\n\n Since: 2.26"]
pub type GDBusSubtreeFlags = ::std::os::raw::c_uint;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_NONE: GDBusServerFlags = 0;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: GDBusServerFlags = 1;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: GDBusServerFlags = 2;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: GDBusServerFlags =
    4;
#[doc = " GDBusServerFlags:\n @G_DBUS_SERVER_FLAGS_NONE: No flags set.\n @G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: All #GDBusServer::new-connection\n signals will run in separated dedicated threads (see signal for\n details).\n @G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: Allow the anonymous\n authentication method.\n @G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: Require the UID of the\n peer to be the same as the UID of the server when authenticating. (Since: 2.68)\n\n Flags used when creating a #GDBusServer.\n\n Since: 2.26"]
pub type GDBusServerFlags = ::std::os::raw::c_uint;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NONE: GDBusSignalFlags = 0;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: GDBusSignalFlags = 1;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: GDBusSignalFlags = 2;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: GDBusSignalFlags = 4;
#[doc = " GDBusSignalFlags:\n @G_DBUS_SIGNAL_FLAGS_NONE: No flags set.\n @G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch\n D-Bus call for this signal subscription.  This gives you more control\n over which match rules you add (but you must add them manually).\n @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: Match first arguments that\n contain a bus or interface name with the given namespace.\n @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: Match first arguments that\n contain an object path that is either equivalent to the given path,\n or one of the paths is a subpath of the other.\n\n Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().\n\n Since: 2.26"]
pub type GDBusSignalFlags = ::std::os::raw::c_uint;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_NONE: GDBusSendMessageFlags = 0;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: GDBusSendMessageFlags =
    1;
#[doc = " GDBusSendMessageFlags:\n @G_DBUS_SEND_MESSAGE_FLAGS_NONE: No flags set.\n @G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: Do not automatically\n assign a serial number from the #GDBusConnection object when\n sending a message.\n\n Flags used when sending #GDBusMessages on a #GDBusConnection.\n\n Since: 2.26"]
pub type GDBusSendMessageFlags = ::std::os::raw::c_uint;
pub const GCredentialsType_G_CREDENTIALS_TYPE_INVALID: GCredentialsType = 0;
pub const GCredentialsType_G_CREDENTIALS_TYPE_LINUX_UCRED: GCredentialsType = 1;
pub const GCredentialsType_G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: GCredentialsType = 2;
pub const GCredentialsType_G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: GCredentialsType = 3;
pub const GCredentialsType_G_CREDENTIALS_TYPE_SOLARIS_UCRED: GCredentialsType = 4;
pub const GCredentialsType_G_CREDENTIALS_TYPE_NETBSD_UNPCBID: GCredentialsType = 5;
pub const GCredentialsType_G_CREDENTIALS_TYPE_APPLE_XUCRED: GCredentialsType = 6;
pub const GCredentialsType_G_CREDENTIALS_TYPE_WIN32_PID: GCredentialsType = 7;
#[doc = " GCredentialsType:\n @G_CREDENTIALS_TYPE_INVALID: Indicates an invalid native credential type.\n @G_CREDENTIALS_TYPE_LINUX_UCRED: The native credentials type is a `struct ucred`.\n @G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: The native credentials type is a `struct cmsgcred`.\n @G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: The native credentials type is a `struct sockpeercred`. Added in 2.30.\n @G_CREDENTIALS_TYPE_SOLARIS_UCRED: The native credentials type is a `ucred_t`. Added in 2.40.\n @G_CREDENTIALS_TYPE_NETBSD_UNPCBID: The native credentials type is a `struct unpcbid`. Added in 2.42.\n @G_CREDENTIALS_TYPE_APPLE_XUCRED: The native credentials type is a `struct xucred`. Added in 2.66.\n @G_CREDENTIALS_TYPE_WIN32_PID: The native credentials type is a PID `DWORD`. Added in 2.72.\n\n Enumeration describing different kinds of native credential types.\n\n Since: 2.26"]
pub type GCredentialsType = ::std::os::raw::c_uint;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: GDBusMessageByteOrder = 66;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: GDBusMessageByteOrder =
    108;
#[doc = " GDBusMessageByteOrder:\n @G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: The byte order is big endian.\n @G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: The byte order is little endian.\n\n Enumeration used to describe the byte order of a D-Bus message.\n\n Since: 2.26"]
pub type GDBusMessageByteOrder = ::std::os::raw::c_uint;
pub const GApplicationFlags_G_APPLICATION_FLAGS_NONE: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_DEFAULT_FLAGS: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_IS_SERVICE: GApplicationFlags = 1;
pub const GApplicationFlags_G_APPLICATION_IS_LAUNCHER: GApplicationFlags = 2;
pub const GApplicationFlags_G_APPLICATION_HANDLES_OPEN: GApplicationFlags = 4;
pub const GApplicationFlags_G_APPLICATION_HANDLES_COMMAND_LINE: GApplicationFlags = 8;
pub const GApplicationFlags_G_APPLICATION_SEND_ENVIRONMENT: GApplicationFlags = 16;
pub const GApplicationFlags_G_APPLICATION_NON_UNIQUE: GApplicationFlags = 32;
pub const GApplicationFlags_G_APPLICATION_CAN_OVERRIDE_APP_ID: GApplicationFlags = 64;
pub const GApplicationFlags_G_APPLICATION_ALLOW_REPLACEMENT: GApplicationFlags = 128;
pub const GApplicationFlags_G_APPLICATION_REPLACE: GApplicationFlags = 256;
#[doc = " GApplicationFlags:\n @G_APPLICATION_FLAGS_NONE: Default. Deprecated in 2.74, use\n   %G_APPLICATION_DEFAULT_FLAGS instead\n @G_APPLICATION_DEFAULT_FLAGS: Default flags. Since: 2.74\n @G_APPLICATION_IS_SERVICE: Run as a service. In this mode, registration\n      fails if the service is already running, and the application\n      will initially wait up to 10 seconds for an initial activation\n      message to arrive.\n @G_APPLICATION_IS_LAUNCHER: Don't try to become the primary instance.\n @G_APPLICATION_HANDLES_OPEN: This application handles opening files (in\n     the primary instance). Note that this flag only affects the default\n     implementation of local_command_line(), and has no effect if\n     %G_APPLICATION_HANDLES_COMMAND_LINE is given.\n     See g_application_run() for details.\n @G_APPLICATION_HANDLES_COMMAND_LINE: This application handles command line\n     arguments (in the primary instance). Note that this flag only affect\n     the default implementation of local_command_line().\n     See g_application_run() for details.\n @G_APPLICATION_SEND_ENVIRONMENT: Send the environment of the\n     launching process to the primary instance. Set this flag if your\n     application is expected to behave differently depending on certain\n     environment variables. For instance, an editor might be expected\n     to use the `GIT_COMMITTER_NAME` environment variable\n     when editing a git commit message. The environment is available\n     to the #GApplication::command-line signal handler, via\n     g_application_command_line_getenv().\n @G_APPLICATION_NON_UNIQUE: Make no attempts to do any of the typical\n     single-instance application negotiation, even if the application\n     ID is given.  The application neither attempts to become the\n     owner of the application ID nor does it check if an existing\n     owner already exists.  Everything occurs in the local process.\n     Since: 2.30.\n @G_APPLICATION_CAN_OVERRIDE_APP_ID: Allow users to override the\n     application ID from the command line with `--gapplication-app-id`.\n     Since: 2.48\n @G_APPLICATION_ALLOW_REPLACEMENT: Allow another instance to take over\n     the bus name. Since: 2.60\n @G_APPLICATION_REPLACE: Take over from another instance. This flag is\n     usually set by passing `--gapplication-replace` on the commandline.\n     Since: 2.60\n\n Flags used to define the behaviour of a #GApplication.\n\n Since: 2.28"]
pub type GApplicationFlags = ::std::os::raw::c_uint;
pub const GTlsError_G_TLS_ERROR_UNAVAILABLE: GTlsError = 0;
pub const GTlsError_G_TLS_ERROR_MISC: GTlsError = 1;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE: GTlsError = 2;
pub const GTlsError_G_TLS_ERROR_NOT_TLS: GTlsError = 3;
pub const GTlsError_G_TLS_ERROR_HANDSHAKE: GTlsError = 4;
pub const GTlsError_G_TLS_ERROR_CERTIFICATE_REQUIRED: GTlsError = 5;
pub const GTlsError_G_TLS_ERROR_EOF: GTlsError = 6;
pub const GTlsError_G_TLS_ERROR_INAPPROPRIATE_FALLBACK: GTlsError = 7;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: GTlsError = 8;
#[doc = " GTlsError:\n @G_TLS_ERROR_UNAVAILABLE: No TLS provider is available\n @G_TLS_ERROR_MISC: Miscellaneous TLS error\n @G_TLS_ERROR_BAD_CERTIFICATE: The certificate presented could not\n   be parsed or failed validation.\n @G_TLS_ERROR_NOT_TLS: The TLS handshake failed because the\n   peer does not seem to be a TLS server.\n @G_TLS_ERROR_HANDSHAKE: The TLS handshake failed because the\n   peer's certificate was not acceptable.\n @G_TLS_ERROR_CERTIFICATE_REQUIRED: The TLS handshake failed because\n   the server requested a client-side certificate, but none was\n   provided. See g_tls_connection_set_certificate().\n @G_TLS_ERROR_EOF: The TLS connection was closed without proper\n   notice, which may indicate an attack. See\n   g_tls_connection_set_require_close_notify().\n @G_TLS_ERROR_INAPPROPRIATE_FALLBACK: The TLS handshake failed\n   because the client sent the fallback SCSV, indicating a protocol\n   downgrade attack. Since: 2.60\n @G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: The certificate failed\n   to load because a password was incorrect. Since: 2.72\n\n An error code used with %G_TLS_ERROR in a #GError returned from a\n TLS-related routine.\n\n Since: 2.28"]
pub type GTlsError = ::std::os::raw::c_uint;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NO_FLAGS: GTlsCertificateFlags = 0;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_UNKNOWN_CA: GTlsCertificateFlags = 1;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_BAD_IDENTITY: GTlsCertificateFlags = 2;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NOT_ACTIVATED: GTlsCertificateFlags = 4;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_EXPIRED: GTlsCertificateFlags = 8;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_REVOKED: GTlsCertificateFlags = 16;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_INSECURE: GTlsCertificateFlags = 32;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_GENERIC_ERROR: GTlsCertificateFlags = 64;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_VALIDATE_ALL: GTlsCertificateFlags = 127;
#[doc = " GTlsCertificateFlags:\n @G_TLS_CERTIFICATE_NO_FLAGS: No flags set. Since: 2.74\n @G_TLS_CERTIFICATE_UNKNOWN_CA: The signing certificate authority is\n   not known.\n @G_TLS_CERTIFICATE_BAD_IDENTITY: The certificate does not match the\n   expected identity of the site that it was retrieved from.\n @G_TLS_CERTIFICATE_NOT_ACTIVATED: The certificate's activation time\n   is still in the future\n @G_TLS_CERTIFICATE_EXPIRED: The certificate has expired\n @G_TLS_CERTIFICATE_REVOKED: The certificate has been revoked\n   according to the #GTlsConnection's certificate revocation list.\n @G_TLS_CERTIFICATE_INSECURE: The certificate's algorithm is\n   considered insecure.\n @G_TLS_CERTIFICATE_GENERIC_ERROR: Some other error occurred validating\n   the certificate\n @G_TLS_CERTIFICATE_VALIDATE_ALL: the combination of all of the above\n   flags\n\n A set of flags describing TLS certification validation. This can be\n used to describe why a particular certificate was rejected (for\n example, in #GTlsConnection::accept-certificate).\n\n GLib guarantees that if certificate verification fails, at least one\n flag will be set, but it does not guarantee that all possible flags\n will be set. Accordingly, you may not safely decide to ignore any\n particular type of error. For example, it would be incorrect to mask\n %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,\n because this could potentially be the only error flag set even if\n other problems exist with the certificate.\n\n Since: 2.28"]
pub type GTlsCertificateFlags = ::std::os::raw::c_uint;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_NONE: GTlsAuthenticationMode = 0;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUESTED: GTlsAuthenticationMode = 1;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUIRED: GTlsAuthenticationMode = 2;
#[doc = " GTlsAuthenticationMode:\n @G_TLS_AUTHENTICATION_NONE: client authentication not required\n @G_TLS_AUTHENTICATION_REQUESTED: client authentication is requested\n @G_TLS_AUTHENTICATION_REQUIRED: client authentication is required\n\n The client authentication mode for a #GTlsServerConnection.\n\n Since: 2.28"]
pub type GTlsAuthenticationMode = ::std::os::raw::c_uint;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_UNIQUE: GTlsChannelBindingType = 0;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:
    GTlsChannelBindingType = 1;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_EXPORTER: GTlsChannelBindingType = 2;
#[doc = " GTlsChannelBindingType:\n @G_TLS_CHANNEL_BINDING_TLS_UNIQUE:\n    [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding\n    type\n @G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:\n    [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)\n    binding type\n @G_TLS_CHANNEL_BINDING_TLS_EXPORTER:\n    [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding\n    type. Since: 2.74\n\n The type of TLS channel binding data to retrieve from #GTlsConnection\n or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The\n [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)\n binding type is not currently implemented.\n\n Since: 2.66"]
pub type GTlsChannelBindingType = ::std::os::raw::c_uint;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED:
    GTlsChannelBindingError = 0;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE:
    GTlsChannelBindingError = 1;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE:
    GTlsChannelBindingError = 2;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED:
    GTlsChannelBindingError = 3;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR:
    GTlsChannelBindingError = 4;
#[doc = " GTlsChannelBindingError:\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED: Either entire binding\n    retrieval facility or specific binding type is not implemented in the\n    TLS backend.\n @G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE: The handshake is not yet\n    complete on the connection which is a strong requirement for any existing\n    binding type.\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE: Handshake is complete but\n    binding data is not available. That normally indicates the TLS\n    implementation failed to provide the binding data. For example, some\n    implementations do not provide a peer certificate for resumed connections.\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED: Binding type is not supported\n    on the current connection. This error could be triggered when requesting\n    `tls-server-end-point` binding data for a certificate which has no hash\n    function or uses multiple hash functions.\n @G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR: Any other backend error\n    preventing binding data retrieval.\n\n An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to\n indicate a TLS channel binding retrieval error.\n\n Since: 2.66"]
pub type GTlsChannelBindingError = ::std::os::raw::c_uint;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_NEVER: GTlsRehandshakeMode = 0;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_SAFELY: GTlsRehandshakeMode = 1;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_UNSAFELY: GTlsRehandshakeMode = 2;
#[doc = " GTlsRehandshakeMode:\n @G_TLS_REHANDSHAKE_NEVER: Never allow rehandshaking\n @G_TLS_REHANDSHAKE_SAFELY: Allow safe rehandshaking only\n @G_TLS_REHANDSHAKE_UNSAFELY: Allow unsafe rehandshaking\n\n When to allow rehandshaking. See\n g_tls_connection_set_rehandshake_mode().\n\n Since: 2.28\n\n Deprecated: 2.60. Changing the rehandshake mode is no longer\n   required for compatibility. Also, rehandshaking has been removed\n   from the TLS protocol in TLS 1.3."]
pub type GTlsRehandshakeMode = ::std::os::raw::c_uint;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_NONE: _GTlsPasswordFlags = 0;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_RETRY: _GTlsPasswordFlags = 2;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_MANY_TRIES: _GTlsPasswordFlags = 4;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_FINAL_TRY: _GTlsPasswordFlags = 8;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_USER: _GTlsPasswordFlags = 16;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: _GTlsPasswordFlags = 32;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: _GTlsPasswordFlags = 64;
#[doc = " GTlsPasswordFlags:\n @G_TLS_PASSWORD_NONE: No flags\n @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.\n @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been\n    wrong many times, and the user may not have many chances left.\n @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get\n    this password right.\n @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.\n    Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer\n    PIN is required. Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific\n    PIN is required. Since: 2.70.\n\n Various flags for the password.\n\n Since: 2.30"]
pub type _GTlsPasswordFlags = ::std::os::raw::c_uint;
#[doc = " GTlsPasswordFlags:\n @G_TLS_PASSWORD_NONE: No flags\n @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.\n @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been\n    wrong many times, and the user may not have many chances left.\n @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get\n    this password right.\n @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.\n    Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer\n    PIN is required. Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific\n    PIN is required. Since: 2.70.\n\n Various flags for the password.\n\n Since: 2.30"]
pub use self::_GTlsPasswordFlags as GTlsPasswordFlags;
pub const GTlsInteractionResult_G_TLS_INTERACTION_UNHANDLED: GTlsInteractionResult = 0;
pub const GTlsInteractionResult_G_TLS_INTERACTION_HANDLED: GTlsInteractionResult = 1;
pub const GTlsInteractionResult_G_TLS_INTERACTION_FAILED: GTlsInteractionResult = 2;
#[doc = " GTlsInteractionResult:\n @G_TLS_INTERACTION_UNHANDLED: The interaction was unhandled (i.e. not\n     implemented).\n @G_TLS_INTERACTION_HANDLED: The interaction completed, and resulting data\n     is available.\n @G_TLS_INTERACTION_FAILED: The interaction has failed, or was cancelled.\n     and the operation should be aborted.\n\n #GTlsInteractionResult is returned by various functions in #GTlsInteraction\n when finishing an interaction request.\n\n Since: 2.30"]
pub type GTlsInteractionResult = ::std::os::raw::c_uint;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_NONE:
    GDBusInterfaceSkeletonFlags = 0;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD : GDBusInterfaceSkeletonFlags = 1 ;
#[doc = " GDBusInterfaceSkeletonFlags:\n @G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: No flags set.\n @G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: Each method invocation is handled in\n   a thread dedicated to the invocation. This means that the method implementation can use blocking IO\n   without blocking any other part of the process. It also means that the method implementation must\n   use locking to access data structures used by other threads.\n\n Flags describing the behavior of a #GDBusInterfaceSkeleton instance.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeletonFlags = ::std::os::raw::c_uint;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE:
    GDBusObjectManagerClientFlags = 0;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START:
    GDBusObjectManagerClientFlags = 1;
#[doc = " GDBusObjectManagerClientFlags:\n @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: No flags set.\n @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: If not set and the\n   manager is for a well-known name, then request the bus to launch\n   an owner for the name if no-one owns the name. This flag can only\n   be used in managers for well-known names.\n\n Flags used when constructing a #GDBusObjectManagerClient.\n\n Since: 2.30"]
pub type GDBusObjectManagerClientFlags = ::std::os::raw::c_uint;
pub const GTlsDatabaseVerifyFlags_G_TLS_DATABASE_VERIFY_NONE: GTlsDatabaseVerifyFlags = 0;
#[doc = " GTlsDatabaseVerifyFlags:\n @G_TLS_DATABASE_VERIFY_NONE: No verification flags\n\n Flags for g_tls_database_verify_chain().\n\n Since: 2.30"]
pub type GTlsDatabaseVerifyFlags = ::std::os::raw::c_uint;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_NONE: GTlsDatabaseLookupFlags = 0;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_KEYPAIR: GTlsDatabaseLookupFlags = 1;
#[doc = " GTlsDatabaseLookupFlags:\n @G_TLS_DATABASE_LOOKUP_NONE: No lookup flags\n @G_TLS_DATABASE_LOOKUP_KEYPAIR: Restrict lookup to certificates that have\n     a private key.\n\n Flags for g_tls_database_lookup_certificate_for_handle(),\n g_tls_database_lookup_certificate_issuer(),\n and g_tls_database_lookup_certificates_issued_by().\n\n Since: 2.30"]
pub type GTlsDatabaseLookupFlags = ::std::os::raw::c_uint;
pub const GTlsCertificateRequestFlags_G_TLS_CERTIFICATE_REQUEST_NONE: GTlsCertificateRequestFlags =
    0;
#[doc = " GTlsCertificateRequestFlags:\n @G_TLS_CERTIFICATE_REQUEST_NONE: No flags\n\n Flags for g_tls_interaction_request_certificate(),\n g_tls_interaction_request_certificate_async(), and\n g_tls_interaction_invoke_request_certificate().\n\n Since: 2.40"]
pub type GTlsCertificateRequestFlags = ::std::os::raw::c_uint;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_UNKNOWN: GTlsProtocolVersion = 0;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_SSL_3_0: GTlsProtocolVersion = 1;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_0: GTlsProtocolVersion = 2;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_1: GTlsProtocolVersion = 3;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_2: GTlsProtocolVersion = 4;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_3: GTlsProtocolVersion = 5;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_0: GTlsProtocolVersion = 201;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_2: GTlsProtocolVersion = 202;
#[doc = " GTlsProtocolVersion:\n @G_TLS_PROTOCOL_VERSION_UNKNOWN: No protocol version or unknown protocol version\n @G_TLS_PROTOCOL_VERSION_SSL_3_0: SSL 3.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_0: TLS 1.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_1: TLS 1.1, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_2: TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)\n @G_TLS_PROTOCOL_VERSION_TLS_1_3: TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)\n @G_TLS_PROTOCOL_VERSION_DTLS_1_0: DTLS 1.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_DTLS_1_2: DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)\n\n The TLS or DTLS protocol version used by a #GTlsConnection or\n #GDtlsConnection. The integer values of these versions are sequential\n to ensure newer known protocol versions compare greater than older\n known versions. Any known DTLS protocol version will compare greater\n than any SSL or TLS protocol version. The protocol version may be\n %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer\n protocol version that GLib does not yet know about. This means that\n it's possible for an unknown DTLS protocol version to compare less\n than the TLS protocol versions.\n\n Since: 2.70"]
pub type GTlsProtocolVersion = ::std::os::raw::c_uint;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_NONE: GIOModuleScopeFlags = 0;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: GIOModuleScopeFlags = 1;
#[doc = " GIOModuleScopeFlags:\n @G_IO_MODULE_SCOPE_NONE: No module scan flags\n @G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: When using this scope to load or\n     scan modules, automatically block a modules which has the same base\n     basename as previously loaded module.\n\n Flags for use with g_io_module_scope_new().\n\n Since: 2.30"]
pub type GIOModuleScopeFlags = ::std::os::raw::c_uint;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVING: GSocketClientEvent = 0;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVED: GSocketClientEvent = 1;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTING: GSocketClientEvent = 2;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTED: GSocketClientEvent = 3;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATING: GSocketClientEvent = 4;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATED: GSocketClientEvent = 5;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKING: GSocketClientEvent = 6;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKED: GSocketClientEvent = 7;
pub const GSocketClientEvent_G_SOCKET_CLIENT_COMPLETE: GSocketClientEvent = 8;
#[doc = " GSocketClientEvent:\n @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.\n @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.\n @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote\n   host (either a proxy or the destination server).\n @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote\n   host.\n @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating\n   with a proxy to connect to the destination server.\n @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated\n   with the proxy server.\n @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a\n   TLS handshake.\n @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a\n   TLS handshake.\n @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular\n   #GSocketConnectable.\n\n Describes an event occurring on a #GSocketClient. See the\n #GSocketClient::event signal for more details.\n\n Additional values may be added to this type in the future.\n\n Since: 2.32"]
pub type GSocketClientEvent = ::std::os::raw::c_uint;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BINDING: GSocketListenerEvent = 0;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BOUND: GSocketListenerEvent = 1;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENING: GSocketListenerEvent = 2;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENED: GSocketListenerEvent = 3;
#[doc = " GSocketListenerEvent:\n @G_SOCKET_LISTENER_BINDING: The listener is about to bind a socket.\n @G_SOCKET_LISTENER_BOUND: The listener has bound a socket.\n @G_SOCKET_LISTENER_LISTENING: The listener is about to start\n    listening on this socket.\n @G_SOCKET_LISTENER_LISTENED: The listener is now listening on\n   this socket.\n\n Describes an event occurring on a #GSocketListener. See the\n #GSocketListener::event signal for more details.\n\n Additional values may be added to this type in the future.\n\n Since: 2.46"]
pub type GSocketListenerEvent = ::std::os::raw::c_uint;
pub const GTestDBusFlags_G_TEST_DBUS_NONE: GTestDBusFlags = 0;
#[doc = " GTestDBusFlags:\n @G_TEST_DBUS_NONE: No flags.\n\n Flags to define future #GTestDBus behaviour.\n\n Since: 2.34"]
pub type GTestDBusFlags = ::std::os::raw::c_uint;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_NONE: GSubprocessFlags = 0;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_PIPE: GSubprocessFlags = 1;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_INHERIT: GSubprocessFlags = 2;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_PIPE: GSubprocessFlags = 4;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_SILENCE: GSubprocessFlags = 8;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_PIPE: GSubprocessFlags = 16;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_SILENCE: GSubprocessFlags = 32;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_MERGE: GSubprocessFlags = 64;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_INHERIT_FDS: GSubprocessFlags = 128;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: GSubprocessFlags = 256;
#[doc = " GSubprocessFlags:\n @G_SUBPROCESS_FLAGS_NONE: No flags.\n @G_SUBPROCESS_FLAGS_STDIN_PIPE: create a pipe for the stdin of the\n   spawned process that can be accessed with\n   g_subprocess_get_stdin_pipe().\n @G_SUBPROCESS_FLAGS_STDIN_INHERIT: stdin is inherited from the\n   calling process.\n @G_SUBPROCESS_FLAGS_STDOUT_PIPE: create a pipe for the stdout of the\n   spawned process that can be accessed with\n   g_subprocess_get_stdout_pipe().\n @G_SUBPROCESS_FLAGS_STDOUT_SILENCE: silence the stdout of the spawned\n   process (ie: redirect to `/dev/null`).\n @G_SUBPROCESS_FLAGS_STDERR_PIPE: create a pipe for the stderr of the\n   spawned process that can be accessed with\n   g_subprocess_get_stderr_pipe().\n @G_SUBPROCESS_FLAGS_STDERR_SILENCE: silence the stderr of the spawned\n   process (ie: redirect to `/dev/null`).\n @G_SUBPROCESS_FLAGS_STDERR_MERGE: merge the stderr of the spawned\n   process with whatever the stdout happens to be.  This is a good way\n   of directing both streams to a common log file, for example.\n @G_SUBPROCESS_FLAGS_INHERIT_FDS: spawned processes will inherit the\n   file descriptors of their parent, unless those descriptors have\n   been explicitly marked as close-on-exec.  This flag has no effect\n   over the \"standard\" file descriptors (stdin, stdout, stderr).\n @G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: if path searching is\n   needed when spawning the subprocess, use the `PATH` in the launcher\n   environment. (Since: 2.72)\n\n Flags to define the behaviour of a #GSubprocess.\n\n Note that the default for stdin is to redirect from `/dev/null`.  For\n stdout and stderr the default are for them to inherit the\n corresponding descriptor from the calling process.\n\n Note that it is a programmer error to mix 'incompatible' flags.  For\n example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and\n %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.\n\n Since: 2.40"]
pub type GSubprocessFlags = ::std::os::raw::c_uint;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_NORMAL: GNotificationPriority = 0;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_LOW: GNotificationPriority = 1;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_HIGH: GNotificationPriority = 2;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_URGENT: GNotificationPriority = 3;
#[doc = " GNotificationPriority:\n @G_NOTIFICATION_PRIORITY_LOW: for notifications that do not require\n   immediate attention - typically used for contextual background\n   information, such as contact birthdays or local weather\n @G_NOTIFICATION_PRIORITY_NORMAL: the default priority, to be used for the\n   majority of notifications (for example email messages, software updates,\n   completed download/sync operations)\n @G_NOTIFICATION_PRIORITY_HIGH: for events that require more attention,\n   usually because responses are time-sensitive (for example chat and SMS\n   messages or alarms)\n @G_NOTIFICATION_PRIORITY_URGENT: for urgent notifications, or notifications\n   that require a response in a short space of time (for example phone calls\n   or emergency warnings)\n\n Priority levels for #GNotifications.\n\n Since: 2.42"]
pub type GNotificationPriority = ::std::os::raw::c_uint;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LOCAL: GNetworkConnectivity = 1;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LIMITED: GNetworkConnectivity = 2;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_PORTAL: GNetworkConnectivity = 3;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_FULL: GNetworkConnectivity = 4;
#[doc = " GNetworkConnectivity:\n @G_NETWORK_CONNECTIVITY_LOCAL: The host is not configured with a\n   route to the Internet; it may or may not be connected to a local\n   network.\n @G_NETWORK_CONNECTIVITY_LIMITED: The host is connected to a network, but\n   does not appear to be able to reach the full Internet, perhaps\n   due to upstream network problems.\n @G_NETWORK_CONNECTIVITY_PORTAL: The host is behind a captive portal and\n   cannot reach the full Internet.\n @G_NETWORK_CONNECTIVITY_FULL: The host is connected to a network, and\n   appears to be able to reach the full Internet.\n\n The host's network connectivity state, as reported by #GNetworkMonitor.\n\n Since: 2.44"]
pub type GNetworkConnectivity = ::std::os::raw::c_uint;
pub const GPollableReturn_G_POLLABLE_RETURN_FAILED: GPollableReturn = 0;
pub const GPollableReturn_G_POLLABLE_RETURN_OK: GPollableReturn = 1;
pub const GPollableReturn_G_POLLABLE_RETURN_WOULD_BLOCK: GPollableReturn = -27;
#[doc = " GPollableReturn:\n @G_POLLABLE_RETURN_FAILED: Generic error condition for when an operation fails.\n @G_POLLABLE_RETURN_OK: The operation was successfully finished.\n @G_POLLABLE_RETURN_WOULD_BLOCK: The operation would block.\n\n Return value for various IO operations that signal errors via the\n return value and not necessarily via a #GError.\n\n This enum exists to be able to return errors to callers without having to\n allocate a #GError. Allocating #GErrors can be quite expensive for\n regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.\n\n In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the\n operation to give details about the error that happened.\n\n Since: 2.60"]
pub type GPollableReturn = ::std::os::raw::c_int;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_LOW:
    GMemoryMonitorWarningLevel = 50;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM:
    GMemoryMonitorWarningLevel = 100;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL:
    GMemoryMonitorWarningLevel = 255;
#[doc = " GMemoryMonitorWarningLevel:\n @G_MEMORY_MONITOR_WARNING_LEVEL_LOW: Memory on the device is low, processes\n   should free up unneeded resources (for example, in-memory caches) so they can\n   be used elsewhere.\n @G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM: Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW\n   but the device has even less free memory, so processes should try harder to free\n   up unneeded resources. If your process does not need to stay running, it is a\n   good time for it to quit.\n @G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL: The system will soon start terminating\n   processes to reclaim memory, including background processes.\n\n Memory availability warning levels.\n\n Note that because new values might be added, it is recommended that applications check\n #GMemoryMonitorWarningLevel as ranges, for example:\n |[<!-- language=\"C\" -->\n if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)\n   drop_caches ();\n ]|\n\n Since: 2.64"]
pub type GMemoryMonitorWarningLevel = ::std::os::raw::c_uint;
#[doc = " GAppLaunchContext:\n\n Integrating the launch with the launching application. This is used to\n handle for instance startup notification and launching the new application\n on the same screen as the launching window."]
pub type GAppLaunchContext = _GAppLaunchContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfo {
    _unused: [u8; 0],
}
pub type GAppInfo = _GAppInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResult {
    _unused: [u8; 0],
}
pub type GAsyncResult = _GAsyncResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitable {
    _unused: [u8; 0],
}
pub type GAsyncInitable = _GAsyncInitable;
pub type GBufferedInputStream = _GBufferedInputStream;
pub type GBufferedOutputStream = _GBufferedOutputStream;
pub type GCancellable = _GCancellable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverter {
    _unused: [u8; 0],
}
pub type GCharsetConverter = _GCharsetConverter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverter {
    _unused: [u8; 0],
}
pub type GConverter = _GConverter;
pub type GConverterInputStream = _GConverterInputStream;
pub type GConverterOutputStream = _GConverterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBased {
    _unused: [u8; 0],
}
pub type GDatagramBased = _GDatagramBased;
pub type GDataInputStream = _GDataInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimplePermission {
    _unused: [u8; 0],
}
pub type GSimplePermission = _GSimplePermission;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressor {
    _unused: [u8; 0],
}
pub type GZlibCompressor = _GZlibCompressor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressor {
    _unused: [u8; 0],
}
pub type GZlibDecompressor = _GZlibDecompressor;
#[doc = " GSimpleActionGroup:\n\n The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.\n\n Since: 2.28"]
pub type GSimpleActionGroup = _GSimpleActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroup {
    _unused: [u8; 0],
}
pub type GRemoteActionGroup = _GRemoteActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusActionGroup {
    _unused: [u8; 0],
}
pub type GDBusActionGroup = _GDBusActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMap {
    _unused: [u8; 0],
}
pub type GActionMap = _GActionMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroup {
    _unused: [u8; 0],
}
pub type GActionGroup = _GActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPropertyAction {
    _unused: [u8; 0],
}
pub type GPropertyAction = _GPropertyAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAction {
    _unused: [u8; 0],
}
pub type GSimpleAction = _GSimpleAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAction {
    _unused: [u8; 0],
}
pub type GAction = _GAction;
pub type GApplication = _GApplication;
pub type GApplicationCommandLine = _GApplicationCommandLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsBackend {
    _unused: [u8; 0],
}
pub type GSettingsBackend = _GSettingsBackend;
pub type GSettings = _GSettings;
pub type GPermission = _GPermission;
pub type GMenuModel = _GMenuModel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNotification {
    _unused: [u8; 0],
}
pub type GNotification = _GNotification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDrive {
    _unused: [u8; 0],
}
#[doc = " GDrive:\n\n Opaque drive object."]
pub type GDrive = _GDrive;
pub type GFileEnumerator = _GFileEnumerator;
#[doc = " GFileMonitor:\n\n Watches for changes to a file."]
pub type GFileMonitor = _GFileMonitor;
pub type GFilterInputStream = _GFilterInputStream;
pub type GFilterOutputStream = _GFilterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFile {
    _unused: [u8; 0],
}
#[doc = " GFile:\n\n A handle to an object implementing the #GFileIface interface.\n Generally stores a location within the file system. Handles do not\n necessarily represent files or directories that currently exist."]
pub type GFile = _GFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfo {
    _unused: [u8; 0],
}
pub type GFileInfo = _GFileInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeMatcher {
    _unused: [u8; 0],
}
#[doc = " GFileAttributeMatcher:\n\n Determines if a string matches a file attribute."]
pub type GFileAttributeMatcher = _GFileAttributeMatcher;
#[doc = " GFileAttributeInfo:\n @name: the name of the attribute.\n @type: the #GFileAttributeType type of the attribute.\n @flags: a set of #GFileAttributeInfoFlags.\n\n Information about a specific attribute."]
pub type GFileAttributeInfo = _GFileAttributeInfo;
#[doc = " GFileAttributeInfoList:\n @infos: an array of #GFileAttributeInfos.\n @n_infos: the number of values in the array.\n\n Acts as a lightweight registry for possible valid file attributes.\n The registry stores Key-Value pair formats as #GFileAttributeInfos."]
pub type GFileAttributeInfoList = _GFileAttributeInfoList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileDescriptorBased {
    _unused: [u8; 0],
}
pub type GFileDescriptorBased = _GFileDescriptorBased;
pub type GFileInputStream = _GFileInputStream;
pub type GFileOutputStream = _GFileOutputStream;
pub type GFileIOStream = _GFileIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIcon {
    _unused: [u8; 0],
}
pub type GFileIcon = _GFileIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleter {
    _unused: [u8; 0],
}
pub type GFilenameCompleter = _GFilenameCompleter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIcon {
    _unused: [u8; 0],
}
pub type GIcon = _GIcon;
pub type GInetAddress = _GInetAddress;
pub type GInetAddressMask = _GInetAddressMask;
pub type GInetSocketAddress = _GInetSocketAddress;
pub type GNativeSocketAddress = _GNativeSocketAddress;
pub type GInputStream = _GInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitable {
    _unused: [u8; 0],
}
pub type GInitable = _GInitable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModule {
    _unused: [u8; 0],
}
pub type GIOModule = _GIOModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtensionPoint {
    _unused: [u8; 0],
}
pub type GIOExtensionPoint = _GIOExtensionPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtension {
    _unused: [u8; 0],
}
pub type GIOExtension = _GIOExtension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOSchedulerJob {
    _unused: [u8; 0],
}
#[doc = " GIOSchedulerJob:\n\n Opaque class for defining and scheduling IO jobs."]
pub type GIOSchedulerJob = _GIOSchedulerJob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamAdapter {
    _unused: [u8; 0],
}
pub type GIOStreamAdapter = _GIOStreamAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIcon {
    _unused: [u8; 0],
}
pub type GLoadableIcon = _GLoadableIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytesIcon {
    _unused: [u8; 0],
}
pub type GBytesIcon = _GBytesIcon;
pub type GMemoryInputStream = _GMemoryInputStream;
pub type GMemoryOutputStream = _GMemoryOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMount {
    _unused: [u8; 0],
}
#[doc = " GMount:\n\n A handle to an object implementing the #GMountIface interface."]
pub type GMount = _GMount;
pub type GMountOperation = _GMountOperation;
pub type GNetworkAddress = _GNetworkAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitor {
    _unused: [u8; 0],
}
pub type GNetworkMonitor = _GNetworkMonitor;
pub type GNetworkService = _GNetworkService;
pub type GOutputStream = _GOutputStream;
#[doc = " GIOStream:\n\n Base class for read-write streams."]
pub type GIOStream = _GIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleIOStream {
    _unused: [u8; 0],
}
pub type GSimpleIOStream = _GSimpleIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStream {
    _unused: [u8; 0],
}
pub type GPollableInputStream = _GPollableInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStream {
    _unused: [u8; 0],
}
pub type GPollableOutputStream = _GPollableOutputStream;
pub type GResolver = _GResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResource {
    _unused: [u8; 0],
}
#[doc = " GResource:\n\n A resource bundle.\n\n Since: 2.32"]
pub type GResource = _GResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekable {
    _unused: [u8; 0],
}
pub type GSeekable = _GSeekable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResult {
    _unused: [u8; 0],
}
pub type GSimpleAsyncResult = _GSimpleAsyncResult;
#[doc = " GSocket:\n\n A lowlevel network socket object.\n\n Since: 2.22"]
pub type GSocket = _GSocket;
#[doc = " GSocketControlMessage:\n\n Base class for socket-type specific control messages that can be sent and\n received over #GSocket."]
pub type GSocketControlMessage = _GSocketControlMessage;
#[doc = " GSocketClient:\n\n A helper class for network clients to make connections.\n\n Since: 2.22"]
pub type GSocketClient = _GSocketClient;
#[doc = " GSocketConnection:\n\n A socket connection GIOStream object for connection-oriented sockets.\n\n Since: 2.22"]
pub type GSocketConnection = _GSocketConnection;
#[doc = " GSocketListener:\n\n A helper class for network servers to listen for and accept connections.\n\n Since: 2.22"]
pub type GSocketListener = _GSocketListener;
#[doc = " GSocketService:\n\n A helper class for handling accepting incoming connections in the\n glib mainloop.\n\n Since: 2.22"]
pub type GSocketService = _GSocketService;
pub type GSocketAddress = _GSocketAddress;
pub type GSocketAddressEnumerator = _GSocketAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectable {
    _unused: [u8; 0],
}
pub type GSocketConnectable = _GSocketConnectable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSrvTarget {
    _unused: [u8; 0],
}
pub type GSrvTarget = _GSrvTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTask {
    _unused: [u8; 0],
}
pub type GTask = _GTask;
#[doc = " GTcpConnection:\n\n A #GSocketConnection for TCP/IP connections.\n\n Since: 2.22"]
pub type GTcpConnection = _GTcpConnection;
pub type GTcpWrapperConnection = _GTcpWrapperConnection;
#[doc = " GThreadedSocketService:\n\n A helper class for handling accepting incoming connections in the\n glib mainloop and handling them in a thread.\n\n Since: 2.22"]
pub type GThreadedSocketService = _GThreadedSocketService;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnection {
    _unused: [u8; 0],
}
pub type GDtlsConnection = _GDtlsConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnection {
    _unused: [u8; 0],
}
pub type GDtlsClientConnection = _GDtlsClientConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnection {
    _unused: [u8; 0],
}
pub type GDtlsServerConnection = _GDtlsServerConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIcon {
    _unused: [u8; 0],
}
pub type GThemedIcon = _GThemedIcon;
pub type GTlsCertificate = _GTlsCertificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnection {
    _unused: [u8; 0],
}
pub type GTlsClientConnection = _GTlsClientConnection;
pub type GTlsConnection = _GTlsConnection;
pub type GTlsDatabase = _GTlsDatabase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabase {
    _unused: [u8; 0],
}
pub type GTlsFileDatabase = _GTlsFileDatabase;
pub type GTlsInteraction = _GTlsInteraction;
pub type GTlsPassword = _GTlsPassword;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnection {
    _unused: [u8; 0],
}
pub type GTlsServerConnection = _GTlsServerConnection;
pub type GVfs = _GVfs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolver {
    _unused: [u8; 0],
}
#[doc = " GProxyResolver:\n\n A helper class to enumerate proxies base on URI.\n\n Since: 2.26"]
pub type GProxyResolver = _GProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxy {
    _unused: [u8; 0],
}
pub type GProxy = _GProxy;
pub type GProxyAddress = _GProxyAddress;
pub type GProxyAddressEnumerator = _GProxyAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolume {
    _unused: [u8; 0],
}
#[doc = " GVolume:\n\n Opaque mountable volume object."]
pub type GVolume = _GVolume;
pub type GVolumeMonitor = _GVolumeMonitor;
#[doc = " GAsyncReadyCallback:\n @source_object: (nullable): the object the asynchronous operation was started with.\n @res: a #GAsyncResult.\n @data: user data passed to the callback.\n\n Type definition for a function that will be called back when an asynchronous\n operation within GIO has been completed. #GAsyncReadyCallback\n callbacks from #GTask are guaranteed to be invoked in a later\n iteration of the\n [thread-default main context][g-main-context-push-thread-default]\n where the #GTask was created. All other users of\n #GAsyncReadyCallback must likewise call it asynchronously in a\n later iteration of the main context.\n\n The asynchronous operation is guaranteed to have held a reference to\n @source_object from the time when the `*_async()` function was called, until\n after this callback returns."]
pub type GAsyncReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(source_object: *mut GObject, res: *mut GAsyncResult, data: gpointer),
>;
#[doc = " GFileProgressCallback:\n @current_num_bytes: the current number of bytes in the operation.\n @total_num_bytes: the total number of bytes in the operation.\n @data: user data passed to the callback.\n\n When doing file operations that may take a while, such as moving\n a file or copying a file, a progress callback is used to pass how\n far along that operation is to the application."]
pub type GFileProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(current_num_bytes: goffset, total_num_bytes: goffset, data: gpointer),
>;
#[doc = " GFileReadMoreCallback:\n @file_contents: the data as currently read.\n @file_size: the size of the data currently read.\n @callback_data: data passed to the callback.\n\n When loading the partial contents of a file with g_file_load_partial_contents_async(),\n it may become necessary to determine if any more data from the file should be loaded.\n A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data\n should be read, or %FALSE otherwise.\n\n Returns: %TRUE if more data should be read back. %FALSE otherwise."]
pub type GFileReadMoreCallback = ::std::option::Option<
    unsafe extern "C" fn(
        file_contents: *const ::std::os::raw::c_char,
        file_size: goffset,
        callback_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GFileMeasureProgressCallback:\n @reporting: %TRUE if more reports will come\n @current_size: the current cumulative size measurement\n @num_dirs: the number of directories visited so far\n @num_files: the number of non-directory files encountered\n @data: the data passed to the original request for this callback\n\n This callback type is used by g_file_measure_disk_usage() to make\n periodic progress reports when measuring the amount of disk spaced\n used by a directory.\n\n These calls are made on a best-effort basis and not all types of\n #GFile will support them.  At the minimum, however, one call will\n always be made immediately.\n\n In the case that there is no support, @reporting will be set to\n %FALSE (and the other values undefined) and no further calls will be\n made.  Otherwise, the @reporting will be %TRUE and the other values\n all-zeros during the first (immediate) call.  In this way, you can\n know which type of progress UI to show without a delay.\n\n For g_file_measure_disk_usage() the callback is made directly.  For\n g_file_measure_disk_usage_async() the callback is made via the\n default main context of the calling thread (ie: the same way that the\n final async result would be reported).\n\n @current_size is in the same units as requested by the operation (see\n %G_FILE_MEASURE_APPARENT_SIZE).\n\n The frequency of the updates is implementation defined, but is\n ideally about once every 200ms.\n\n The last progress callback may or may not be equal to the final\n result.  Always check the async result to get the final value.\n\n Since: 2.38"]
pub type GFileMeasureProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        reporting: gboolean,
        current_size: guint64,
        num_dirs: guint64,
        num_files: guint64,
        data: gpointer,
    ),
>;
#[doc = " GIOSchedulerJobFunc:\n @job: a #GIOSchedulerJob.\n @cancellable: optional #GCancellable object, %NULL to ignore.\n @data: data passed to the callback function\n\n I/O Job function.\n\n Long-running jobs should periodically check the @cancellable\n to see if they have been cancelled.\n\n Returns: %TRUE if this function should be called again to\n    complete the job, %FALSE if the job is complete (or cancelled)"]
pub type GIOSchedulerJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        job: *mut GIOSchedulerJob,
        cancellable: *mut GCancellable,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSimpleAsyncThreadFunc:\n @res: a #GSimpleAsyncResult.\n @object: a #GObject.\n @cancellable: optional #GCancellable object, %NULL to ignore.\n\n Simple thread function that runs an asynchronous operation and\n checks for cancellation."]
pub type GSimpleAsyncThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        res: *mut GSimpleAsyncResult,
        object: *mut GObject,
        cancellable: *mut GCancellable,
    ),
>;
#[doc = " GSocketSourceFunc:\n @socket: the #GSocket\n @condition: the current condition at the source fired.\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_socket_create_source().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.22"]
pub type GSocketSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(socket: *mut GSocket, condition: GIOCondition, data: gpointer) -> gboolean,
>;
#[doc = " GDatagramBasedSourceFunc:\n @datagram_based: the #GDatagramBased\n @condition: the current condition at the source fired\n @data: data passed in by the user\n\n This is the function type of the callback used for the #GSource\n returned by g_datagram_based_create_source().\n\n Returns: %G_SOURCE_REMOVE if the source should be removed,\n   %G_SOURCE_CONTINUE otherwise\n\n Since: 2.48"]
pub type GDatagramBasedSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GInputVector:\n @buffer: Pointer to a buffer where data will be written.\n @size: the available size in @buffer.\n\n Structure used for scatter/gather data input.\n You generally pass in an array of #GInputVectors\n and the operation will store the read data starting in the\n first buffer, switching to the next as needed.\n\n Since: 2.22"]
pub type GInputVector = _GInputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInputVector {
    pub buffer: gpointer,
    pub size: gsize,
}
#[test]
fn bindgen_test_layout__GInputVector() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputVector>(),
        16usize,
        concat!("Size of: ", stringify!(_GInputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputVector),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputVector),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " GInputMessage:\n @address: (optional) (out) (transfer full): return location\n   for a #GSocketAddress, or %NULL\n @vectors: (array length=num_vectors) (out): pointer to an\n   array of input vectors\n @num_vectors: the number of input vectors pointed to by @vectors\n @bytes_received: (out): will be set to the number of bytes that have been\n   received\n @flags: (out): collection of #GSocketMsgFlags for the received message,\n   outputted by the call\n @control_messages: (array length=num_control_messages) (optional)\n   (out) (transfer full): return location for a\n   caller-allocated array of #GSocketControlMessages, or %NULL\n @num_control_messages: (out) (optional): return location for the number of\n   elements in @control_messages\n\n Structure used for scatter/gather data input when receiving multiple\n messages or packets in one go. You generally pass in an array of empty\n #GInputVectors and the operation will use all the buffers as if they\n were one buffer, and will set @bytes_received to the total number of bytes\n received across all #GInputVectors.\n\n This structure closely mirrors `struct mmsghdr` and `struct msghdr` from\n the POSIX sockets API (see `man 2 recvmmsg`).\n\n If @address is non-%NULL then it is set to the source address the message\n was received from, and the caller must free it afterwards.\n\n If @control_messages is non-%NULL then it is set to an array of control\n messages received with the message (if any), and the caller must free it\n afterwards. @num_control_messages is set to the number of elements in\n this array, which may be zero.\n\n Flags relevant to this message will be returned in @flags. For example,\n `MSG_EOR` or `MSG_TRUNC`.\n\n Since: 2.48"]
pub type GInputMessage = _GInputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInputMessage {
    pub address: *mut *mut GSocketAddress,
    pub vectors: *mut GInputVector,
    pub num_vectors: guint,
    pub bytes_received: gsize,
    pub flags: gint,
    pub control_messages: *mut *mut *mut GSocketControlMessage,
    pub num_control_messages: *mut guint,
}
#[test]
fn bindgen_test_layout__GInputMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputMessage>(),
        56usize,
        concat!("Size of: ", stringify!(_GInputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_vectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(num_vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_received) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(bytes_received)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_messages) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(control_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_control_messages) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(num_control_messages)
        )
    );
}
#[doc = " GOutputVector:\n @buffer: Pointer to a buffer of data to read.\n @size: the size of @buffer.\n\n Structure used for scatter/gather data output.\n You generally pass in an array of #GOutputVectors\n and the operation will use all the buffers as if they were\n one buffer.\n\n Since: 2.22"]
pub type GOutputVector = _GOutputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GOutputVector {
    pub buffer: gconstpointer,
    pub size: gsize,
}
#[test]
fn bindgen_test_layout__GOutputVector() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputVector>(),
        16usize,
        concat!("Size of: ", stringify!(_GOutputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputVector),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputVector),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " GOutputMessage:\n @address: (nullable): a #GSocketAddress, or %NULL\n @vectors: pointer to an array of output vectors\n @num_vectors: the number of output vectors pointed to by @vectors.\n @bytes_sent: initialize to 0. Will be set to the number of bytes\n     that have been sent\n @control_messages: (array length=num_control_messages) (nullable): a pointer\n   to an array of #GSocketControlMessages, or %NULL.\n @num_control_messages: number of elements in @control_messages.\n\n Structure used for scatter/gather data output when sending multiple\n messages or packets in one go. You generally pass in an array of\n #GOutputVectors and the operation will use all the buffers as if they\n were one buffer.\n\n If @address is %NULL then the message is sent to the default receiver\n (as previously set by g_socket_connect()).\n\n Since: 2.44"]
pub type GOutputMessage = _GOutputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: guint,
    pub bytes_sent: guint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}
#[test]
fn bindgen_test_layout__GOutputMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputMessage>(),
        40usize,
        concat!("Size of: ", stringify!(_GOutputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_vectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(num_vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_sent) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(bytes_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_messages) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(control_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_control_messages) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(num_control_messages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentials {
    _unused: [u8; 0],
}
pub type GCredentials = _GCredentials;
#[doc = " GUnixCredentialsMessage:\n\n The #GUnixCredentialsMessage structure contains only private data\n and should only be accessed using the provided API.\n\n Since: 2.26"]
pub type GUnixCredentialsMessage = _GUnixCredentialsMessage;
pub type GUnixFDList = _GUnixFDList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMessage {
    _unused: [u8; 0],
}
pub type GDBusMessage = _GDBusMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusConnection {
    _unused: [u8; 0],
}
pub type GDBusConnection = _GDBusConnection;
#[doc = " GDBusProxy:\n\n The #GDBusProxy structure contains only private data and\n should only be accessed using the provided API.\n\n Since: 2.26"]
pub type GDBusProxy = _GDBusProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInvocation {
    _unused: [u8; 0],
}
pub type GDBusMethodInvocation = _GDBusMethodInvocation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusServer {
    _unused: [u8; 0],
}
pub type GDBusServer = _GDBusServer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAuthObserver {
    _unused: [u8; 0],
}
pub type GDBusAuthObserver = _GDBusAuthObserver;
#[doc = " GDBusErrorEntry:\n @error_code: An error code.\n @dbus_error_name: The D-Bus error name to associate with @error_code.\n\n Struct used in g_dbus_error_register_error_domain().\n\n Since: 2.26"]
pub type GDBusErrorEntry = _GDBusErrorEntry;
#[doc = " GDBusInterfaceVTable:\n @method_call: Function for handling incoming method calls.\n @get_property: Function for getting a property.\n @set_property: Function for setting a property.\n\n Virtual table for handling properties and method calls for a D-Bus\n interface.\n\n Since 2.38, if you want to handle getting/setting D-Bus properties\n asynchronously, give %NULL as your get_property() or set_property()\n function. The D-Bus call will be directed to your @method_call function,\n with the provided @interface_name set to \"org.freedesktop.DBus.Properties\".\n\n Ownership of the #GDBusMethodInvocation object passed to the\n method_call() function is transferred to your handler; you must\n call one of the methods of #GDBusMethodInvocation to return a reply\n (possibly empty), or an error. These functions also take ownership\n of the passed-in invocation object, so unless the invocation\n object has otherwise been referenced, it will be then be freed.\n Calling one of these functions may be done within your\n method_call() implementation but it also can be done at a later\n point to handle the method asynchronously.\n\n The usual checks on the validity of the calls is performed. For\n `Get` calls, an error is automatically returned if the property does\n not exist or the permissions do not allow access. The same checks are\n performed for `Set` calls, and the provided value is also checked for\n being the correct type.\n\n For both `Get` and `Set` calls, the #GDBusMethodInvocation\n passed to the @method_call handler can be queried with\n g_dbus_method_invocation_get_property_info() to get a pointer\n to the #GDBusPropertyInfo of the property.\n\n If you have readable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @get_property()\n function or provide implementations of both the `Get` and `GetAll`\n methods on org.freedesktop.DBus.Properties interface in your @method_call\n function. Note that the required return type of the `Get` call is\n `(v)`, not the type of the property. `GetAll` expects a return value\n of type `a{sv}`.\n\n If you have writable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @set_property()\n function or provide an implementation of the `Set` call. If implementing\n the call, you must return the value of type %G_VARIANT_TYPE_UNIT.\n\n Since: 2.26"]
pub type GDBusInterfaceVTable = _GDBusInterfaceVTable;
#[doc = " GDBusSubtreeVTable:\n @enumerate: Function for enumerating child nodes.\n @introspect: Function for introspecting a child node.\n @dispatch: Function for dispatching a remote call on a child node.\n\n Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().\n\n Since: 2.26"]
pub type GDBusSubtreeVTable = _GDBusSubtreeVTable;
#[doc = " GDBusAnnotationInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @key: The name of the annotation, e.g. \"org.freedesktop.DBus.Deprecated\".\n @value: The value of the annotation.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an annotation.\n\n Since: 2.26"]
pub type GDBusAnnotationInfo = _GDBusAnnotationInfo;
#[doc = " GDBusArgInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: Name of the argument, e.g. @unix_user_id.\n @signature: D-Bus signature of the argument (a single complete type).\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an argument for a method or a signal.\n\n Since: 2.26"]
pub type GDBusArgInfo = _GDBusArgInfo;
#[doc = " GDBusMethodInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus method, e.g. @RequestName.\n @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.\n @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a method on an D-Bus interface.\n\n Since: 2.26"]
pub type GDBusMethodInfo = _GDBusMethodInfo;
#[doc = " GDBusSignalInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus signal, e.g. \"NameOwnerChanged\".\n @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a signal on a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusSignalInfo = _GDBusSignalInfo;
#[doc = " GDBusPropertyInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus property, e.g. \"SupportedFilesystems\".\n @signature: The D-Bus signature of the property (a single complete type).\n @flags: Access control flags for the property.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus property on a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusPropertyInfo = _GDBusPropertyInfo;
#[doc = " GDBusInterfaceInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus interface, e.g. \"org.freedesktop.DBus.Properties\".\n @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.\n @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.\n @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusInterfaceInfo = _GDBusInterfaceInfo;
#[doc = " GDBusNodeInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.\n @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.\n @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about nodes in a remote object hierarchy.\n\n Since: 2.26"]
pub type GDBusNodeInfo = _GDBusNodeInfo;
#[doc = " GCancellableSourceFunc:\n @cancellable: the #GCancellable\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_cancellable_source_new().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.28"]
pub type GCancellableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(cancellable: *mut GCancellable, data: gpointer) -> gboolean,
>;
#[doc = " GPollableSourceFunc:\n @pollable_stream: the #GPollableInputStream or #GPollableOutputStream\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_pollable_input_stream_create_source() and\n g_pollable_output_stream_create_source().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.28"]
pub type GPollableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(pollable_stream: *mut GObject, data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterface {
    _unused: [u8; 0],
}
pub type GDBusInterface = _GDBusInterface;
#[doc = " GDBusInterfaceSkeleton:\n\n The #GDBusInterfaceSkeleton structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObject {
    _unused: [u8; 0],
}
pub type GDBusObject = _GDBusObject;
#[doc = " GDBusObjectSkeleton:\n\n The #GDBusObjectSkeleton structure contains private data and should only be\n accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectSkeleton = _GDBusObjectSkeleton;
#[doc = " GDBusObjectProxy:\n\n The #GDBusObjectProxy structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectProxy = _GDBusObjectProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManager {
    _unused: [u8; 0],
}
pub type GDBusObjectManager = _GDBusObjectManager;
#[doc = " GDBusObjectManagerClient:\n\n The #GDBusObjectManagerClient structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectManagerClient = _GDBusObjectManagerClient;
#[doc = " GDBusObjectManagerServer:\n\n The #GDBusObjectManagerServer structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectManagerServer = _GDBusObjectManagerServer;
#[doc = " GDBusProxyTypeFunc:\n @manager: A #GDBusObjectManagerClient.\n @object_path: The object path of the remote object.\n @interface_name: (nullable): The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.\n @data: data passed in by the user.\n\n Function signature for a function used to determine the #GType to\n use for an interface proxy (if @interface_name is not %NULL) or\n object proxy (if @interface_name is %NULL).\n\n This function is called in the\n [thread-default main loop][g-main-context-push-thread-default]\n that @manager was constructed in.\n\n Returns: A #GType to use for the remote object. The returned type\n   must be a #GDBusProxy or #GDBusObjectProxy -derived\n   type.\n\n Since: 2.30"]
pub type GDBusProxyTypeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        manager: *mut GDBusObjectManagerClient,
        object_path: *const gchar,
        interface_name: *const gchar,
        data: gpointer,
    ) -> GType,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTestDBus {
    _unused: [u8; 0],
}
pub type GTestDBus = _GTestDBus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocess {
    _unused: [u8; 0],
}
#[doc = " GSubprocess:\n\n A child process.\n\n Since: 2.40"]
pub type GSubprocess = _GSubprocess;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocessLauncher {
    _unused: [u8; 0],
}
#[doc = " GSubprocessLauncher:\n\n Options for launching a child process.\n\n Since: 2.40"]
pub type GSubprocessLauncher = _GSubprocessLauncher;
pub type GActionInterface = _GActionInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GActionInterface {
    pub g_iface: GTypeInterface,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const gchar>,
    pub get_parameter_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_hint:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub get_enabled: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> gboolean>,
    pub get_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub change_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, value: *mut GVariant)>,
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, parameter: *mut GVariant)>,
}
#[test]
fn bindgen_test_layout__GActionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionInterface>(),
        80usize,
        concat!("Size of: ", stringify!(_GActionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parameter_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_parameter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state_hint) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_enabled) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(change_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(activate)
        )
    );
}
extern "C" {
    pub fn g_action_get_type() -> GType;
}
extern "C" {
    pub fn g_action_get_name(action: *mut GAction) -> *const gchar;
}
extern "C" {
    pub fn g_action_get_parameter_type(action: *mut GAction) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_get_state_type(action: *mut GAction) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
}
extern "C" {
    pub fn g_action_get_state(action: *mut GAction) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_change_state(action: *mut GAction, value: *mut GVariant);
}
extern "C" {
    pub fn g_action_activate(action: *mut GAction, parameter: *mut GVariant);
}
extern "C" {
    pub fn g_action_name_is_valid(action_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_action_parse_detailed_name(
        detailed_name: *const gchar,
        action_name: *mut *mut gchar,
        target_value: *mut *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_action_print_detailed_name(
        action_name: *const gchar,
        target_value: *mut GVariant,
    ) -> *mut gchar;
}
pub type GActionGroupInterface = _GActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub has_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> gboolean,
    >,
    pub list_actions: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup) -> *mut *mut gchar,
    >,
    pub get_action_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> gboolean,
    >,
    pub get_action_parameter_type: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *const GVariantType,
    >,
    pub get_action_state_type: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *const GVariantType,
    >,
    pub get_action_state_hint: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *mut GVariant,
    >,
    pub get_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *mut GVariant,
    >,
    pub change_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
        ),
    >,
    pub activate_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
        ),
    >,
    pub action_added: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_removed: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_enabled_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: gboolean,
        ),
    >,
    pub action_state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            state: *mut GVariant,
        ),
    >,
    pub query_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: *mut gboolean,
            parameter_type: *mut *const GVariantType,
            state_type: *mut *const GVariantType,
            state_hint: *mut *mut GVariant,
            state: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GActionGroupInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionGroupInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionGroupInterface>(),
        128usize,
        concat!("Size of: ", stringify!(_GActionGroupInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionGroupInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionGroupInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_action) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(has_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_actions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(list_actions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_enabled) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_parameter_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_parameter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_state_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_state_hint) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_action_state) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(change_action_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate_action) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(activate_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_added) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_removed) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_enabled_changed) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_enabled_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_state_changed) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_state_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_action) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(query_action)
        )
    );
}
extern "C" {
    pub fn g_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_action_group_has_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_action_group_get_action_parameter_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_group_get_action_state_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_group_get_action_state_hint(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_group_get_action_enabled(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_action_group_get_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_group_change_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_action_group_activate_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
    );
}
extern "C" {
    pub fn g_action_group_action_added(action_group: *mut GActionGroup, action_name: *const gchar);
}
extern "C" {
    pub fn g_action_group_action_removed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    );
}
extern "C" {
    pub fn g_action_group_action_enabled_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: gboolean,
    );
}
extern "C" {
    pub fn g_action_group_action_state_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        state: *mut GVariant,
    );
}
extern "C" {
    pub fn g_action_group_query_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: *mut gboolean,
        parameter_type: *mut *const GVariantType,
        state_type: *mut *const GVariantType,
        state_hint: *mut *mut GVariant,
        state: *mut *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_export_action_group(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        action_group: *mut GActionGroup,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unexport_action_group(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
pub type GActionMapInterface = _GActionMapInterface;
pub type GActionEntry = _GActionEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GActionMapInterface {
    pub g_iface: GTypeInterface,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_map: *mut GActionMap,
            action_name: *const gchar,
        ) -> *mut GAction,
    >,
    pub add_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action: *mut GAction),
    >,
    pub remove_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action_name: *const gchar),
    >,
}
#[test]
fn bindgen_test_layout__GActionMapInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionMapInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionMapInterface>(),
        40usize,
        concat!("Size of: ", stringify!(_GActionMapInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionMapInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionMapInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_action) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(lookup_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_action) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(add_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_action) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(remove_action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GActionEntry {
    pub name: *const gchar,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut GSimpleAction,
            parameter: *mut GVariant,
            user_data: gpointer,
        ),
    >,
    pub parameter_type: *const gchar,
    pub state: *const gchar,
    pub change_state: ::std::option::Option<
        unsafe extern "C" fn(action: *mut GSimpleAction, value: *mut GVariant, user_data: gpointer),
    >,
    pub padding: [gsize; 3usize],
}
#[test]
fn bindgen_test_layout__GActionEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionEntry>(),
        64usize,
        concat!("Size of: ", stringify!(_GActionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(parameter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(change_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_action_map_get_type() -> GType;
}
extern "C" {
    pub fn g_action_map_lookup_action(
        action_map: *mut GActionMap,
        action_name: *const gchar,
    ) -> *mut GAction;
}
extern "C" {
    pub fn g_action_map_add_action(action_map: *mut GActionMap, action: *mut GAction);
}
extern "C" {
    pub fn g_action_map_remove_action(action_map: *mut GActionMap, action_name: *const gchar);
}
extern "C" {
    pub fn g_action_map_add_action_entries(
        action_map: *mut GActionMap,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_action_map_remove_action_entries(
        action_map: *mut GActionMap,
        entries: *const GActionEntry,
        n_entries: gint,
    );
}
pub type GAppLaunchContextClass = _GAppLaunchContextClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextPrivate {
    _unused: [u8; 0],
}
pub type GAppLaunchContextPrivate = _GAppLaunchContextPrivate;
#[doc = " GAppInfoIface:\n @g_iface: The parent interface.\n @dup: Copies a #GAppInfo.\n @equal: Checks two #GAppInfos for equality.\n @get_id: Gets a string identifier for a #GAppInfo.\n @get_name: Gets the name of the application for a #GAppInfo.\n @get_description: Gets a short description for the application described by the #GAppInfo.\n @get_executable: Gets the executable name for the #GAppInfo.\n @get_icon: Gets the #GIcon for the #GAppInfo.\n @launch: Launches an application specified by the #GAppInfo.\n @supports_uris: Indicates whether the application specified supports launching URIs.\n @supports_files: Indicates whether the application specified accepts filename arguments.\n @launch_uris: Launches an application with a list of URIs.\n @should_show: Returns whether an application should be shown (e.g. when getting a list of installed applications).\n [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).\n @set_as_default_for_type: Sets an application as default for a given content type.\n @set_as_default_for_extension: Sets an application as default for a given file extension.\n @add_supports_type: Adds to the #GAppInfo information about supported file types.\n @can_remove_supports_type: Checks for support for removing supported file types from a #GAppInfo.\n @remove_supports_type: Removes a supported application type from a #GAppInfo.\n @can_delete: Checks if a #GAppInfo can be deleted. Since 2.20\n @do_delete: Deletes a #GAppInfo. Since 2.20\n @get_commandline: Gets the commandline for the #GAppInfo. Since 2.20\n @get_display_name: Gets the display name for the #GAppInfo. Since 2.24\n @set_as_last_used_for_type: Sets the application as the last used. See g_app_info_set_as_last_used_for_type().\n @get_supported_types: Retrieves the list of content types that @app_info claims to support.\n @launch_uris_async: Asynchronously launches an application with a list of URIs. (Since: 2.60)\n @launch_uris_finish: Finishes an operation started with @launch_uris_async. (Since: 2.60)\n\n Application Information interface, for operating system portability."]
pub type GAppInfoIface = _GAppInfoIface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GAppInfoIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GAppInfo>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean,
    >,
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_executable: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GIcon>,
    pub launch: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            files: *mut GList,
            context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_uris:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub supports_files:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub launch_uris: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub should_show:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub set_as_default_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_as_default_for_extension: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            extension: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub add_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_remove_supports_type:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub remove_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub do_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub get_commandline: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub set_as_last_used_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_supported_types: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut *const ::std::os::raw::c_char,
    >,
    pub launch_uris_async: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            context: *mut GAppLaunchContext,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub launch_uris_finish: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAppInfoIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GAppInfoIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAppInfoIface>(),
        216usize,
        concat!("Size of: ", stringify!(_GAppInfoIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppInfoIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppInfoIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_description) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_executable) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_executable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_uris) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(supports_uris)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_files) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(supports_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_uris) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).should_show) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(should_show)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_as_default_for_type) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_default_for_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).set_as_default_for_extension) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_default_for_extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_supports_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(add_supports_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_remove_supports_type) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(can_remove_supports_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_supports_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(remove_supports_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_delete) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(can_delete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_delete) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(do_delete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_commandline) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_commandline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_display_name) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_as_last_used_for_type) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_last_used_for_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_types) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_supported_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_uris_async) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_uris_finish) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris_finish)
        )
    );
}
extern "C" {
    pub fn g_app_info_get_type() -> GType;
}
extern "C" {
    pub fn g_app_info_create_from_commandline(
        commandline: *const ::std::os::raw::c_char,
        application_name: *const ::std::os::raw::c_char,
        flags: GAppInfoCreateFlags,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
}
extern "C" {
    pub fn g_app_info_launch(
        appinfo: *mut GAppInfo,
        files: *mut GList,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_launch_uris(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_launch_uris_async(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_launch_uris_finish(
        appinfo: *mut GAppInfo,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_set_as_default_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_set_as_default_for_extension(
        appinfo: *mut GAppInfo,
        extension: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_add_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_remove_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_get_supported_types(
        appinfo: *mut GAppInfo,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_set_as_last_used_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_get_all() -> *mut GList;
}
extern "C" {
    pub fn g_app_info_get_all_for_type(content_type: *const ::std::os::raw::c_char) -> *mut GList;
}
extern "C" {
    pub fn g_app_info_get_recommended_for_type(content_type: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn g_app_info_get_fallback_for_type(content_type: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn g_app_info_reset_type_associations(content_type: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_app_info_get_default_for_type(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_get_default_for_type_async(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_get_default_for_type_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme(
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme_async(
        uri_scheme: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_launch_default_for_uri(
        uri: *const ::std::os::raw::c_char,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_launch_default_for_uri_async(
        uri: *const ::std::os::raw::c_char,
        context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_launch_default_for_uri_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GAppLaunchContext:\n\n Integrating the launch with the launching application. This is used to\n handle for instance startup notification and launching the new application\n on the same screen as the launching window."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GAppLaunchContext {
    pub parent_instance: GObject,
    pub priv_: *mut GAppLaunchContextPrivate,
}
#[test]
fn bindgen_test_layout__GAppLaunchContext() {
    const UNINIT: ::std::mem::MaybeUninit<_GAppLaunchContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAppLaunchContext>(),
        32usize,
        concat!("Size of: ", stringify!(_GAppLaunchContext))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppLaunchContext>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppLaunchContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContext),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContext),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GAppLaunchContextClass {
    pub parent_class: GObjectClass,
    pub get_display: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub get_startup_notify_id: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub launch_failed: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            startup_notify_id: *const ::std::os::raw::c_char,
        ),
    >,
    pub launched: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub launch_started: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GAppLaunchContextClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GAppLaunchContextClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAppLaunchContextClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GAppLaunchContextClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppLaunchContextClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppLaunchContextClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_display) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(get_display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_startup_notify_id) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(get_startup_notify_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_failed) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launch_failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launched) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_started) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launch_started)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_app_launch_context_get_type() -> GType;
}
extern "C" {
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
}
extern "C" {
    pub fn g_app_launch_context_setenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_app_launch_context_unsetenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_app_launch_context_get_environment(
        context: *mut GAppLaunchContext,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_launch_context_get_display(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_launch_context_get_startup_notify_id(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_launch_context_launch_failed(
        context: *mut GAppLaunchContext,
        startup_notify_id: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoMonitor {
    _unused: [u8; 0],
}
pub type GAppInfoMonitor = _GAppInfoMonitor;
extern "C" {
    pub fn g_app_info_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationPrivate {
    _unused: [u8; 0],
}
pub type GApplicationPrivate = _GApplicationPrivate;
pub type GApplicationClass = _GApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GApplication {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationPrivate,
}
#[test]
fn bindgen_test_layout__GApplication() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplication> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplication>(),
        32usize,
        concat!("Size of: ", stringify!(_GApplication))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplication))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplication),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplication),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GApplicationClass {
    pub parent_class: GObjectClass,
    pub startup: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            files: *mut *mut GFile,
            n_files: gint,
            hint: *const gchar,
        ),
    >,
    pub command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            command_line: *mut GApplicationCommandLine,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " GApplicationClass::local_command_line:\n @application: a #GApplication\n @arguments: (inout) (array zero-terminated=1): array of command line arguments\n @exit_status: (out): exit status to fill after processing the command line.\n\n This virtual function is always invoked in the local instance. It\n gets passed a pointer to a %NULL-terminated copy of @argv and is\n expected to remove arguments that it handled (shifting up remaining\n arguments).\n\n The last argument to local_command_line() is a pointer to the @status\n variable which can used to set the exit status that is returned from\n g_application_run().\n\n See g_application_run() for more details on #GApplication startup.\n\n Returns: %TRUE if the commandline has been completely handled"]
    pub local_command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            arguments: *mut *mut *mut gchar,
            exit_status: *mut ::std::os::raw::c_int,
        ) -> gboolean,
    >,
    pub before_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub after_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub add_platform_data: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, builder: *mut GVariantBuilder),
    >,
    pub quit_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub run_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub dbus_register: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub dbus_unregister: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
        ),
    >,
    pub handle_local_options: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, options: *mut GVariantDict) -> gint,
    >,
    pub name_lost:
        ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication) -> gboolean>,
    pub padding: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__GApplicationClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplicationClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplicationClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GApplicationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startup) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(startup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_line) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(command_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_command_line) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(local_command_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).before_emit) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(before_emit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).after_emit) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(after_emit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_platform_data) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(add_platform_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quit_mainloop) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(quit_mainloop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_mainloop) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(run_mainloop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbus_register) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(dbus_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbus_unregister) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(dbus_unregister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_local_options) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(handle_local_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_lost) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(name_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_application_get_type() -> GType;
}
extern "C" {
    pub fn g_application_id_is_valid(application_id: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_application_new(
        application_id: *const gchar,
        flags: GApplicationFlags,
    ) -> *mut GApplication;
}
extern "C" {
    pub fn g_application_get_application_id(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    pub fn g_application_set_application_id(
        application: *mut GApplication,
        application_id: *const gchar,
    );
}
extern "C" {
    pub fn g_application_get_dbus_connection(
        application: *mut GApplication,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_application_get_dbus_object_path(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    pub fn g_application_get_inactivity_timeout(application: *mut GApplication) -> guint;
}
extern "C" {
    pub fn g_application_set_inactivity_timeout(
        application: *mut GApplication,
        inactivity_timeout: guint,
    );
}
extern "C" {
    pub fn g_application_get_flags(application: *mut GApplication) -> GApplicationFlags;
}
extern "C" {
    pub fn g_application_set_flags(application: *mut GApplication, flags: GApplicationFlags);
}
extern "C" {
    pub fn g_application_get_resource_base_path(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    pub fn g_application_set_resource_base_path(
        application: *mut GApplication,
        resource_path: *const gchar,
    );
}
extern "C" {
    pub fn g_application_set_action_group(
        application: *mut GApplication,
        action_group: *mut GActionGroup,
    );
}
extern "C" {
    pub fn g_application_add_main_option_entries(
        application: *mut GApplication,
        entries: *const GOptionEntry,
    );
}
extern "C" {
    pub fn g_application_add_main_option(
        application: *mut GApplication,
        long_name: *const ::std::os::raw::c_char,
        short_name: ::std::os::raw::c_char,
        flags: GOptionFlags,
        arg: GOptionArg,
        description: *const ::std::os::raw::c_char,
        arg_description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_application_add_option_group(application: *mut GApplication, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_application_set_option_context_parameter_string(
        application: *mut GApplication,
        parameter_string: *const gchar,
    );
}
extern "C" {
    pub fn g_application_set_option_context_summary(
        application: *mut GApplication,
        summary: *const gchar,
    );
}
extern "C" {
    pub fn g_application_set_option_context_description(
        application: *mut GApplication,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_application_get_is_registered(application: *mut GApplication) -> gboolean;
}
extern "C" {
    pub fn g_application_get_is_remote(application: *mut GApplication) -> gboolean;
}
extern "C" {
    pub fn g_application_register(
        application: *mut GApplication,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_application_hold(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_release(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_activate(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_open(
        application: *mut GApplication,
        files: *mut *mut GFile,
        n_files: gint,
        hint: *const gchar,
    );
}
extern "C" {
    pub fn g_application_run(
        application: *mut GApplication,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_application_quit(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_get_default() -> *mut GApplication;
}
extern "C" {
    pub fn g_application_set_default(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_mark_busy(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_unmark_busy(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_get_is_busy(application: *mut GApplication) -> gboolean;
}
extern "C" {
    pub fn g_application_send_notification(
        application: *mut GApplication,
        id: *const gchar,
        notification: *mut GNotification,
    );
}
extern "C" {
    pub fn g_application_withdraw_notification(application: *mut GApplication, id: *const gchar);
}
extern "C" {
    pub fn g_application_bind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
extern "C" {
    pub fn g_application_unbind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLinePrivate {
    _unused: [u8; 0],
}
pub type GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate;
pub type GApplicationCommandLineClass = _GApplicationCommandLineClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GApplicationCommandLine {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationCommandLinePrivate,
}
#[test]
fn bindgen_test_layout__GApplicationCommandLine() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplicationCommandLine> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplicationCommandLine>(),
        32usize,
        concat!("Size of: ", stringify!(_GApplicationCommandLine))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationCommandLine>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationCommandLine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLine),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLine),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GApplicationCommandLineClass {
    pub parent_class: GObjectClass,
    pub print_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub printerr_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub get_stdin: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine) -> *mut GInputStream,
    >,
    pub padding: [gpointer; 11usize],
}
#[test]
fn bindgen_test_layout__GApplicationCommandLineClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplicationCommandLineClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplicationCommandLineClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GApplicationCommandLineClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationCommandLineClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationCommandLineClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).print_literal) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(print_literal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).printerr_literal) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(printerr_literal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_stdin) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(get_stdin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_application_command_line_get_type() -> GType;
}
extern "C" {
    pub fn g_application_command_line_get_arguments(
        cmdline: *mut GApplicationCommandLine,
        argc: *mut ::std::os::raw::c_int,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_application_command_line_get_options_dict(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_application_command_line_get_stdin(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_application_command_line_get_environ(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const *const gchar;
}
extern "C" {
    pub fn g_application_command_line_getenv(
        cmdline: *mut GApplicationCommandLine,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_application_command_line_get_cwd(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_application_command_line_get_is_remote(
        cmdline: *mut GApplicationCommandLine,
    ) -> gboolean;
}
extern "C" {
    pub fn g_application_command_line_print(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_application_command_line_printerr(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_application_command_line_get_exit_status(
        cmdline: *mut GApplicationCommandLine,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_application_command_line_set_exit_status(
        cmdline: *mut GApplicationCommandLine,
        exit_status: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_application_command_line_get_platform_data(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_application_command_line_create_file_for_arg(
        cmdline: *mut GApplicationCommandLine,
        arg: *const gchar,
    ) -> *mut GFile;
}
#[doc = " GInitable:\n\n Interface for initializable objects.\n\n Since: 2.22"]
pub type GInitableIface = _GInitableIface;
#[doc = " GInitableIface:\n @g_iface: The parent interface.\n @init: Initializes the object.\n\n Provides an interface for initializing object such that initialization\n may fail.\n\n Since: 2.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInitableIface {
    pub g_iface: GTypeInterface,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GInitable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GInitableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GInitableIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInitableIface>(),
        24usize,
        concat!("Size of: ", stringify!(_GInitableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInitableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInitableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInitableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInitableIface),
            "::",
            stringify!(init)
        )
    );
}
extern "C" {
    pub fn g_initable_get_type() -> GType;
}
extern "C" {
    pub fn g_initable_init(
        initable: *mut GInitable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_initable_new(
        object_type: GType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        first_property_name: *const gchar,
        ...
    ) -> gpointer;
}
extern "C" {
    pub fn g_initable_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gpointer;
}
extern "C" {
    pub fn g_initable_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: va_list,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
#[doc = " GAsyncInitable:\n\n Interface for asynchronously initializable objects.\n\n Since: 2.22"]
pub type GAsyncInitableIface = _GAsyncInitableIface;
#[doc = " GAsyncInitableIface:\n @g_iface: The parent interface.\n @init_async: Starts initialization of the object.\n @init_finish: Finishes initialization of the object.\n\n Provides an interface for asynchronous initializing object such that\n initialization may fail.\n\n Since: 2.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GAsyncInitableIface {
    pub g_iface: GTypeInterface,
    pub init_async: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub init_finish: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAsyncInitableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GAsyncInitableIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAsyncInitableIface>(),
        32usize,
        concat!("Size of: ", stringify!(_GAsyncInitableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAsyncInitableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAsyncInitableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_async) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(init_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_finish) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(init_finish)
        )
    );
}
extern "C" {
    pub fn g_async_initable_get_type() -> GType;
}
extern "C" {
    pub fn g_async_initable_init_async(
        initable: *mut GAsyncInitable,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_initable_init_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_async_initable_new_async(
        object_type: GType,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        first_property_name: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_async_initable_newv_async(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_initable_new_valist_async(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: va_list,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_initable_new_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
#[doc = " GAsyncResult:\n\n Holds results information for an asynchronous operation,\n usually passed directly to an asynchronous _finish() operation."]
pub type GAsyncResultIface = _GAsyncResultIface;
#[doc = " GAsyncResultIface:\n @g_iface: The parent interface.\n @get_user_data: Gets the user data passed to the callback.\n @get_source_object: Gets the source object that issued the asynchronous operation.\n @is_tagged: Checks if a result is tagged with a particular source.\n\n Interface definition for #GAsyncResult."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GAsyncResultIface {
    pub g_iface: GTypeInterface,
    pub get_user_data:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> gpointer>,
    pub get_source_object:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> *mut GObject>,
    pub is_tagged: ::std::option::Option<
        unsafe extern "C" fn(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAsyncResultIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GAsyncResultIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAsyncResultIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GAsyncResultIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAsyncResultIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAsyncResultIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_user_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(get_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_source_object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(get_source_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_tagged) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(is_tagged)
        )
    );
}
extern "C" {
    pub fn g_async_result_get_type() -> GType;
}
extern "C" {
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
}
extern "C" {
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult) -> *mut GObject;
}
extern "C" {
    pub fn g_async_result_legacy_propagate_error(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean;
}
#[doc = " GInputStream:\n\n Base class for streaming input operations."]
pub type GInputStreamClass = _GInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GInputStreamPrivate = _GInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInputStreamClass {
    pub parent_class: GObjectClass,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub skip_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputStreamClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_async) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_finish) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_async) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_finish) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_input_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_read_all(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        bytes_read: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_read_bytes(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_input_stream_skip(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_close(
        stream: *mut GInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_read_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_read_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_read_all_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_read_all_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_read_bytes_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_read_bytes_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_input_stream_skip_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_skip_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_close_async(
        stream: *mut GInputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_close_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_set_pending(
        stream: *mut GInputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
}
#[doc = " GFilterInputStream:\n\n A base class for all input streams that work on an underlying stream."]
pub type GFilterInputStreamClass = _GFilterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}
#[test]
fn bindgen_test_layout__GFilterInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFilterInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStream),
            "::",
            stringify!(base_stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilterInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterInputStreamClass>(),
        272usize,
        concat!("Size of: ", stringify!(_GFilterInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_filter_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_filter_input_stream_get_base_stream(
        stream: *mut GFilterInputStream,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_filter_input_stream_get_close_base_stream(stream: *mut GFilterInputStream)
        -> gboolean;
}
extern "C" {
    pub fn g_filter_input_stream_set_close_base_stream(
        stream: *mut GFilterInputStream,
        close_base: gboolean,
    );
}
#[doc = " GBufferedInputStream:\n\n Implements #GFilterInputStream with a sized input buffer."]
pub type GBufferedInputStreamClass = _GBufferedInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GBufferedInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GBufferedInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedInputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedInputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GBufferedInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub fill_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub fill_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GBufferedInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedInputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GBufferedInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_async) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_finish) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_buffered_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream) -> *mut GInputStream;
}
extern "C" {
    pub fn g_buffered_input_stream_new_sized(
        base_stream: *mut GInputStream,
        size: gsize,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_buffered_input_stream_get_buffer_size(stream: *mut GBufferedInputStream) -> gsize;
}
extern "C" {
    pub fn g_buffered_input_stream_set_buffer_size(stream: *mut GBufferedInputStream, size: gsize);
}
extern "C" {
    pub fn g_buffered_input_stream_get_available(stream: *mut GBufferedInputStream) -> gsize;
}
extern "C" {
    pub fn g_buffered_input_stream_peek(
        stream: *mut GBufferedInputStream,
        buffer: *mut ::std::os::raw::c_void,
        offset: gsize,
        count: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_buffered_input_stream_peek_buffer(
        stream: *mut GBufferedInputStream,
        count: *mut gsize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn g_buffered_input_stream_fill(
        stream: *mut GBufferedInputStream,
        count: gssize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_buffered_input_stream_fill_async(
        stream: *mut GBufferedInputStream,
        count: gssize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_buffered_input_stream_fill_finish(
        stream: *mut GBufferedInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_buffered_input_stream_read_byte(
        stream: *mut GBufferedInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> ::std::os::raw::c_int;
}
#[doc = " GOutputStream:\n\n Base class for writing output.\n\n All classes derived from GOutputStream should implement synchronous\n writing, splicing, flushing and closing streams, but may implement\n asynchronous versions."]
pub type GOutputStreamClass = _GOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GOutputStreamPrivate = _GOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GOutputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GOutputStreamClass {
    pub parent_class: GObjectClass,
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub write_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub write_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub splice_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub flush_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub writev_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            bytes_written: *mut gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub writev_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub writev_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputStreamClass>(),
        296usize,
        concat!("Size of: ", stringify!(_GOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_fn) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splice) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splice_async) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splice_finish) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_async) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_finish) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_fn) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(writev_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_async) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(writev_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_finish) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(writev_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
}
extern "C" {
    pub fn g_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_output_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev(
        stream: *mut GOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev_all(
        stream: *mut GOutputStream,
        vectors: *mut GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_printf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_vprintf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        args: va_list,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_write_bytes(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_splice(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_flush(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_close(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_write_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_write_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_write_all_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_write_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev_async(
        stream: *mut GOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_writev_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev_all_async(
        stream: *mut GOutputStream,
        vectors: *mut GOutputVector,
        n_vectors: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_writev_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_write_bytes_async(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_write_bytes_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_splice_async(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_splice_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_flush_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_flush_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_close_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_close_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_set_pending(
        stream: *mut GOutputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
}
#[doc = " GFilterOutputStream:\n\n A base class for all output streams that work on an underlying stream."]
pub type GFilterOutputStreamClass = _GFilterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}
#[test]
fn bindgen_test_layout__GFilterOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFilterOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStream),
            "::",
            stringify!(base_stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilterOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterOutputStreamClass>(),
        320usize,
        concat!("Size of: ", stringify!(_GFilterOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_filter_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_filter_output_stream_get_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_filter_output_stream_get_close_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> gboolean;
}
extern "C" {
    pub fn g_filter_output_stream_set_close_base_stream(
        stream: *mut GFilterOutputStream,
        close_base: gboolean,
    );
}
#[doc = " GBufferedOutputStream:\n\n An implementation of #GFilterOutputStream with a sized buffer."]
pub type GBufferedOutputStreamClass = _GBufferedOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GBufferedOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GBufferedOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedOutputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GBufferedOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GBufferedOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedOutputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GBufferedOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
}
extern "C" {
    pub fn g_buffered_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_buffered_output_stream_new_sized(
        base_stream: *mut GOutputStream,
        size: gsize,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_buffered_output_stream_get_buffer_size(stream: *mut GBufferedOutputStream) -> gsize;
}
extern "C" {
    pub fn g_buffered_output_stream_set_buffer_size(
        stream: *mut GBufferedOutputStream,
        size: gsize,
    );
}
extern "C" {
    pub fn g_buffered_output_stream_get_auto_grow(stream: *mut GBufferedOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_buffered_output_stream_set_auto_grow(
        stream: *mut GBufferedOutputStream,
        auto_grow: gboolean,
    );
}
extern "C" {
    #[doc = " GBytesIcon:\n\n Gets an icon for a #GBytes. Implements #GLoadableIcon."]
    pub fn g_bytes_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_bytes_icon_new(bytes: *mut GBytes) -> *mut GIcon;
}
extern "C" {
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut GBytes;
}
#[doc = " GCancellable:\n\n Allows actions to be cancelled."]
pub type GCancellableClass = _GCancellableClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellablePrivate {
    _unused: [u8; 0],
}
pub type GCancellablePrivate = _GCancellablePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GCancellable {
    pub parent_instance: GObject,
    pub priv_: *mut GCancellablePrivate,
}
#[test]
fn bindgen_test_layout__GCancellable() {
    const UNINIT: ::std::mem::MaybeUninit<_GCancellable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCancellable>(),
        32usize,
        concat!("Size of: ", stringify!(_GCancellable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GCancellableClass {
    pub parent_class: GObjectClass,
    pub cancelled: ::std::option::Option<unsafe extern "C" fn(cancellable: *mut GCancellable)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GCancellableClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GCancellableClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCancellableClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GCancellableClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellableClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellableClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancelled) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(cancelled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_cancellable_get_type() -> GType;
}
extern "C" {
    pub fn g_cancellable_new() -> *mut GCancellable;
}
extern "C" {
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable) -> gboolean;
}
extern "C" {
    pub fn g_cancellable_set_error_if_cancelled(
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_cancellable_make_pollfd(
        cancellable: *mut GCancellable,
        pollfd: *mut GPollFD,
    ) -> gboolean;
}
extern "C" {
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable) -> *mut GSource;
}
extern "C" {
    pub fn g_cancellable_get_current() -> *mut GCancellable;
}
extern "C" {
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_connect(
        cancellable: *mut GCancellable,
        callback: GCallback,
        data: gpointer,
        data_destroy_func: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable, handler_id: gulong);
}
extern "C" {
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
}
#[doc = " GConverter:\n\n Seek object for streaming operations.\n\n Since: 2.24"]
pub type GConverterIface = _GConverterIface;
#[doc = " GConverterIface:\n @g_iface: The parent interface.\n @convert: Converts data.\n @reset: Reverts the internal state of the converter to its initial state.\n\n Provides an interface for converting data from one type\n to another type. The conversion can be stateful\n and may fail at any place.\n\n Since: 2.24"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GConverterIface {
    pub g_iface: GTypeInterface,
    pub convert: ::std::option::Option<
        unsafe extern "C" fn(
            converter: *mut GConverter,
            inbuf: *const ::std::os::raw::c_void,
            inbuf_size: gsize,
            outbuf: *mut ::std::os::raw::c_void,
            outbuf_size: gsize,
            flags: GConverterFlags,
            bytes_read: *mut gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GConverterResult,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(converter: *mut GConverter)>,
}
#[test]
fn bindgen_test_layout__GConverterIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterIface>(),
        32usize,
        concat!("Size of: ", stringify!(_GConverterIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).convert) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(convert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(reset)
        )
    );
}
extern "C" {
    pub fn g_converter_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_convert(
        converter: *mut GConverter,
        inbuf: *const ::std::os::raw::c_void,
        inbuf_size: gsize,
        outbuf: *mut ::std::os::raw::c_void,
        outbuf_size: gsize,
        flags: GConverterFlags,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GConverterResult;
}
extern "C" {
    pub fn g_converter_reset(converter: *mut GConverter);
}
pub type GCharsetConverterClass = _GCharsetConverterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GCharsetConverterClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GCharsetConverterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GCharsetConverterClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCharsetConverterClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GCharsetConverterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCharsetConverterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCharsetConverterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCharsetConverterClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_charset_converter_get_type() -> GType;
}
extern "C" {
    pub fn g_charset_converter_new(
        to_charset: *const gchar,
        from_charset: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GCharsetConverter;
}
extern "C" {
    pub fn g_charset_converter_set_use_fallback(
        converter: *mut GCharsetConverter,
        use_fallback: gboolean,
    );
}
extern "C" {
    pub fn g_charset_converter_get_use_fallback(converter: *mut GCharsetConverter) -> gboolean;
}
extern "C" {
    pub fn g_charset_converter_get_num_fallbacks(converter: *mut GCharsetConverter) -> guint;
}
extern "C" {
    pub fn g_content_type_equals(type1: *const gchar, type2: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_is_a(type_: *const gchar, supertype: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_is_mime_type(type_: *const gchar, mime_type: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_is_unknown(type_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_get_description(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_get_mime_type(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_get_icon(type_: *const gchar) -> *mut GIcon;
}
extern "C" {
    pub fn g_content_type_get_symbolic_icon(type_: *const gchar) -> *mut GIcon;
}
extern "C" {
    pub fn g_content_type_get_generic_icon_name(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_can_be_executable(type_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_from_mime_type(mime_type: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_guess(
        filename: *const gchar,
        data: *const guchar,
        data_size: gsize,
        result_uncertain: *mut gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_content_types_get_registered() -> *mut GList;
}
extern "C" {
    pub fn g_content_type_get_mime_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_content_type_set_mime_dirs(dirs: *const *const gchar);
}
#[doc = " GConverterInputStream:\n\n An implementation of #GFilterInputStream that allows data\n conversion."]
pub type GConverterInputStreamClass = _GConverterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterInputStreamPrivate = _GConverterInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GConverterInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GConverterInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterInputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterInputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GConverterInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GConverterInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterInputStreamClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GConverterInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_converter_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_input_stream_new(
        base_stream: *mut GInputStream,
        converter: *mut GConverter,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_converter_input_stream_get_converter(
        converter_stream: *mut GConverterInputStream,
    ) -> *mut GConverter;
}
#[doc = " GConverterOutputStream:\n\n An implementation of #GFilterOutputStream that allows data\n conversion."]
pub type GConverterOutputStreamClass = _GConverterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GConverterOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GConverterOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterOutputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GConverterOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GConverterOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterOutputStreamClass>(),
        360usize,
        concat!("Size of: ", stringify!(_GConverterOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_converter_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_output_stream_new(
        base_stream: *mut GOutputStream,
        converter: *mut GConverter,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_converter_output_stream_get_converter(
        converter_stream: *mut GConverterOutputStream,
    ) -> *mut GConverter;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<accessx_descriptor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad_name_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_name_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad_pad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_pad)
        )
    );
}
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freadlink(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentialsClass {
    _unused: [u8; 0],
}
pub type GCredentialsClass = _GCredentialsClass;
extern "C" {
    pub fn g_credentials_get_type() -> GType;
}
extern "C" {
    pub fn g_credentials_new() -> *mut GCredentials;
}
extern "C" {
    pub fn g_credentials_to_string(credentials: *mut GCredentials) -> *mut gchar;
}
extern "C" {
    pub fn g_credentials_get_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
    ) -> gpointer;
}
extern "C" {
    pub fn g_credentials_set_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
        native: gpointer,
    );
}
extern "C" {
    pub fn g_credentials_is_same_user(
        credentials: *mut GCredentials,
        other_credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_credentials_get_unix_pid(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> pid_t;
}
extern "C" {
    pub fn g_credentials_get_unix_user(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> uid_t;
}
extern "C" {
    pub fn g_credentials_set_unix_user(
        credentials: *mut GCredentials,
        uid: uid_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GDatagramBased:\n\n Interface for socket-like objects with datagram semantics.\n\n Since: 2.48"]
pub type GDatagramBasedInterface = _GDatagramBasedInterface;
#[doc = " GDatagramBasedInterface:\n @g_iface: The parent interface.\n @receive_messages: Virtual method for g_datagram_based_receive_messages().\n @send_messages: Virtual method for g_datagram_based_send_messages().\n @create_source: Virtual method for g_datagram_based_create_source().\n @condition_check: Virtual method for g_datagram_based_condition_check().\n @condition_wait: Virtual method for\n   g_datagram_based_condition_wait().\n\n Provides an interface for socket-like objects which have datagram semantics,\n following the Berkeley sockets API. The interface methods are thin wrappers\n around the corresponding virtual methods, and no pre-processing of inputs is\n implemented  so implementations of this API must handle all functionality\n documented in the interface methods.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDatagramBasedInterface {
    pub g_iface: GTypeInterface,
    pub receive_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GInputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub send_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GOutputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub condition_check: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
        ) -> GIOCondition,
    >,
    pub condition_wait: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GDatagramBasedInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDatagramBasedInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDatagramBasedInterface>(),
        56usize,
        concat!("Size of: ", stringify!(_GDatagramBasedInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDatagramBasedInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDatagramBasedInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_messages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(receive_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_messages) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(send_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).condition_check) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(condition_check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).condition_wait) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(condition_wait)
        )
    );
}
extern "C" {
    pub fn g_datagram_based_get_type() -> GType;
}
extern "C" {
    pub fn g_datagram_based_receive_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_datagram_based_send_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_datagram_based_create_source(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_datagram_based_condition_check(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
    ) -> GIOCondition;
}
extern "C" {
    pub fn g_datagram_based_condition_wait(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GDataInputStream:\n\n An implementation of #GBufferedInputStream that allows for high-level\n data manipulation of arbitrary data (including binary operations)."]
pub type GDataInputStreamClass = _GDataInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataInputStreamPrivate = _GDataInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    pub priv_: *mut GDataInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GDataInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataInputStream>(),
        56usize,
        concat!("Size of: ", stringify!(_GDataInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GDataInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataInputStreamClass>(),
        376usize,
        concat!("Size of: ", stringify!(_GDataInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_data_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream) -> *mut GDataInputStream;
}
extern "C" {
    pub fn g_data_input_stream_set_byte_order(
        stream: *mut GDataInputStream,
        order: GDataStreamByteOrder,
    );
}
extern "C" {
    pub fn g_data_input_stream_get_byte_order(
        stream: *mut GDataInputStream,
    ) -> GDataStreamByteOrder;
}
extern "C" {
    pub fn g_data_input_stream_set_newline_type(
        stream: *mut GDataInputStream,
        type_: GDataStreamNewlineType,
    );
}
extern "C" {
    pub fn g_data_input_stream_get_newline_type(
        stream: *mut GDataInputStream,
    ) -> GDataStreamNewlineType;
}
extern "C" {
    pub fn g_data_input_stream_read_byte(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guchar;
}
extern "C" {
    pub fn g_data_input_stream_read_int16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint16;
}
extern "C" {
    pub fn g_data_input_stream_read_uint16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint16;
}
extern "C" {
    pub fn g_data_input_stream_read_int32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint32;
}
extern "C" {
    pub fn g_data_input_stream_read_uint32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint32;
}
extern "C" {
    pub fn g_data_input_stream_read_int64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_data_input_stream_read_uint64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_data_input_stream_read_line(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_line_utf8(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_line_async(
        stream: *mut GDataInputStream,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_data_input_stream_read_line_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_line_finish_utf8(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_until(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_until_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_data_input_stream_read_until_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_upto(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_upto_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_data_input_stream_read_upto_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " GDataOutputStream:\n\n An implementation of #GBufferedOutputStream that allows for high-level\n data manipulation of arbitrary data (including binary operations)."]
pub type GDataOutputStream = _GDataOutputStream;
pub type GDataOutputStreamClass = _GDataOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataOutputStreamPrivate = _GDataOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GDataOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GDataOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GDataOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GDataOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataOutputStreamClass>(),
        360usize,
        concat!("Size of: ", stringify!(_GDataOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_data_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream) -> *mut GDataOutputStream;
}
extern "C" {
    pub fn g_data_output_stream_set_byte_order(
        stream: *mut GDataOutputStream,
        order: GDataStreamByteOrder,
    );
}
extern "C" {
    pub fn g_data_output_stream_get_byte_order(
        stream: *mut GDataOutputStream,
    ) -> GDataStreamByteOrder;
}
extern "C" {
    pub fn g_data_output_stream_put_byte(
        stream: *mut GDataOutputStream,
        data: guchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_int16(
        stream: *mut GDataOutputStream,
        data: gint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_uint16(
        stream: *mut GDataOutputStream,
        data: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_int32(
        stream: *mut GDataOutputStream,
        data: gint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_uint32(
        stream: *mut GDataOutputStream,
        data: guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_int64(
        stream: *mut GDataOutputStream,
        data: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_uint64(
        stream: *mut GDataOutputStream,
        data: guint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_string(
        stream: *mut GDataOutputStream,
        str_: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_action_group_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusActionGroup;
}
extern "C" {
    pub fn g_dbus_address_escape_value(string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_is_address(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_supported_address(string: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_dbus_address_get_stream(
        address: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_address_get_stream_finish(
        res: *mut GAsyncResult,
        out_guid: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_dbus_address_get_stream_sync(
        address: *const gchar,
        out_guid: *mut *mut gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_dbus_address_get_for_bus_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_auth_observer_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
}
extern "C" {
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(
        observer: *mut GDBusAuthObserver,
        stream: *mut GIOStream,
        credentials: *mut GCredentials,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_auth_observer_allow_mechanism(
        observer: *mut GDBusAuthObserver,
        mechanism: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_get(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_bus_get_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_bus_get_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new_sync(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new_for_address(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_new_for_address_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new_for_address_sync(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_start_message_processing(connection: *mut GDBusConnection);
}
extern "C" {
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection) -> *mut GIOStream;
}
extern "C" {
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_connection_get_peer_credentials(
        connection: *mut GDBusConnection,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection) -> guint32;
}
extern "C" {
    pub fn g_dbus_connection_get_exit_on_close(connection: *mut GDBusConnection) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_set_exit_on_close(
        connection: *mut GDBusConnection,
        exit_on_close: gboolean,
    );
}
extern "C" {
    pub fn g_dbus_connection_get_capabilities(
        connection: *mut GDBusConnection,
    ) -> GDBusCapabilityFlags;
}
extern "C" {
    pub fn g_dbus_connection_get_flags(connection: *mut GDBusConnection) -> GDBusConnectionFlags;
}
extern "C" {
    pub fn g_dbus_connection_close(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_close_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_close_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_flush(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_flush_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_flush_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_send_message(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        out_serial: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_send_message_with_reply(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_send_message_with_reply_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_connection_send_message_with_reply_sync(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_connection_emit_signal(
        connection: *mut GDBusConnection,
        destination_bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_call(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_call_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_connection_call_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(
        connection: *mut GDBusConnection,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
#[doc = " GDBusInterfaceMethodCallFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name the method was invoked on.\n @method_name: The name of the method that was invoked.\n @parameters: A #GVariant tuple with parameters.\n @invocation: (transfer full): A #GDBusMethodInvocation object that must be used to return a value or error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @method_call function in #GDBusInterfaceVTable.\n\n Since: 2.26"]
pub type GDBusInterfaceMethodCallFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        invocation: *mut GDBusMethodInvocation,
        user_data: gpointer,
    ),
>;
#[doc = " GDBusInterfaceGetPropertyFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name for the property.\n @property_name: The name of the property to get the value of.\n @error: Return location for error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @get_property function in #GDBusInterfaceVTable.\n\n Returns: A #GVariant with the value for @property_name or %NULL if\n     @error is set. If the returned #GVariant is floating, it is\n     consumed - otherwise its reference count is decreased by one.\n\n Since: 2.26"]
pub type GDBusInterfaceGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
#[doc = " GDBusInterfaceSetPropertyFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name for the property.\n @property_name: The name of the property to get the value of.\n @value: The value to set the property to.\n @error: Return location for error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @set_property function in #GDBusInterfaceVTable.\n\n Returns: %TRUE if the property was set to @value, %FALSE if @error is set.\n\n Since: 2.26"]
pub type GDBusInterfaceSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        value: *mut GVariant,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GDBusInterfaceVTable:\n @method_call: Function for handling incoming method calls.\n @get_property: Function for getting a property.\n @set_property: Function for setting a property.\n\n Virtual table for handling properties and method calls for a D-Bus\n interface.\n\n Since 2.38, if you want to handle getting/setting D-Bus properties\n asynchronously, give %NULL as your get_property() or set_property()\n function. The D-Bus call will be directed to your @method_call function,\n with the provided @interface_name set to \"org.freedesktop.DBus.Properties\".\n\n Ownership of the #GDBusMethodInvocation object passed to the\n method_call() function is transferred to your handler; you must\n call one of the methods of #GDBusMethodInvocation to return a reply\n (possibly empty), or an error. These functions also take ownership\n of the passed-in invocation object, so unless the invocation\n object has otherwise been referenced, it will be then be freed.\n Calling one of these functions may be done within your\n method_call() implementation but it also can be done at a later\n point to handle the method asynchronously.\n\n The usual checks on the validity of the calls is performed. For\n `Get` calls, an error is automatically returned if the property does\n not exist or the permissions do not allow access. The same checks are\n performed for `Set` calls, and the provided value is also checked for\n being the correct type.\n\n For both `Get` and `Set` calls, the #GDBusMethodInvocation\n passed to the @method_call handler can be queried with\n g_dbus_method_invocation_get_property_info() to get a pointer\n to the #GDBusPropertyInfo of the property.\n\n If you have readable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @get_property()\n function or provide implementations of both the `Get` and `GetAll`\n methods on org.freedesktop.DBus.Properties interface in your @method_call\n function. Note that the required return type of the `Get` call is\n `(v)`, not the type of the property. `GetAll` expects a return value\n of type `a{sv}`.\n\n If you have writable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @set_property()\n function or provide an implementation of the `Set` call. If implementing\n the call, you must return the value of type %G_VARIANT_TYPE_UNIT.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusInterfaceVTable {
    pub method_call: GDBusInterfaceMethodCallFunc,
    pub get_property: GDBusInterfaceGetPropertyFunc,
    pub set_property: GDBusInterfaceSetPropertyFunc,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusInterfaceVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceVTable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceVTable>(),
        88usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_call) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(method_call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_property) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_connection_register_object(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        vtable: *const GDBusInterfaceVTable,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_register_object_with_closures(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        method_call_closure: *mut GClosure,
        get_property_closure: *mut GClosure,
        set_property_closure: *mut GClosure,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unregister_object(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
#[doc = " GDBusSubtreeEnumerateFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @enumerate function in #GDBusSubtreeVTable.\n\n This function is called when generating introspection data and also\n when preparing to dispatch incoming messages in the event that the\n %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not\n specified (ie: to verify that the object path is valid).\n\n Hierarchies are not supported; the items that you return should not\n contain the `/` character.\n\n The return value will be freed with g_strfreev().\n\n Returns: (array zero-terminated=1) (transfer full): A newly allocated array of strings for node names that are children of @object_path.\n\n Since: 2.26"]
pub type GDBusSubtreeEnumerateFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut gchar,
>;
#[doc = " GDBusSubtreeIntrospectFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @introspect function in #GDBusSubtreeVTable.\n\n Subtrees are flat.  @node, if non-%NULL, is always exactly one\n segment of the object path (ie: it never contains a slash).\n\n This function should return %NULL to indicate that there is no object\n at this node.\n\n If this function returns non-%NULL, the return value is expected to\n be a %NULL-terminated array of pointers to #GDBusInterfaceInfo\n structures describing the interfaces implemented by @node.  This\n array will have g_dbus_interface_info_unref() called on each item\n before being freed with g_free().\n\n The difference between returning %NULL and an array containing zero\n items is that the standard DBus interfaces will returned to the\n remote introspector in the empty array case, but not in the %NULL\n case.\n\n Returns: (array zero-terminated=1) (nullable) (transfer full): A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.\n\n Since: 2.26"]
pub type GDBusSubtreeIntrospectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        node: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut GDBusInterfaceInfo,
>;
#[doc = " GDBusSubtreeDispatchFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @interface_name: The D-Bus interface name that the method call or property access is for.\n @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.\n @out_user_data: (nullable) (not optional): Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @dispatch function in #GDBusSubtreeVTable.\n\n Subtrees are flat.  @node, if non-%NULL, is always exactly one\n segment of the object path (ie: it never contains a slash).\n\n Returns: (nullable): A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.\n\n Since: 2.26"]
pub type GDBusSubtreeDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        node: *const gchar,
        out_user_data: *mut gpointer,
        user_data: gpointer,
    ) -> *const GDBusInterfaceVTable,
>;
#[doc = " GDBusSubtreeVTable:\n @enumerate: Function for enumerating child nodes.\n @introspect: Function for introspecting a child node.\n @dispatch: Function for dispatching a remote call on a child node.\n\n Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusSubtreeVTable {
    pub enumerate: GDBusSubtreeEnumerateFunc,
    pub introspect: GDBusSubtreeIntrospectFunc,
    pub dispatch: GDBusSubtreeDispatchFunc,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusSubtreeVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusSubtreeVTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusSubtreeVTable>(),
        88usize,
        concat!("Size of: ", stringify!(_GDBusSubtreeVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusSubtreeVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusSubtreeVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).introspect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(introspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_connection_register_subtree(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        vtable: *const GDBusSubtreeVTable,
        flags: GDBusSubtreeFlags,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unregister_subtree(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
#[doc = " GDBusSignalCallback:\n @connection: A #GDBusConnection.\n @sender_name: (nullable): The unique bus name of the sender of the signal,\nor %NULL on a peer-to-peer D-Bus connection.\n @object_path: The object path that the signal was emitted on.\n @interface_name: The name of the interface.\n @signal_name: The name of the signal.\n @parameters: A #GVariant tuple with parameters for the signal.\n @user_data: User data passed when subscribing to the signal.\n\n Signature for callback function used in g_dbus_connection_signal_subscribe().\n\n Since: 2.26"]
pub type GDBusSignalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_dbus_connection_signal_subscribe(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        interface_name: *const gchar,
        member: *const gchar,
        object_path: *const gchar,
        arg0: *const gchar,
        flags: GDBusSignalFlags,
        callback: GDBusSignalCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_signal_unsubscribe(
        connection: *mut GDBusConnection,
        subscription_id: guint,
    );
}
#[doc = " GDBusMessageFilterFunction:\n @connection: (transfer none): A #GDBusConnection.\n @message: (transfer full): A locked #GDBusMessage that the filter function takes ownership of.\n @incoming: %TRUE if it is a message received from the other peer, %FALSE if it is\n a message to be sent to the other peer.\n @user_data: User data passed when adding the filter.\n\n Signature for function used in g_dbus_connection_add_filter().\n\n A filter function is passed a #GDBusMessage and expected to return\n a #GDBusMessage too. Passive filter functions that don't modify the\n message can simply return the @message object:\n |[\n static GDBusMessage *\n passive_filter (GDBusConnection *connection\n                 GDBusMessage    *message,\n                 gboolean         incoming,\n                 gpointer         user_data)\n {\n   // inspect @message\n   return message;\n }\n ]|\n Filter functions that wants to drop a message can simply return %NULL:\n |[\n static GDBusMessage *\n drop_filter (GDBusConnection *connection\n              GDBusMessage    *message,\n              gboolean         incoming,\n              gpointer         user_data)\n {\n   if (should_drop_message)\n     {\n       g_object_unref (message);\n       message = NULL;\n     }\n   return message;\n }\n ]|\n Finally, a filter function may modify a message by copying it:\n |[\n static GDBusMessage *\n modifying_filter (GDBusConnection *connection\n                   GDBusMessage    *message,\n                   gboolean         incoming,\n                   gpointer         user_data)\n {\n   GDBusMessage *copy;\n   GError *error;\n\n   error = NULL;\n   copy = g_dbus_message_copy (message, &error);\n   // handle @error being set\n   g_object_unref (message);\n\n   // modify @copy\n\n   return copy;\n }\n ]|\n If the returned #GDBusMessage is different from @message and cannot\n be sent on @connection (it could use features, such as file\n descriptors, not compatible with @connection), then a warning is\n logged to standard error. Applications can\n check this ahead of time using g_dbus_message_to_blob() passing a\n #GDBusCapabilityFlags value obtained from @connection.\n\n Returns: (transfer full) (nullable): A #GDBusMessage that will be freed with\n g_object_unref() or %NULL to drop the message. Passive filter\n functions can simply return the passed @message object.\n\n Since: 2.26"]
pub type GDBusMessageFilterFunction = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        incoming: gboolean,
        user_data: gpointer,
    ) -> *mut GDBusMessage,
>;
extern "C" {
    pub fn g_dbus_connection_add_filter(
        connection: *mut GDBusConnection,
        filter_function: GDBusMessageFilterFunction,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection, filter_id: guint);
}
extern "C" {
    pub fn g_dbus_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_dbus_error_is_remote_error(error: *const GError) -> gboolean;
}
extern "C" {
    pub fn g_dbus_error_get_remote_error(error: *const GError) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_error_strip_remote_error(error: *mut GError) -> gboolean;
}
#[doc = " GDBusErrorEntry:\n @error_code: An error code.\n @dbus_error_name: The D-Bus error name to associate with @error_code.\n\n Struct used in g_dbus_error_register_error_domain().\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusErrorEntry {
    pub error_code: gint,
    pub dbus_error_name: *const gchar,
}
#[test]
fn bindgen_test_layout__GDBusErrorEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusErrorEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusErrorEntry>(),
        16usize,
        concat!("Size of: ", stringify!(_GDBusErrorEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusErrorEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusErrorEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusErrorEntry),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbus_error_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusErrorEntry),
            "::",
            stringify!(dbus_error_name)
        )
    );
}
extern "C" {
    pub fn g_dbus_error_register_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_error_unregister_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_error_register_error_domain(
        error_domain_quark_name: *const gchar,
        quark_volatile: *mut gsize,
        entries: *const GDBusErrorEntry,
        num_entries: guint,
    );
}
extern "C" {
    pub fn g_dbus_error_new_for_dbus_error(
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_dbus_error_set_dbus_error(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_dbus_error_set_dbus_error_valist(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        var_args: va_list,
    );
}
extern "C" {
    pub fn g_dbus_error_encode_gerror(error: *const GError) -> *mut gchar;
}
#[doc = " GDBusInterface:\n\n Base type for D-Bus interfaces.\n\n Since: 2.30"]
pub type GDBusInterfaceIface = _GDBusInterfaceIface;
#[doc = " GDBusInterfaceIface:\n @parent_iface: The parent interface.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info().\n @get_object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().\n @set_object: Sets the enclosing #GDBusObject. See g_dbus_interface_set_object().\n @dup_object: Gets a reference to the enclosing #GDBusObject. See g_dbus_interface_dup_object(). Added in 2.32.\n\n Base type for D-Bus interfaces.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusInterfaceIface {
    pub parent_iface: GTypeInterface,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo,
    >,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
    pub set_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface, object: *mut GDBusObject),
    >,
    pub dup_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceIface>(),
        48usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(get_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_object) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(set_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup_object) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(dup_object)
        )
    );
}
extern "C" {
    pub fn g_dbus_interface_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
extern "C" {
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface, object: *mut GDBusObject);
}
extern "C" {
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
#[doc = " GDBusInterfaceSkeletonClass:\n @parent_class: The parent class.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.\n @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.\n @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().\n @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().\n @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.\n\n Class structure for #GDBusInterfaceSkeleton.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeletonClass = _GDBusInterfaceSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate;
#[doc = " GDBusInterfaceSkeleton:\n\n The #GDBusInterfaceSkeleton structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusInterfaceSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusInterfaceSkeletonPrivate,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceSkeleton() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceSkeleton> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceSkeleton>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceSkeleton>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceSkeleton))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeleton),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeleton),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusInterfaceSkeletonClass:\n @parent_class: The parent class.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.\n @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.\n @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().\n @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().\n @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.\n\n Class structure for #GDBusInterfaceSkeleton.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusInterfaceSkeletonClass {
    pub parent_class: GObjectClass,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo,
    >,
    pub get_vtable: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable,
    >,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GVariant,
    >,
    pub flush: ::std::option::Option<unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton)>,
    pub vfunc_padding: [gpointer; 8usize],
    pub g_authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub signal_padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusInterfaceSkeletonClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceSkeletonClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceSkeletonClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceSkeletonClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceSkeletonClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceSkeletonClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_info) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_vtable) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfunc_padding) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(vfunc_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_authorize_method) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(g_authorize_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_padding) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(signal_padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_flags(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> GDBusInterfaceSkeletonFlags;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_set_flags(
        interface_: *mut GDBusInterfaceSkeleton,
        flags: GDBusInterfaceSkeletonFlags,
    );
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_info(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_vtable(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceVTable;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_properties(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_flush(interface_: *mut GDBusInterfaceSkeleton);
}
extern "C" {
    pub fn g_dbus_interface_skeleton_export(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_unexport(interface_: *mut GDBusInterfaceSkeleton);
}
extern "C" {
    pub fn g_dbus_interface_skeleton_unexport_from_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    );
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_connection(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_connections(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_has_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_object_path(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *const gchar;
}
#[doc = " GDBusAnnotationInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @key: The name of the annotation, e.g. \"org.freedesktop.DBus.Deprecated\".\n @value: The value of the annotation.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an annotation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusAnnotationInfo {
    pub ref_count: gint,
    pub key: *mut gchar,
    pub value: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusAnnotationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusAnnotationInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusAnnotationInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusAnnotationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusAnnotationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusAnnotationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusArgInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: Name of the argument, e.g. @unix_user_id.\n @signature: D-Bus signature of the argument (a single complete type).\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an argument for a method or a signal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusArgInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusArgInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusArgInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusArgInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusArgInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusArgInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusArgInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusMethodInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus method, e.g. @RequestName.\n @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.\n @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a method on an D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusMethodInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusMethodInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusMethodInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusMethodInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusMethodInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusMethodInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusMethodInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(in_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(out_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusSignalInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus signal, e.g. \"NameOwnerChanged\".\n @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a signal on a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusSignalInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusSignalInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusSignalInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusSignalInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusSignalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusSignalInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusSignalInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusPropertyInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus property, e.g. \"SupportedFilesystems\".\n @signature: The D-Bus signature of the property (a single complete type).\n @flags: Access control flags for the property.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus property on a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusPropertyInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusPropertyInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusPropertyInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusPropertyInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusPropertyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusPropertyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusPropertyInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusInterfaceInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus interface, e.g. \"org.freedesktop.DBus.Properties\".\n @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.\n @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.\n @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusInterfaceInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signals) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(signals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusNodeInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.\n @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.\n @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about nodes in a remote object hierarchy.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusNodeInfo {
    pub ref_count: gint,
    pub path: *mut gchar,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusNodeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusNodeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusNodeInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusNodeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusNodeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusNodeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaces) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(interfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(annotations)
        )
    );
}
extern "C" {
    pub fn g_dbus_annotation_info_lookup(
        annotations: *mut *mut GDBusAnnotationInfo,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_interface_info_lookup_method(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusMethodInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_lookup_signal(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusSignalInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_lookup_property(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusPropertyInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_interface_info_generate_xml(
        info: *mut GDBusInterfaceInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
extern "C" {
    pub fn g_dbus_node_info_new_for_xml(
        xml_data: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GDBusNodeInfo;
}
extern "C" {
    pub fn g_dbus_node_info_lookup_interface(
        info: *mut GDBusNodeInfo,
        name: *const gchar,
    ) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_node_info_generate_xml(
        info: *mut GDBusNodeInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
extern "C" {
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo) -> *mut GDBusNodeInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo) -> *mut GDBusMethodInfo;
}
extern "C" {
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo) -> *mut GDBusSignalInfo;
}
extern "C" {
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo) -> *mut GDBusPropertyInfo;
}
extern "C" {
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
}
extern "C" {
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo) -> *mut GDBusAnnotationInfo;
}
extern "C" {
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);
}
extern "C" {
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);
}
extern "C" {
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);
}
extern "C" {
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);
}
extern "C" {
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);
}
extern "C" {
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
}
extern "C" {
    pub fn g_dbus_node_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_method_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_signal_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_property_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_arg_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_annotation_info_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMenuModel {
    _unused: [u8; 0],
}
pub type GDBusMenuModel = _GDBusMenuModel;
extern "C" {
    pub fn g_dbus_menu_model_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_menu_model_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusMenuModel;
}
extern "C" {
    pub fn g_dbus_message_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_signal(
        path: *const gchar,
        interface_: *const gchar,
        signal: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_call(
        name: *const gchar,
        path: *const gchar,
        interface_: *const gchar,
        method: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_reply(
        method_call_message: *mut GDBusMessage,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_error(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        ...
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_error_valist(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        var_args: va_list,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_error_literal(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: guint) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
}
extern "C" {
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
}
extern "C" {
    pub fn g_dbus_message_copy(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage) -> GDBusMessageByteOrder;
}
extern "C" {
    pub fn g_dbus_message_set_byte_order(
        message: *mut GDBusMessage,
        byte_order: GDBusMessageByteOrder,
    );
}
extern "C" {
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage) -> GDBusMessageType;
}
extern "C" {
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage, type_: GDBusMessageType);
}
extern "C" {
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage) -> GDBusMessageFlags;
}
extern "C" {
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage, flags: GDBusMessageFlags);
}
extern "C" {
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage, serial: guint32);
}
extern "C" {
    pub fn g_dbus_message_get_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_message_set_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage) -> *mut guchar;
}
extern "C" {
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage, body: *mut GVariant);
}
extern "C" {
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage) -> *mut GUnixFDList;
}
extern "C" {
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage, fd_list: *mut GUnixFDList);
}
extern "C" {
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage, value: guint32);
}
extern "C" {
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage, value: guint32);
}
extern "C" {
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_new_from_blob(
        blob: *mut guchar,
        blob_len: gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_bytes_needed(
        blob: *mut guchar,
        blob_len: gsize,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_dbus_message_to_blob(
        message: *mut GDBusMessage,
        out_size: *mut gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut guchar;
}
extern "C" {
    pub fn g_dbus_message_to_gerror(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_sender(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_object_path(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_interface_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_method_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_method_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusMethodInfo;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_property_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusPropertyInfo;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_connection(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_message(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_parameters(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_user_data(
        invocation: *mut GDBusMethodInvocation,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dbus_method_invocation_return_value(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
        fd_list: *mut GUnixFDList,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_error(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_error_valist(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        var_args: va_list,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_error_literal(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_gerror(
        invocation: *mut GDBusMethodInvocation,
        error: *const GError,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_take_error(
        invocation: *mut GDBusMethodInvocation,
        error: *mut GError,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_dbus_error(
        invocation: *mut GDBusMethodInvocation,
        error_name: *const gchar,
        error_message: *const gchar,
    );
}
#[doc = " GBusAcquiredCallback:\n @connection: The #GDBusConnection to a message bus.\n @name: The name that is requested to be owned.\n @user_data: User data passed to g_bus_own_name().\n\n Invoked when a connection to a message bus has been obtained.\n\n Since: 2.26"]
pub type GBusAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
#[doc = " GBusNameAcquiredCallback:\n @connection: The #GDBusConnection on which to acquired the name.\n @name: The name being owned.\n @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().\n\n Invoked when the name is acquired.\n\n Since: 2.26"]
pub type GBusNameAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
#[doc = " GBusNameLostCallback:\n @connection: The #GDBusConnection on which to acquire the name or %NULL if\n the connection was disconnected.\n @name: The name being owned.\n @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().\n\n Invoked when the name is lost or @connection has been closed.\n\n Since: 2.26"]
pub type GBusNameLostCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
extern "C" {
    pub fn g_bus_own_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_handler: GBusAcquiredCallback,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_own_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_own_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_closure: *mut GClosure,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_own_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_unown_name(owner_id: guint);
}
#[doc = " GBusNameAppearedCallback:\n @connection: The #GDBusConnection the name is being watched on.\n @name: The name being watched.\n @name_owner: Unique name of the owner of the name being watched.\n @user_data: User data passed to g_bus_watch_name().\n\n Invoked when the name being watched is known to have to have an owner.\n\n Since: 2.26"]
pub type GBusNameAppearedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        name: *const gchar,
        name_owner: *const gchar,
        user_data: gpointer,
    ),
>;
#[doc = " GBusNameVanishedCallback:\n @connection: The #GDBusConnection the name is being watched on, or\n     %NULL.\n @name: The name being watched.\n @user_data: User data passed to g_bus_watch_name().\n\n Invoked when the name being watched is known not to have to have an owner.\n\n This is also invoked when the #GDBusConnection on which the watch was\n established has been closed.  In that case, @connection will be\n %NULL.\n\n Since: 2.26"]
pub type GBusNameVanishedCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
extern "C" {
    pub fn g_bus_watch_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_watch_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_watch_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_watch_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_unwatch_name(watcher_id: guint);
}
#[doc = " GDBusObjectIface:\n @parent_iface: The parent interface.\n @get_object_path: Returns the object path. See g_dbus_object_get_object_path().\n @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().\n @get_interface: Returns an interface by name. See g_dbus_object_get_interface().\n @interface_added: Signal handler for the #GDBusObject::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.\n\n Base object type for D-Bus objects.\n\n Since: 2.30"]
pub type GDBusObjectIface = _GDBusObjectIface;
#[doc = " GDBusObjectIface:\n @parent_iface: The parent interface.\n @get_object_path: Returns the object path. See g_dbus_object_get_object_path().\n @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().\n @get_interface: Returns an interface by name. See g_dbus_object_get_interface().\n @interface_added: Signal handler for the #GDBusObject::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.\n\n Base object type for D-Bus objects.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *const gchar>,
    pub get_interfaces:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *mut GList>,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObject,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
}
#[test]
fn bindgen_test_layout__GDBusObjectIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GDBusObjectIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_object_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interfaces) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_interfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_added) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(interface_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_removed) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(interface_removed)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject) -> *mut GList;
}
extern "C" {
    pub fn g_dbus_object_get_interface(
        object: *mut GDBusObject,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
#[doc = " GDBusObjectManagerIface:\n @parent_iface: The parent interface.\n @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().\n @get_objects: Virtual function for g_dbus_object_manager_get_objects().\n @get_object: Virtual function for g_dbus_object_manager_get_object().\n @get_interface: Virtual function for g_dbus_object_manager_get_interface().\n @object_added: Signal handler for the #GDBusObjectManager::object-added signal.\n @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.\n @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.\n\n Base type for D-Bus object managers.\n\n Since: 2.30"]
pub type GDBusObjectManagerIface = _GDBusObjectManagerIface;
#[doc = " GDBusObjectManagerIface:\n @parent_iface: The parent interface.\n @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().\n @get_objects: Virtual function for g_dbus_object_manager_get_objects().\n @get_object: Virtual function for g_dbus_object_manager_get_object().\n @get_interface: Virtual function for g_dbus_object_manager_get_interface().\n @object_added: Signal handler for the #GDBusObjectManager::object-added signal.\n @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.\n @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.\n\n Base type for D-Bus object managers.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectManagerIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *const gchar,
    >,
    pub get_objects:
        ::std::option::Option<unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *mut GList>,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
        ) -> *mut GDBusObject,
    >,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub object_added: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub object_removed: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerIface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerIface>(),
        80usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_object_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_objects) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_objects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_added) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(object_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_removed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(object_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_added) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(interface_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_removed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(interface_removed)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_manager_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_get_object_path(manager: *mut GDBusObjectManager) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager) -> *mut GList;
}
extern "C" {
    pub fn g_dbus_object_manager_get_object(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
    ) -> *mut GDBusObject;
}
extern "C" {
    pub fn g_dbus_object_manager_get_interface(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
#[doc = " GDBusObjectManagerClientClass:\n @parent_class: The parent class.\n @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.\n @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.\n\n Class structure for #GDBusObjectManagerClient.\n\n Since: 2.30"]
pub type GDBusObjectManagerClientClass = _GDBusObjectManagerClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate;
#[doc = " GDBusObjectManagerClient:\n\n The #GDBusObjectManagerClient structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectManagerClient {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerClientPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerClient() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerClient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerClient>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerClient))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerClient>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClient),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClient),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectManagerClientClass:\n @parent_class: The parent class.\n @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.\n @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.\n\n Class structure for #GDBusObjectManagerClient.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectManagerClientClass {
    pub parent_class: GObjectClass,
    pub interface_proxy_signal: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub interface_proxy_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerClientClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerClientClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerClientClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerClientClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerClientClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerClientClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_proxy_signal) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(interface_proxy_signal)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).interface_proxy_properties_changed) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(interface_proxy_properties_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_connection(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_flags(
        manager: *mut GDBusObjectManagerClient,
    ) -> GDBusObjectManagerClientFlags;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_name(
        manager: *mut GDBusObjectManagerClient,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_name_owner(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut gchar;
}
#[doc = " GDBusObjectManagerServerClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectManagerServer.\n\n Since: 2.30"]
pub type GDBusObjectManagerServerClass = _GDBusObjectManagerServerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate;
#[doc = " GDBusObjectManagerServer:\n\n The #GDBusObjectManagerServer structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectManagerServer {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerServerPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerServer() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerServer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerServer>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerServer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerServer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerServer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServer),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServer),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectManagerServerClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectManagerServer.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectManagerServerClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerServerClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerServerClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerServerClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerServerClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerServerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerServerClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServerClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_server_new(
        object_path: *const gchar,
    ) -> *mut GDBusObjectManagerServer;
}
extern "C" {
    pub fn g_dbus_object_manager_server_get_connection(
        manager: *mut GDBusObjectManagerServer,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_object_manager_server_set_connection(
        manager: *mut GDBusObjectManagerServer,
        connection: *mut GDBusConnection,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_export(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_export_uniquely(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_is_exported(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_object_manager_server_unexport(
        manager: *mut GDBusObjectManagerServer,
        object_path: *const gchar,
    ) -> gboolean;
}
#[doc = " GDBusObjectProxyClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectProxy.\n\n Since: 2.30"]
pub type GDBusObjectProxyClass = _GDBusObjectProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate;
#[doc = " GDBusObjectProxy:\n\n The #GDBusObjectProxy structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectProxyPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectProxy() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectProxy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectProxy>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectProxy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxy),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxy),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectProxyClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectProxy.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectProxyClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectProxyClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectProxyClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectProxyClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GDBusObjectProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectProxyClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxyClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_proxy_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_proxy_new(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
    ) -> *mut GDBusObjectProxy;
}
extern "C" {
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy)
        -> *mut GDBusConnection;
}
#[doc = " GDBusObjectSkeletonClass:\n @parent_class: The parent class.\n @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.\n\n Class structure for #GDBusObjectSkeleton.\n\n Since: 2.30"]
pub type GDBusObjectSkeletonClass = _GDBusObjectSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate;
#[doc = " GDBusObjectSkeleton:\n\n The #GDBusObjectSkeleton structure contains private data and should only be\n accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectSkeletonPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectSkeleton() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectSkeleton> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectSkeleton>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectSkeleton>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectSkeleton))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeleton),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeleton),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectSkeletonClass:\n @parent_class: The parent class.\n @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.\n\n Class structure for #GDBusObjectSkeleton.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusObjectSkeletonClass {
    pub parent_class: GObjectClass,
    pub authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObjectSkeleton,
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectSkeletonClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectSkeletonClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectSkeletonClass>(),
        208usize,
        concat!("Size of: ", stringify!(_GDBusObjectSkeletonClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectSkeletonClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectSkeletonClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorize_method) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(authorize_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_skeleton_new(object_path: *const gchar) -> *mut GDBusObjectSkeleton;
}
extern "C" {
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
}
extern "C" {
    pub fn g_dbus_object_skeleton_add_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_remove_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_remove_interface_by_name(
        object: *mut GDBusObjectSkeleton,
        interface_name: *const gchar,
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_set_object_path(
        object: *mut GDBusObjectSkeleton,
        object_path: *const gchar,
    );
}
#[doc = " GDBusProxyClass:\n @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.\n @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.\n\n Class structure for #GDBusProxy.\n\n Since: 2.26"]
pub type GDBusProxyClass = _GDBusProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusProxyPrivate = _GDBusProxyPrivate;
#[doc = " GDBusProxy:\n\n The #GDBusProxy structure contains only private data and\n should only be accessed using the provided API.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusProxyPrivate,
}
#[test]
fn bindgen_test_layout__GDBusProxy() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusProxy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusProxy>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusProxy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxy),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxy),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusProxyClass:\n @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.\n @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.\n\n Class structure for #GDBusProxy.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDBusProxyClass {
    pub parent_class: GObjectClass,
    pub g_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub g_signal: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub padding: [gpointer; 32usize],
}
#[test]
fn bindgen_test_layout__GDBusProxyClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusProxyClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusProxyClass>(),
        408usize,
        concat!("Size of: ", stringify!(_GDBusProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusProxyClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_properties_changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(g_properties_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_signal) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(g_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_proxy_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_proxy_new(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_new_for_bus(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
}
extern "C" {
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> gint;
}
extern "C" {
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy, timeout_msec: gint);
}
extern "C" {
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy, info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_proxy_get_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_set_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_dbus_proxy_call(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_call_finish(
        proxy: *mut GDBusProxy,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_call_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(
        proxy: *mut GDBusProxy,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_server_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_server_new_sync(
        address: *const gchar,
        flags: GDBusServerFlags,
        guid: *const gchar,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusServer;
}
extern "C" {
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer) -> GDBusServerFlags;
}
extern "C" {
    pub fn g_dbus_server_start(server: *mut GDBusServer);
}
extern "C" {
    pub fn g_dbus_server_stop(server: *mut GDBusServer);
}
extern "C" {
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_guid(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_generate_guid() -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_is_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_unique_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_member_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_interface_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_error_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_gvariant_to_gvalue(value: *mut GVariant, out_gvalue: *mut GValue);
}
extern "C" {
    pub fn g_dbus_gvalue_to_gvariant(
        gvalue: *const GValue,
        type_: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_escape_object_path_bytestring(bytes: *const guint8) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_escape_object_path(s: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_unescape_object_path(s: *const gchar) -> *mut guint8;
}
extern "C" {
    pub fn g_debug_controller_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugController {
    _unused: [u8; 0],
}
pub type GDebugController = _GDebugController;
#[doc = " GDebugControllerInterface:\n @g_iface: The parent interface.\n\n The virtual function table for #GDebugController.\n\n Since: 2.72"]
pub type GDebugControllerInterface = _GDebugControllerInterface;
pub type GDebugController_autoptr = *mut GDebugController;
pub type GDebugController_listautoptr = *mut GList;
pub type GDebugController_slistautoptr = *mut GSList;
pub type GDebugController_queueautoptr = *mut GQueue;
#[doc = " GDebugControllerInterface:\n @g_iface: The parent interface.\n\n The virtual function table for #GDebugController.\n\n Since: 2.72"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDebugControllerInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDebugControllerInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugControllerInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugControllerInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugControllerInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugControllerInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugControllerInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_debug_controller_get_debug_enabled(self_: *mut GDebugController) -> gboolean;
}
extern "C" {
    pub fn g_debug_controller_set_debug_enabled(
        self_: *mut GDebugController,
        debug_enabled: gboolean,
    );
}
extern "C" {
    pub fn g_debug_controller_dbus_get_type() -> GType;
}
pub type GDebugControllerDBus = _GDebugControllerDBus;
#[doc = " GDebugControllerDBusClass:\n @parent_class: The parent class.\n @authorize: Default handler for the #GDebugControllerDBus::authorize signal.\n\n The virtual function table for #GDebugControllerDBus.\n\n Since: 2.72"]
pub type GDebugControllerDBusClass = _GDebugControllerDBusClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDebugControllerDBus {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GDebugControllerDBus() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugControllerDBus> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugControllerDBus>(),
        24usize,
        concat!("Size of: ", stringify!(_GDebugControllerDBus))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugControllerDBus>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugControllerDBus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBus),
            "::",
            stringify!(parent_instance)
        )
    );
}
pub type GDebugControllerDBus_autoptr = *mut GDebugControllerDBus;
pub type GDebugControllerDBus_listautoptr = *mut GList;
pub type GDebugControllerDBus_slistautoptr = *mut GSList;
pub type GDebugControllerDBus_queueautoptr = *mut GQueue;
pub type GDebugControllerDBusClass_autoptr = *mut GDebugControllerDBusClass;
pub type GDebugControllerDBusClass_listautoptr = *mut GList;
pub type GDebugControllerDBusClass_slistautoptr = *mut GSList;
pub type GDebugControllerDBusClass_queueautoptr = *mut GQueue;
#[doc = " GDebugControllerDBusClass:\n @parent_class: The parent class.\n @authorize: Default handler for the #GDebugControllerDBus::authorize signal.\n\n The virtual function table for #GDebugControllerDBus.\n\n Since: 2.72"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDebugControllerDBusClass {
    pub parent_class: GObjectClass,
    pub authorize: ::std::option::Option<
        unsafe extern "C" fn(
            controller: *mut GDebugControllerDBus,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__GDebugControllerDBusClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugControllerDBusClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugControllerDBusClass>(),
        240usize,
        concat!("Size of: ", stringify!(_GDebugControllerDBusClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugControllerDBusClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugControllerDBusClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBusClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBusClass),
            "::",
            stringify!(authorize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBusClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_debug_controller_dbus_new(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDebugControllerDBus;
}
extern "C" {
    pub fn g_debug_controller_dbus_stop(self_: *mut GDebugControllerDBus);
}
#[doc = " GDriveIface:\n @g_iface: The parent interface.\n @changed: Signal emitted when the drive is changed.\n @disconnected: The removed signal that is emitted when the #GDrive have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.\n @eject_button: Signal emitted when the physical eject button (if any) of a drive have been pressed.\n @get_name: Returns the name for the given #GDrive.\n @get_icon: Returns a #GIcon for the given #GDrive.\n @has_volumes: Returns %TRUE if the #GDrive has mountable volumes.\n @get_volumes: Returns a list #GList of #GVolume for the #GDrive.\n @is_removable: Returns %TRUE if the #GDrive and/or its media is considered removable by the user. Since 2.50.\n @is_media_removable: Returns %TRUE if the #GDrive supports removal and insertion of media.\n @has_media: Returns %TRUE if the #GDrive has media inserted.\n @is_media_check_automatic: Returns %TRUE if the #GDrive is capable of automatically detecting media changes.\n @can_poll_for_media: Returns %TRUE if the #GDrive is capable of manually polling for media change.\n @can_eject: Returns %TRUE if the #GDrive can eject media.\n @eject: Ejects a #GDrive.\n @eject_finish: Finishes an eject operation.\n @poll_for_media: Poll for media insertion/removal on a #GDrive.\n @poll_for_media_finish: Finishes a media poll operation.\n @get_identifier: Returns the identifier of the given kind, or %NULL if\n    the #GDrive doesn't have one.\n @enumerate_identifiers: Returns an array strings listing the kinds\n    of identifiers which the #GDrive has.\n @get_start_stop_type: Gets a #GDriveStartStopType with details about starting/stopping the drive. Since 2.22.\n @can_stop: Returns %TRUE if a #GDrive can be stopped. Since 2.22.\n @stop: Stops a #GDrive. Since 2.22.\n @stop_finish: Finishes a stop operation. Since 2.22.\n @can_start: Returns %TRUE if a #GDrive can be started. Since 2.22.\n @can_start_degraded: Returns %TRUE if a #GDrive can be started degraded. Since 2.22.\n @start: Starts a #GDrive. Since 2.22.\n @start_finish: Finishes a start operation. Since 2.22.\n @stop_button: Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.\n @eject_with_operation: Starts ejecting a #GDrive using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_sort_key: Gets a key used for sorting #GDrive instances or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Returns a symbolic #GIcon for the given #GDrive. Since 2.34.\n\n Interface for creating #GDrive implementations."]
pub type GDriveIface = _GDriveIface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDriveIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub disconnected: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub has_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub get_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GList>,
    pub is_media_removable:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub has_media: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub is_media_check_automatic:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_poll_for_media:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_for_media: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_for_media_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            kind: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub get_start_stop_type:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> GDriveStartStopType>,
    pub can_start: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_start_degraded:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GDriveStartFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_stop: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub is_removable: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GDriveIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDriveIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDriveIface>(),
        272usize,
        concat!("Size of: ", stringify!(_GDriveIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDriveIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDriveIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnected) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(disconnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_button) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_volumes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(has_volumes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volumes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_volumes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_media_removable) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_media_removable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_media) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(has_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_media_check_automatic) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_media_check_automatic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_eject) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_poll_for_media) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_poll_for_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_finish) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_for_media) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(poll_for_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_for_media_finish) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(poll_for_media_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_identifiers) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(enumerate_identifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_start_stop_type) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_start_stop_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_start) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_start_degraded) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_start_degraded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_finish) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(start_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_stop) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_finish) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_button) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation_finish) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sort_key) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_symbolic_icon) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_removable) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_removable)
        )
    );
}
extern "C" {
    pub fn g_drive_get_type() -> GType;
}
extern "C" {
    pub fn g_drive_get_name(drive: *mut GDrive) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
}
extern "C" {
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
}
extern "C" {
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut GList;
}
extern "C" {
    pub fn g_drive_is_removable(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_eject(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_eject_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_poll_for_media(
        drive: *mut GDrive,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_poll_for_media_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_get_identifier(
        drive: *mut GDrive,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive) -> GDriveStartStopType;
}
extern "C" {
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_start(
        drive: *mut GDrive,
        flags: GDriveStartFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_start_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_stop(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_stop_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_eject_with_operation(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_eject_with_operation_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const gchar;
}
#[doc = " GDtlsConnectionInterface:\n @g_iface: The parent interface.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @shutdown: Shut down one or both directions of the connection.\n @shutdown_async: Start an asynchronous shutdown operation.\n @shutdown_finish: Finish an asynchronous shutdown operation.\n @set_advertised_protocols: Set APLN protocol list (Since: 2.60)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n\n Virtual method table for a #GDtlsConnection implementation.\n\n Since: 2.48"]
pub type GDtlsConnectionInterface = _GDtlsConnectionInterface;
#[doc = " GDtlsConnectionInterface:\n @g_iface: The parent interface.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @shutdown: Shut down one or both directions of the connection.\n @shutdown_async: Start an asynchronous shutdown operation.\n @shutdown_finish: Finish an asynchronous shutdown operation.\n @set_advertised_protocols: Set APLN protocol list (Since: 2.60)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n\n Virtual method table for a #GDtlsConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDtlsConnectionInterface {
    pub g_iface: GTypeInterface,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GDtlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub shutdown_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_advertised_protocols: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GDtlsConnection, protocols: *const *const gchar),
    >,
    pub get_negotiated_protocol:
        ::std::option::Option<unsafe extern "C" fn(conn: *mut GDtlsConnection) -> *const gchar>,
    pub get_binding_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            type_: GTlsChannelBindingType,
            data: *mut GByteArray,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GDtlsConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDtlsConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDtlsConnectionInterface>(),
        96usize,
        concat!("Size of: ", stringify!(_GDtlsConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_certificate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(accept_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_async) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_async) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_finish) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_advertised_protocols) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(set_advertised_protocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_negotiated_protocol) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(get_negotiated_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_binding_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(get_binding_data)
        )
    );
}
extern "C" {
    pub fn g_dtls_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_dtls_connection_set_database(conn: *mut GDtlsConnection, database: *mut GTlsDatabase);
}
extern "C" {
    pub fn g_dtls_connection_get_database(conn: *mut GDtlsConnection) -> *mut GTlsDatabase;
}
extern "C" {
    pub fn g_dtls_connection_set_certificate(
        conn: *mut GDtlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_certificate(conn: *mut GDtlsConnection) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_dtls_connection_set_interaction(
        conn: *mut GDtlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_interaction(conn: *mut GDtlsConnection) -> *mut GTlsInteraction;
}
extern "C" {
    pub fn g_dtls_connection_get_peer_certificate(
        conn: *mut GDtlsConnection,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_dtls_connection_get_peer_certificate_errors(
        conn: *mut GDtlsConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_dtls_connection_set_require_close_notify(
        conn: *mut GDtlsConnection,
        require_close_notify: gboolean,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_require_close_notify(conn: *mut GDtlsConnection) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_set_rehandshake_mode(
        conn: *mut GDtlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_rehandshake_mode(
        conn: *mut GDtlsConnection,
    ) -> GTlsRehandshakeMode;
}
extern "C" {
    pub fn g_dtls_connection_handshake(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_handshake_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dtls_connection_handshake_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_shutdown(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_shutdown_async(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dtls_connection_shutdown_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_close(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_close_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dtls_connection_close_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_emit_accept_certificate(
        conn: *mut GDtlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_set_advertised_protocols(
        conn: *mut GDtlsConnection,
        protocols: *const *const gchar,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_negotiated_protocol(conn: *mut GDtlsConnection) -> *const gchar;
}
extern "C" {
    pub fn g_dtls_connection_get_channel_binding_data(
        conn: *mut GDtlsConnection,
        type_: GTlsChannelBindingType,
        data: *mut GByteArray,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_get_protocol_version(
        conn: *mut GDtlsConnection,
    ) -> GTlsProtocolVersion;
}
extern "C" {
    pub fn g_dtls_connection_get_ciphersuite_name(conn: *mut GDtlsConnection) -> *mut gchar;
}
#[doc = " GDtlsClientConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsClientConnection implementation.\n\n Since: 2.48"]
pub type GDtlsClientConnectionInterface = _GDtlsClientConnectionInterface;
#[doc = " GDtlsClientConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsClientConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDtlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDtlsClientConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDtlsClientConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDtlsClientConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDtlsClientConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsClientConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsClientConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsClientConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_dtls_client_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_dtls_client_connection_new(
        base_socket: *mut GDatagramBased,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
extern "C" {
    pub fn g_dtls_client_connection_get_validation_flags(
        conn: *mut GDtlsClientConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_dtls_client_connection_set_validation_flags(
        conn: *mut GDtlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    pub fn g_dtls_client_connection_get_server_identity(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_dtls_client_connection_set_server_identity(
        conn: *mut GDtlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
extern "C" {
    pub fn g_dtls_client_connection_get_accepted_cas(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GList;
}
#[doc = " GDtlsServerConnection:\n\n DTLS server-side connection. This is the server-side implementation\n of a #GDtlsConnection.\n\n Since: 2.48"]
pub type GDtlsServerConnectionInterface = _GDtlsServerConnectionInterface;
#[doc = " GDtlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsServerConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GDtlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDtlsServerConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDtlsServerConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDtlsServerConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDtlsServerConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsServerConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsServerConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsServerConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_dtls_server_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_dtls_server_connection_new(
        base_socket: *mut GDatagramBased,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
#[doc = " GIcon:\n\n An abstract type that specifies an icon."]
pub type GIconIface = _GIconIface;
#[doc = " GIconIface:\n @g_iface: The parent interface.\n @hash: A hash for a given #GIcon.\n @equal: Checks if two #GIcons are equal.\n @to_tokens: Serializes a #GIcon into tokens. The tokens must not\n contain any whitespace. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @from_tokens: Constructs a #GIcon from tokens. Set the #GError if\n the tokens are malformed. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @serialize: Serializes a #GIcon into a #GVariant. Since: 2.38\n\n GIconIface is used to implement GIcon types for various\n different systems. See #GThemedIcon and #GLoadableIcon for\n examples of how to implement this interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GIconIface {
    pub g_iface: GTypeInterface,
    pub hash: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean,
    >,
    #[doc = " GIconIface::to_tokens:\n @icon: The #GIcon\n @tokens: (element-type utf8) (out caller-allocates):\n   The array to fill with tokens\n @out_version: (out): version of serialized tokens\n\n Serializes the @icon into string tokens.\n This is can be invoked when g_icon_new_for_string() is called.\n\n Returns: %TRUE if serialization took place, %FALSE otherwise\n\n Since: 2.20"]
    pub to_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GIcon,
            tokens: *mut GPtrArray,
            out_version: *mut gint,
        ) -> gboolean,
    >,
    #[doc = " GIconIface::from_tokens:\n @tokens: (array length=num_tokens): An array of tokens\n @num_tokens: The number of tokens in @tokens\n @version: Version of the serialized tokens\n @error: Return location for errors, or %NULL to ignore\n\n Constructs a #GIcon from a list of @tokens.\n\n Returns: (nullable) (transfer full): the #GIcon or %NULL on error\n\n Since: 2.20"]
    pub from_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            tokens: *mut *mut gchar,
            num_tokens: gint,
            version: gint,
            error: *mut *mut GError,
        ) -> *mut GIcon,
    >,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> *mut GVariant>,
}
#[test]
fn bindgen_test_layout__GIconIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GIconIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIconIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GIconIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIconIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIconIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_tokens) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(to_tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_tokens) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(from_tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(serialize)
        )
    );
}
extern "C" {
    pub fn g_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_icon_hash(icon: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
}
extern "C" {
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut gchar;
}
extern "C" {
    pub fn g_icon_new_for_string(str_: *const gchar, error: *mut *mut GError) -> *mut GIcon;
}
extern "C" {
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut GVariant;
}
extern "C" {
    pub fn g_icon_deserialize(value: *mut GVariant) -> *mut GIcon;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblem {
    _unused: [u8; 0],
}
#[doc = " GEmblem:\n\n An object for Emblems"]
pub type GEmblem = _GEmblem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemClass {
    _unused: [u8; 0],
}
pub type GEmblemClass = _GEmblemClass;
extern "C" {
    pub fn g_emblem_get_type() -> GType;
}
extern "C" {
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
}
extern "C" {
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin) -> *mut GEmblem;
}
extern "C" {
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
}
extern "C" {
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;
}
#[doc = " GEmblemedIcon:\n\n An implementation of #GIcon for icons with emblems."]
pub type GEmblemedIcon = _GEmblemedIcon;
pub type GEmblemedIconClass = _GEmblemedIconClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconPrivate {
    _unused: [u8; 0],
}
pub type GEmblemedIconPrivate = _GEmblemedIconPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GEmblemedIcon {
    pub parent_instance: GObject,
    pub priv_: *mut GEmblemedIconPrivate,
}
#[test]
fn bindgen_test_layout__GEmblemedIcon() {
    const UNINIT: ::std::mem::MaybeUninit<_GEmblemedIcon> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEmblemedIcon>(),
        32usize,
        concat!("Size of: ", stringify!(_GEmblemedIcon))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEmblemedIcon>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEmblemedIcon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIcon),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIcon),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GEmblemedIconClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GEmblemedIconClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GEmblemedIconClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEmblemedIconClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GEmblemedIconClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEmblemedIconClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEmblemedIconClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIconClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_emblemed_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem) -> *mut GIcon;
}
extern "C" {
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon) -> *mut GIcon;
}
extern "C" {
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon) -> *mut GList;
}
extern "C" {
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon, emblem: *mut GEmblem);
}
extern "C" {
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
}
#[doc = " GFileIface:\n @g_iface: The parent interface.\n @dup: Duplicates a #GFile.\n @hash: Creates a hash of a #GFile.\n @equal: Checks equality of two given #GFiles.\n @is_native: Checks to see if a file is native to the system.\n @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.\n @get_uri_scheme: Gets the URI scheme for a #GFile.\n @get_basename: Gets the basename for a given #GFile.\n @get_path: Gets the current path within a #GFile.\n @get_uri: Gets a URI for the path within a #GFile.\n @get_parse_name: Gets the parsed name for the #GFile.\n @get_parent: Gets the parent directory for the #GFile.\n @prefix_matches: Checks whether a #GFile contains a specified file.\n @get_relative_path: Gets the path for a #GFile relative to a given path.\n @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.\n @get_child_for_display_name: Gets the child #GFile for a given display name.\n @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_finish: Finishes asynchronously enumerating the children.\n @query_info: Gets the #GFileInfo for a #GFile.\n @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.\n @query_info_finish: Finishes an asynchronous query info operation.\n @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_finish: Finishes asynchronously getting the file system info.\n @find_enclosing_mount: Gets a #GMount for the #GFile.\n @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.\n @find_enclosing_mount_finish: Finishes asynchronously getting the volume.\n @set_display_name: Sets the display name for a #GFile.\n @set_display_name_async: Asynchronously sets a #GFile's display name.\n @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.\n @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.\n @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.\n @set_attribute: Sets a #GFileAttributeInfo.\n @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.\n @set_attributes_async: Asynchronously sets a file's attributes.\n @set_attributes_finish: Finishes setting a file's attributes asynchronously.\n @read_fn: Reads a file asynchronously.\n @read_async: Asynchronously reads a file.\n @read_finish: Finishes asynchronously reading a file.\n @append_to: Writes to the end of a file.\n @append_to_async: Asynchronously writes to the end of a file.\n @append_to_finish: Finishes an asynchronous file append operation.\n @create: Creates a new file.\n @create_async: Asynchronously creates a file.\n @create_finish: Finishes asynchronously creating a file.\n @replace: Replaces the contents of a file.\n @replace_async: Asynchronously replaces the contents of a file.\n @replace_finish: Finishes asynchronously replacing a file.\n @delete_file: Deletes a file.\n @delete_file_async: Asynchronously deletes a file.\n @delete_file_finish: Finishes an asynchronous delete.\n @trash: Sends a #GFile to the Trash location.\n @trash_async: Asynchronously sends a #GFile to the Trash location.\n @trash_finish: Finishes an asynchronous file trashing operation.\n @make_directory: Makes a directory.\n @make_directory_async: Asynchronously makes a directory.\n @make_directory_finish: Finishes making a directory asynchronously.\n @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic\n    links are unsupported.\n @make_symbolic_link_async: Asynchronously makes a symbolic link\n @make_symbolic_link_finish: Finishes making a symbolic link asynchronously.\n @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will\n     cause `GFile` to use a fallback copy method where it reads from the\n     source and writes to the destination.\n @copy_async: Asynchronously copies a file.\n @copy_finish: Finishes an asynchronous copy operation.\n @move: Moves a file.\n @move_async: Asynchronously moves a file. Since: 2.72\n @move_finish: Finishes an asynchronous move operation. Since: 2.72\n @mount_mountable: Mounts a mountable object.\n @mount_mountable_finish: Finishes a mounting operation.\n @unmount_mountable: Unmounts a mountable object.\n @unmount_mountable_finish: Finishes an unmount operation.\n @eject_mountable: Ejects a mountable.\n @eject_mountable_finish: Finishes an eject operation.\n @mount_enclosing_volume: Mounts a specified location.\n @mount_enclosing_volume_finish: Finishes mounting a specified location.\n @monitor_dir: Creates a #GFileMonitor for the location.\n @monitor_file: Creates a #GFileMonitor for the location.\n @open_readwrite: Open file read/write. Since 2.22.\n @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.\n @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.\n @create_readwrite: Creates file read/write. Since 2.22.\n @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.\n @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.\n @replace_readwrite: Replaces file read/write. Since 2.22.\n @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.\n @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.\n @start_mountable: Starts a mountable object. Since 2.22.\n @start_mountable_finish: Finishes a start operation. Since 2.22.\n @stop_mountable: Stops a mountable. Since 2.22.\n @stop_mountable_finish: Finishes a stop operation. Since 2.22.\n @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.\n @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.\n @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @poll_mountable: Polls a mountable object for media changes. Since 2.22.\n @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.\n @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38\n\n An interface for writing VFS file handles."]
pub type GFileIface = _GFileIface;
#[doc = " GFileIface:\n @g_iface: The parent interface.\n @dup: Duplicates a #GFile.\n @hash: Creates a hash of a #GFile.\n @equal: Checks equality of two given #GFiles.\n @is_native: Checks to see if a file is native to the system.\n @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.\n @get_uri_scheme: Gets the URI scheme for a #GFile.\n @get_basename: Gets the basename for a given #GFile.\n @get_path: Gets the current path within a #GFile.\n @get_uri: Gets a URI for the path within a #GFile.\n @get_parse_name: Gets the parsed name for the #GFile.\n @get_parent: Gets the parent directory for the #GFile.\n @prefix_matches: Checks whether a #GFile contains a specified file.\n @get_relative_path: Gets the path for a #GFile relative to a given path.\n @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.\n @get_child_for_display_name: Gets the child #GFile for a given display name.\n @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_finish: Finishes asynchronously enumerating the children.\n @query_info: Gets the #GFileInfo for a #GFile.\n @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.\n @query_info_finish: Finishes an asynchronous query info operation.\n @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_finish: Finishes asynchronously getting the file system info.\n @find_enclosing_mount: Gets a #GMount for the #GFile.\n @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.\n @find_enclosing_mount_finish: Finishes asynchronously getting the volume.\n @set_display_name: Sets the display name for a #GFile.\n @set_display_name_async: Asynchronously sets a #GFile's display name.\n @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.\n @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.\n @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.\n @set_attribute: Sets a #GFileAttributeInfo.\n @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.\n @set_attributes_async: Asynchronously sets a file's attributes.\n @set_attributes_finish: Finishes setting a file's attributes asynchronously.\n @read_fn: Reads a file asynchronously.\n @read_async: Asynchronously reads a file.\n @read_finish: Finishes asynchronously reading a file.\n @append_to: Writes to the end of a file.\n @append_to_async: Asynchronously writes to the end of a file.\n @append_to_finish: Finishes an asynchronous file append operation.\n @create: Creates a new file.\n @create_async: Asynchronously creates a file.\n @create_finish: Finishes asynchronously creating a file.\n @replace: Replaces the contents of a file.\n @replace_async: Asynchronously replaces the contents of a file.\n @replace_finish: Finishes asynchronously replacing a file.\n @delete_file: Deletes a file.\n @delete_file_async: Asynchronously deletes a file.\n @delete_file_finish: Finishes an asynchronous delete.\n @trash: Sends a #GFile to the Trash location.\n @trash_async: Asynchronously sends a #GFile to the Trash location.\n @trash_finish: Finishes an asynchronous file trashing operation.\n @make_directory: Makes a directory.\n @make_directory_async: Asynchronously makes a directory.\n @make_directory_finish: Finishes making a directory asynchronously.\n @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic\n    links are unsupported.\n @make_symbolic_link_async: Asynchronously makes a symbolic link\n @make_symbolic_link_finish: Finishes making a symbolic link asynchronously.\n @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will\n     cause `GFile` to use a fallback copy method where it reads from the\n     source and writes to the destination.\n @copy_async: Asynchronously copies a file.\n @copy_finish: Finishes an asynchronous copy operation.\n @move: Moves a file.\n @move_async: Asynchronously moves a file. Since: 2.72\n @move_finish: Finishes an asynchronous move operation. Since: 2.72\n @mount_mountable: Mounts a mountable object.\n @mount_mountable_finish: Finishes a mounting operation.\n @unmount_mountable: Unmounts a mountable object.\n @unmount_mountable_finish: Finishes an unmount operation.\n @eject_mountable: Ejects a mountable.\n @eject_mountable_finish: Finishes an eject operation.\n @mount_enclosing_volume: Mounts a specified location.\n @mount_enclosing_volume_finish: Finishes mounting a specified location.\n @monitor_dir: Creates a #GFileMonitor for the location.\n @monitor_file: Creates a #GFileMonitor for the location.\n @open_readwrite: Open file read/write. Since 2.22.\n @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.\n @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.\n @create_readwrite: Creates file read/write. Since 2.22.\n @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.\n @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.\n @replace_readwrite: Replaces file read/write. Since 2.22.\n @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.\n @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.\n @start_mountable: Starts a mountable object. Since 2.22.\n @start_mountable_finish: Finishes a start operation. Since 2.22.\n @stop_mountable: Stops a mountable. Since 2.22.\n @stop_mountable_finish: Finishes a stop operation. Since 2.22.\n @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.\n @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.\n @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @poll_mountable: Polls a mountable object for media changes. Since 2.22.\n @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.\n @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38\n\n An interface for writing VFS file handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub hash: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(file1: *mut GFile, file2: *mut GFile) -> gboolean,
    >,
    pub is_native: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> gboolean>,
    pub has_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            uri_scheme: *const ::std::os::raw::c_char,
        ) -> gboolean,
    >,
    pub get_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_basename: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_path: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_uri: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parse_name: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parent: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub prefix_matches: ::std::option::Option<
        unsafe extern "C" fn(prefix: *mut GFile, file: *mut GFile) -> gboolean,
    >,
    pub get_relative_path: ::std::option::Option<
        unsafe extern "C" fn(
            parent: *mut GFile,
            descendant: *mut GFile,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub resolve_relative_path: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            relative_path: *const ::std::os::raw::c_char,
        ) -> *mut GFile,
    >,
    pub get_child_for_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub enumerate_children: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub enumerate_children_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub enumerate_children_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_filesystem_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub find_enclosing_mount: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub find_enclosing_mount_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub find_enclosing_mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub set_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub set_display_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_display_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub query_settable_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_settable_attributes_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_settable_attributes_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub query_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_writable_namespaces_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_writable_namespaces_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub set_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attribute: *const ::std::os::raw::c_char,
            type_: GFileAttributeType,
            value_p: gpointer,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_from_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_attributes_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            info: *mut *mut GFileInfo,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub append_to: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub append_to_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub append_to_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub delete_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub delete_file_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub delete_file_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub trash_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_directory_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_symbolic_link: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_symbolic_link_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_symbolic_link_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub copy_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub move_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub move_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub mount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub unmount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub mount_enclosing_volume: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_enclosing_volume_finish: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub monitor_dir: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub monitor_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub open_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub open_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub open_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub start_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GDriveStartFlags,
            start_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            io_priority: gint,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub measure_disk_usage_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GFileIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileIface>(),
        840usize,
        concat!("Size of: ", stringify!(_GFileIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_native) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(is_native)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_uri_scheme) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(has_uri_scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uri_scheme) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_uri_scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_basename) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_basename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_path) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uri) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parse_name) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_parse_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix_matches) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(prefix_matches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_relative_path) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_relative_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve_relative_path) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(resolve_relative_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_child_for_display_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_child_for_display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_children) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_children_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_children_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_filesystem_info) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_filesystem_info_async) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).query_filesystem_info_finish) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_enclosing_mount) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_enclosing_mount_async) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_enclosing_mount_finish) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_display_name) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_display_name_async) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_display_name_finish) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_settable_attributes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_settable_attributes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_settable_attributes_async) as usize - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_settable_attributes_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_settable_attributes_finish) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_settable_attributes_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_writable_namespaces) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_writable_namespaces)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_writable_namespaces_async) as usize - ptr as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_writable_namespaces_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_writable_namespaces_finish) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_writable_namespaces_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attribute) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attributes_from_info) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_from_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attributes_async) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attributes_finish) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_async) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_finish) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_to) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_to_async) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_to_finish) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_async) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_finish) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_async) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_finish) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_file) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_file_async) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_file_finish) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash_async) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash_finish) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_directory) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_directory_async) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_directory_finish) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_symbolic_link) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_symbolic_link_async) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_symbolic_link_finish) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_async) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_finish) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_async) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_finish) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_mountable) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_mountable_finish) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_mountable) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_mountable_finish) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_mountable) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_mountable_finish) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_enclosing_volume) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_enclosing_volume)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).mount_enclosing_volume_finish) as usize - ptr as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_enclosing_volume_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_dir) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(monitor_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_file) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(monitor_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_readwrite) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_readwrite_async) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_readwrite_finish) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_readwrite) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_readwrite_async) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_readwrite_finish) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_readwrite) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_readwrite_async) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_readwrite_finish) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_mountable) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(start_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_mountable_finish) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(start_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_mountable) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(stop_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_mountable_finish) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(stop_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_thread_contexts) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(supports_thread_contexts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unmount_mountable_with_operation) as usize - ptr as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unmount_mountable_with_operation_finish) as usize
                - ptr as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).eject_mountable_with_operation) as usize - ptr as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).eject_mountable_with_operation_finish) as usize
                - ptr as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_mountable) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(poll_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_mountable_finish) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(poll_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_disk_usage) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_disk_usage_async) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_disk_usage_finish) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage_finish)
        )
    );
}
extern "C" {
    pub fn g_file_get_type() -> GType;
}
extern "C" {
    pub fn g_file_new_for_path(path: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_for_uri(uri: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_for_commandline_arg(arg: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_for_commandline_arg_and_cwd(
        arg: *const gchar,
        cwd: *const gchar,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_tmp(
        tmpl: *const ::std::os::raw::c_char,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_tmp_async(
        tmpl: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_new_tmp_finish(
        result: *mut GAsyncResult,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_tmp_dir_async(
        tmpl: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_new_tmp_dir_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_parse_name(parse_name: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_build_filename(first_element: *const gchar, ...) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_build_filenamev(args: *const *const gchar) -> *mut GFile;
}
extern "C" {
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
}
extern "C" {
    pub fn g_file_hash(file: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_get_basename(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_path(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_peek_path(file: *mut GFile) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_uri(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_parse_name(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
}
extern "C" {
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_get_child(file: *mut GFile, name: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_get_child_for_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_get_relative_path(
        parent: *mut GFile,
        descendant: *mut GFile,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_resolve_relative_path(
        file: *mut GFile,
        relative_path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_has_uri_scheme(
        file: *mut GFile,
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_get_uri_scheme(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_read(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
extern "C" {
    pub fn g_file_read_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_read_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
extern "C" {
    pub fn g_file_append_to(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_create(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_replace(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_append_to_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_append_to_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_create_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_create_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_replace_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_open_readwrite(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_open_readwrite_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_open_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_create_readwrite(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_create_readwrite_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_create_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_replace_readwrite(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_replace_readwrite_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_query_exists(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
}
extern "C" {
    pub fn g_file_query_file_type(
        file: *mut GFile,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
    ) -> GFileType;
}
extern "C" {
    pub fn g_file_query_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_query_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_query_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_query_filesystem_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_query_filesystem_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_query_filesystem_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_find_enclosing_mount(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
extern "C" {
    pub fn g_file_find_enclosing_mount_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_find_enclosing_mount_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
extern "C" {
    pub fn g_file_enumerate_children(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
extern "C" {
    pub fn g_file_enumerate_children_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_enumerate_children_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
extern "C" {
    pub fn g_file_set_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_set_display_name_async(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_set_display_name_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_delete(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_delete_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_delete_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_trash(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_trash_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_trash_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_copy(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_copy_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_copy_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_move(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_move_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_move_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_directory(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_directory_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_make_directory_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_directory_with_parents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_symbolic_link(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_symbolic_link_async(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_make_symbolic_link_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_query_settable_attributes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_query_writable_namespaces(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_set_attribute(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attributes_from_info(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attributes_async(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_set_attributes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        info: *mut *mut GFileInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_byte_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_uint32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_int32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_uint64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_int64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_mount_enclosing_volume(
        location: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_mount_enclosing_volume_finish(
        location: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_mount_mountable(
        file: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_mount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_unmount_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_unmount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_unmount_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_unmount_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_eject_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_eject_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_eject_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_eject_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_build_attribute_list_for_copy(
        file: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_copy_attributes(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_monitor_directory(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    pub fn g_file_monitor_file(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    pub fn g_file_monitor(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    pub fn g_file_measure_disk_usage(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_measure_disk_usage_async(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        io_priority: gint,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_measure_disk_usage_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_start_mountable(
        file: *mut GFile,
        flags: GDriveStartFlags,
        start_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_start_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_stop_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_stop_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_poll_mountable(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_poll_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_query_default_handler(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_file_query_default_handler_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_query_default_handler_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_file_load_contents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_load_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_load_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_load_partial_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        read_more_callback: GFileReadMoreCallback,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_load_partial_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_replace_contents(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        new_etag: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_replace_contents_async(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_contents_bytes_async(
        file: *mut GFile,
        contents: *mut GBytes,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        new_etag: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_load_bytes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        etag_out: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_file_load_bytes_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_load_bytes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        etag_out: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
#[doc = " GFileAttributeInfo:\n @name: the name of the attribute.\n @type: the #GFileAttributeType type of the attribute.\n @flags: a set of #GFileAttributeInfoFlags.\n\n Information about a specific attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileAttributeInfo {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}
#[test]
fn bindgen_test_layout__GFileAttributeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileAttributeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileAttributeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(_GFileAttributeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileAttributeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileAttributeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " GFileAttributeInfoList:\n @infos: an array of #GFileAttributeInfos.\n @n_infos: the number of values in the array.\n\n Acts as a lightweight registry for possible valid file attributes.\n The registry stores Key-Value pair formats as #GFileAttributeInfos."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__GFileAttributeInfoList() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileAttributeInfoList> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileAttributeInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(_GFileAttributeInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileAttributeInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileAttributeInfoList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfoList),
            "::",
            stringify!(infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_infos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfoList),
            "::",
            stringify!(n_infos)
        )
    );
}
extern "C" {
    pub fn g_file_attribute_info_list_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_attribute_info_list_ref(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_attribute_info_list_unref(list: *mut GFileAttributeInfoList);
}
extern "C" {
    pub fn g_file_attribute_info_list_dup(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_attribute_info_list_lookup(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
    ) -> *const GFileAttributeInfo;
}
extern "C" {
    pub fn g_file_attribute_info_list_add(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        flags: GFileAttributeInfoFlags,
    );
}
#[doc = " GFileEnumerator:\n\n A per matched file iterator."]
pub type GFileEnumeratorClass = _GFileEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GFileEnumeratorPrivate = _GFileEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileEnumerator {
    pub parent_instance: GObject,
    pub priv_: *mut GFileEnumeratorPrivate,
}
#[test]
fn bindgen_test_layout__GFileEnumerator() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileEnumerator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileEnumerator>(),
        32usize,
        concat!("Size of: ", stringify!(_GFileEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileEnumerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumerator),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next_file: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub next_files_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            num_files: ::std::os::raw::c_int,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_files_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileEnumeratorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileEnumeratorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileEnumeratorClass>(),
        240usize,
        concat!("Size of: ", stringify!(_GFileEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileEnumeratorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_file) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_files_async) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_files_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_files_finish) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_files_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
}
extern "C" {
    pub fn g_file_enumerator_get_type() -> GType;
}
extern "C" {
    pub fn g_file_enumerator_next_file(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_enumerator_close(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_next_files_async(
        enumerator: *mut GFileEnumerator,
        num_files: ::std::os::raw::c_int,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_enumerator_next_files_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_file_enumerator_close_async(
        enumerator: *mut GFileEnumerator,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_enumerator_close_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator, pending: gboolean);
}
extern "C" {
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator) -> *mut GFile;
}
extern "C" {
    pub fn g_file_enumerator_get_child(
        enumerator: *mut GFileEnumerator,
        info: *mut GFileInfo,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_enumerator_iterate(
        direnum: *mut GFileEnumerator,
        out_info: *mut *mut GFileInfo,
        out_child: *mut *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIconClass {
    _unused: [u8; 0],
}
#[doc = " GFileIcon:\n\n Gets an icon for a #GFile. Implements #GLoadableIcon."]
pub type GFileIconClass = _GFileIconClass;
extern "C" {
    pub fn g_file_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GIcon;
}
extern "C" {
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfoClass {
    _unused: [u8; 0],
}
#[doc = " GFileInfo:\n\n Stores information about a file system object referenced by a #GFile."]
pub type GFileInfoClass = _GFileInfoClass;
extern "C" {
    pub fn g_file_info_get_type() -> GType;
}
extern "C" {
    pub fn g_file_info_new() -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo, dest_info: *mut GFileInfo);
}
extern "C" {
    pub fn g_file_info_has_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_has_namespace(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_list_attributes(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_data(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: *mut GFileAttributeType,
        value_pp: *mut gpointer,
        status: *mut GFileAttributeStatus,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_attribute_type(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeType;
}
extern "C" {
    pub fn g_file_info_remove_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_get_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeStatus;
}
extern "C" {
    pub fn g_file_info_set_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        status: GFileAttributeStatus,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_attribute_as_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint32;
}
extern "C" {
    pub fn g_file_info_get_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint32;
}
extern "C" {
    pub fn g_file_info_get_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint64;
}
extern "C" {
    pub fn g_file_info_get_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint64;
}
extern "C" {
    pub fn g_file_info_get_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut GObject;
}
extern "C" {
    pub fn g_file_info_get_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_file_path(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_set_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gboolean,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint32,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint32,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint64,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint64,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut GObject,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_file_path(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
}
extern "C" {
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
}
extern "C" {
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_display_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
}
extern "C" {
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
}
extern "C" {
    pub fn g_file_info_get_content_type(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> goffset;
}
extern "C" {
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo, result: *mut GTimeVal);
}
extern "C" {
    pub fn g_file_info_get_modification_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_access_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_creation_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_etag(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> gint32;
}
extern "C" {
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo, mask: *mut GFileAttributeMatcher);
}
extern "C" {
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);
}
extern "C" {
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, type_: GFileType);
}
extern "C" {
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo, is_hidden: gboolean);
}
extern "C" {
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo, is_symlink: gboolean);
}
extern "C" {
    pub fn g_file_info_set_name(info: *mut GFileInfo, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_file_info_set_display_name(
        info: *mut GFileInfo,
        display_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_edit_name(
        info: *mut GFileInfo,
        edit_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
extern "C" {
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
extern "C" {
    pub fn g_file_info_set_content_type(
        info: *mut GFileInfo,
        content_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: goffset);
}
extern "C" {
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo, mtime: *mut GTimeVal);
}
extern "C" {
    pub fn g_file_info_set_modification_date_time(info: *mut GFileInfo, mtime: *mut GDateTime);
}
extern "C" {
    pub fn g_file_info_set_access_date_time(info: *mut GFileInfo, atime: *mut GDateTime);
}
extern "C" {
    pub fn g_file_info_set_creation_date_time(info: *mut GFileInfo, creation_time: *mut GDateTime);
}
extern "C" {
    pub fn g_file_info_set_symlink_target(
        info: *mut GFileInfo,
        symlink_target: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo, sort_order: gint32);
}
extern "C" {
    pub fn g_file_attribute_matcher_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_matcher_new(
        attributes: *const ::std::os::raw::c_char,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    pub fn g_file_attribute_matcher_ref(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    pub fn g_file_attribute_matcher_unref(matcher: *mut GFileAttributeMatcher);
}
extern "C" {
    pub fn g_file_attribute_matcher_subtract(
        matcher: *mut GFileAttributeMatcher,
        subtract: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    pub fn g_file_attribute_matcher_matches(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_attribute_matcher_matches_only(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_attribute_matcher_enumerate_namespace(
        matcher: *mut GFileAttributeMatcher,
        ns: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_attribute_matcher_enumerate_next(
        matcher: *mut GFileAttributeMatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_attribute_matcher_to_string(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " GFileInputStream:\n\n A subclass of GInputStream for opened files. This adds\n a few file-specific operations and seeking.\n\n #GFileInputStream implements #GSeekable."]
pub type GFileInputStreamClass = _GFileInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileInputStreamPrivate = _GFileInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GFileInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileInputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GFileInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_file_input_stream_query_info(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_input_stream_query_info_async(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_input_stream_query_info_finish(
        stream: *mut GFileInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_io_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_error_from_errno(err_no: gint) -> GIOErrorEnum;
}
extern "C" {
    pub fn g_io_error_from_file_error(file_error: GFileError) -> GIOErrorEnum;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GIOStreamPrivate = _GIOStreamPrivate;
pub type GIOStreamClass = _GIOStreamClass;
#[doc = " GIOStream:\n\n Base class for read-write streams."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GIOStream {
    pub parent_instance: GObject,
    pub priv_: *mut GIOStreamPrivate,
}
#[test]
fn bindgen_test_layout__GIOStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GIOStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GIOStreamClass {
    pub parent_class: GObjectClass,
    pub get_input_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GInputStream>,
    pub get_output_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GOutputStream>,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GIOStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOStreamClass>(),
        256usize,
        concat!("Size of: ", stringify!(_GIOStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_input_stream) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(get_input_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_output_stream) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(get_output_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved9) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved10) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved10)
        )
    );
}
extern "C" {
    pub fn g_io_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream) -> *mut GInputStream;
}
extern "C" {
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_io_stream_splice_async(
        stream1: *mut GIOStream,
        stream2: *mut GIOStream,
        flags: GIOStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_io_stream_splice_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_close(
        stream: *mut GIOStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_close_async(
        stream: *mut GIOStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_io_stream_close_finish(
        stream: *mut GIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_set_pending(stream: *mut GIOStream, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
}
#[doc = " GFileIOStream:\n\n A subclass of GIOStream for opened files. This adds\n a few file-specific operations and seeking and truncating.\n\n #GFileIOStream implements GSeekable."]
pub type GFileIOStreamClass = _GFileIOStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileIOStreamPrivate = _GFileIOStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileIOStream {
    pub parent_instance: GIOStream,
    pub priv_: *mut GFileIOStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileIOStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileIOStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileIOStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileIOStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIOStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIOStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileIOStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileIOStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileIOStreamClass>(),
        368usize,
        concat!("Size of: ", stringify!(_GFileIOStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIOStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIOStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_truncate) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_fn) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(truncate_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_etag) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(get_etag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_io_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_file_io_stream_query_info(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_io_stream_query_info_async(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_io_stream_query_info_finish(
        stream: *mut GFileIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char;
}
pub type GFileMonitorClass = _GFileMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorPrivate {
    _unused: [u8; 0],
}
pub type GFileMonitorPrivate = _GFileMonitorPrivate;
#[doc = " GFileMonitor:\n\n Watches for changes to a file."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileMonitor {
    pub parent_instance: GObject,
    pub priv_: *mut GFileMonitorPrivate,
}
#[test]
fn bindgen_test_layout__GFileMonitor() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileMonitor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GFileMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileMonitor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitor),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileMonitorClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GFileMonitor,
            file: *mut GFile,
            other_file: *mut GFile,
            event_type: GFileMonitorEvent,
        ),
    >,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(monitor: *mut GFileMonitor) -> gboolean>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileMonitorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileMonitorClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileMonitorClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GFileMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileMonitorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
}
extern "C" {
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor) -> gboolean;
}
extern "C" {
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor, limit_msecs: gint);
}
extern "C" {
    pub fn g_file_monitor_emit_event(
        monitor: *mut GFileMonitor,
        child: *mut GFile,
        other_file: *mut GFile,
        event_type: GFileMonitorEvent,
    );
}
#[doc = " GFilenameCompleter:\n\n Completes filenames based on files that exist within the file system."]
pub type GFilenameCompleterClass = _GFilenameCompleterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFilenameCompleterClass {
    pub parent_class: GObjectClass,
    pub got_completion_data:
        ::std::option::Option<unsafe extern "C" fn(filename_completer: *mut GFilenameCompleter)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilenameCompleterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilenameCompleterClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilenameCompleterClass>(),
        168usize,
        concat!("Size of: ", stringify!(_GFilenameCompleterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilenameCompleterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilenameCompleterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).got_completion_data) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(got_completion_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_filename_completer_get_type() -> GType;
}
extern "C" {
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
}
extern "C" {
    pub fn g_filename_completer_get_completion_suffix(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_filename_completer_get_completions(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_filename_completer_set_dirs_only(
        completer: *mut GFilenameCompleter,
        dirs_only: gboolean,
    );
}
#[doc = " GFileOutputStream:\n\n A subclass of GOutputStream for opened files. This adds\n a few file-specific operations and seeking and truncating.\n\n #GFileOutputStream implements GSeekable."]
pub type GFileOutputStreamClass = _GFileOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileOutputStreamPrivate = _GFileOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GFileOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileOutputStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileOutputStreamClass>(),
        408usize,
        concat!("Size of: ", stringify!(_GFileOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_truncate) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_fn) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(truncate_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_etag) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(get_etag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_file_output_stream_query_info(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_output_stream_query_info_async(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_output_stream_query_info_finish(
        stream: *mut GFileOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_output_stream_get_etag(
        stream: *mut GFileOutputStream,
    ) -> *mut ::std::os::raw::c_char;
}
pub type GInetAddressClass = _GInetAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressPrivate = _GInetAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInetAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressPrivate,
}
#[test]
fn bindgen_test_layout__GInetAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInetAddressClass {
    pub parent_class: GObjectClass,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *mut gchar>,
    pub to_bytes:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *const guint8>,
}
#[test]
fn bindgen_test_layout__GInetAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddressClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressClass>(),
        152usize,
        concat!("Size of: ", stringify!(_GInetAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_string) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(to_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_bytes) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(to_bytes)
        )
    );
}
extern "C" {
    pub fn g_inet_address_get_type() -> GType;
}
extern "C" {
    pub fn g_inet_address_new_from_string(string: *const gchar) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_new_from_bytes(
        bytes: *const guint8,
        family: GSocketFamily,
    ) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_new_loopback(family: GSocketFamily) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_equal(
        address: *mut GInetAddress,
        other_address: *mut GInetAddress,
    ) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut gchar;
}
extern "C" {
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress) -> *const guint8;
}
extern "C" {
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress) -> gsize;
}
extern "C" {
    pub fn g_inet_address_get_family(address: *mut GInetAddress) -> GSocketFamily;
}
extern "C" {
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress) -> gboolean;
}
pub type GInetAddressMaskClass = _GInetAddressMaskClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressMaskPrivate = _GInetAddressMaskPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInetAddressMask {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressMaskPrivate,
}
#[test]
fn bindgen_test_layout__GInetAddressMask() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddressMask> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressMask>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetAddressMask))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressMask>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressMask))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMask),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMask),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInetAddressMaskClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GInetAddressMaskClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddressMaskClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressMaskClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GInetAddressMaskClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressMaskClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressMaskClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMaskClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_inet_address_mask_get_type() -> GType;
}
extern "C" {
    pub fn g_inet_address_mask_new(
        addr: *mut GInetAddress,
        length: guint,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
extern "C" {
    pub fn g_inet_address_mask_new_from_string(
        mask_string: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
extern "C" {
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask) -> *mut gchar;
}
extern "C" {
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask) -> GSocketFamily;
}
extern "C" {
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask) -> guint;
}
extern "C" {
    pub fn g_inet_address_mask_matches(
        mask: *mut GInetAddressMask,
        address: *mut GInetAddress,
    ) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_mask_equal(
        mask: *mut GInetAddressMask,
        mask2: *mut GInetAddressMask,
    ) -> gboolean;
}
pub type GSocketAddressClass = _GSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketAddress {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddress>(),
        24usize,
        concat!("Size of: ", stringify!(_GSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketAddressClass {
    pub parent_class: GObjectClass,
    pub get_family:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> GSocketFamily>,
    pub get_native_size:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> gssize>,
    pub to_native: ::std::option::Option<
        unsafe extern "C" fn(
            address: *mut GSocketAddress,
            dest: gpointer,
            destlen: gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddressClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_family) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(get_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_native_size) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(get_native_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_native) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(to_native)
        )
    );
}
extern "C" {
    pub fn g_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_address_get_family(address: *mut GSocketAddress) -> GSocketFamily;
}
extern "C" {
    pub fn g_socket_address_new_from_native(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_address_to_native(
        address: *mut GSocketAddress,
        dest: gpointer,
        destlen: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress) -> gssize;
}
pub type GInetSocketAddressClass = _GInetSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetSocketAddressPrivate = _GInetSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GInetSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GInetSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetSocketAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GInetSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetSocketAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GInetSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_inet_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_inet_socket_address_new(
        address: *mut GInetAddress,
        port: guint16,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_inet_socket_address_new_from_string(
        address: *const ::std::os::raw::c_char,
        port: guint,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress)
        -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress) -> guint16;
}
extern "C" {
    pub fn g_inet_socket_address_get_flowinfo(address: *mut GInetSocketAddress) -> guint32;
}
extern "C" {
    pub fn g_inet_socket_address_get_scope_id(address: *mut GInetSocketAddress) -> guint32;
}
extern "C" {
    pub fn g_app_info_create_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_result_get_type() -> GType;
}
extern "C" {
    pub fn g_data_stream_byte_order_get_type() -> GType;
}
extern "C" {
    pub fn g_data_stream_newline_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_info_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_status_get_type() -> GType;
}
extern "C" {
    pub fn g_file_query_info_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_create_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_measure_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_mount_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_unmount_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_drive_start_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_drive_start_stop_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_copy_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_monitor_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_type_get_type() -> GType;
}
extern "C" {
    pub fn g_filesystem_preview_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_monitor_event_get_type() -> GType;
}
extern "C" {
    pub fn g_io_error_enum_get_type() -> GType;
}
extern "C" {
    pub fn g_ask_password_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_password_save_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_operation_result_get_type() -> GType;
}
extern "C" {
    pub fn g_output_stream_splice_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_io_stream_splice_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_emblem_origin_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_error_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_record_type_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_error_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_lookup_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_family_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_type_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_msg_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_protocol_get_type() -> GType;
}
extern "C" {
    pub fn g_zlib_compressor_format_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_socket_address_type_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_type_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_name_owner_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_name_watcher_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_proxy_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_error_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_connection_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_capability_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_call_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_type_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_header_field_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_property_info_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_subtree_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_server_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_signal_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_send_message_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_credentials_type_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_byte_order_get_type() -> GType;
}
extern "C" {
    pub fn g_application_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_error_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_certificate_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_authentication_mode_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_channel_binding_type_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_channel_binding_error_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_rehandshake_mode_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_password_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_interaction_result_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_client_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_database_verify_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_database_lookup_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_certificate_request_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_protocol_version_get_type() -> GType;
}
extern "C" {
    pub fn g_io_module_scope_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_client_event_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_listener_event_get_type() -> GType;
}
extern "C" {
    pub fn g_test_dbus_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_subprocess_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_notification_priority_get_type() -> GType;
}
extern "C" {
    pub fn g_network_connectivity_get_type() -> GType;
}
extern "C" {
    pub fn g_pollable_return_get_type() -> GType;
}
extern "C" {
    pub fn g_memory_monitor_warning_level_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_name_lookup_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_bind_flags_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleScope {
    _unused: [u8; 0],
}
pub type GIOModuleScope = _GIOModuleScope;
extern "C" {
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags) -> *mut GIOModuleScope;
}
extern "C" {
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
}
extern "C" {
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope, basename: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleClass {
    _unused: [u8; 0],
}
#[doc = " GIOModule:\n\n Opaque module base class for extending GIO."]
pub type GIOModuleClass = _GIOModuleClass;
extern "C" {
    pub fn g_io_module_get_type() -> GType;
}
extern "C" {
    pub fn g_io_module_new(filename: *const gchar) -> *mut GIOModule;
}
extern "C" {
    pub fn g_io_modules_scan_all_in_directory(dirname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_io_modules_load_all_in_directory(dirname: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn g_io_modules_scan_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    );
}
extern "C" {
    pub fn g_io_modules_load_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_io_extension_point_register(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
extern "C" {
    pub fn g_io_extension_point_lookup(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
extern "C" {
    pub fn g_io_extension_point_set_required_type(
        extension_point: *mut GIOExtensionPoint,
        type_: GType,
    );
}
extern "C" {
    pub fn g_io_extension_point_get_required_type(extension_point: *mut GIOExtensionPoint)
        -> GType;
}
extern "C" {
    pub fn g_io_extension_point_get_extensions(
        extension_point: *mut GIOExtensionPoint,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_io_extension_point_get_extension_by_name(
        extension_point: *mut GIOExtensionPoint,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtension;
}
extern "C" {
    pub fn g_io_extension_point_implement(
        extension_point_name: *const ::std::os::raw::c_char,
        type_: GType,
        extension_name: *const ::std::os::raw::c_char,
        priority: gint,
    ) -> *mut GIOExtension;
}
extern "C" {
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
}
extern "C" {
    pub fn g_io_extension_get_name(extension: *mut GIOExtension) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> gint;
}
extern "C" {
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension) -> *mut GTypeClass;
}
extern "C" {
    #[doc = " g_io_module_load: (skip)\n @module: a #GIOModule.\n\n Required API for GIO modules to implement.\n\n This function is run after the module has been loaded into GIO,\n to initialize the module. Typically, this function will call\n g_io_extension_point_implement().\n\n Since 2.56, this function should be named `g_io_<modulename>_load`, where\n `modulename` is the plugins filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds."]
    pub fn g_io_module_load(module: *mut GIOModule);
}
extern "C" {
    #[doc = " g_io_module_unload: (skip)\n @module: a #GIOModule.\n\n Required API for GIO modules to implement.\n\n This function is run when the module is being unloaded from GIO,\n to finalize the module.\n\n Since 2.56, this function should be named `g_io_<modulename>_unload`, where\n `modulename` is the plugins filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds."]
    pub fn g_io_module_unload(module: *mut GIOModule);
}
extern "C" {
    #[doc = " g_io_module_query:\n\n Optional API for GIO modules to implement.\n\n Should return a list of all the extension points that may be\n implemented in this module.\n\n This method will not be called in normal use, however it may be\n called when probing existing modules and recording which extension\n points that this model is used for. This means we won't have to\n load and initialize this module unless its needed.\n\n If this function is not implemented by the module the module will\n always be loaded, initialized and then unloaded on application\n startup so that it can register its extension points during init.\n\n Note that a module need not actually implement all the extension\n points that g_io_module_query() returns, since the exact list of\n extension may depend on runtime issues. However all extension\n points actually implemented must be returned by g_io_module_query()\n (if defined).\n\n When installing a module that implements g_io_module_query() you must\n run gio-querymodules in order to build the cache files required for\n lazy loading.\n\n Since 2.56, this function should be named `g_io_<modulename>_query`, where\n `modulename` is the plugins filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds.\n\n Returns: (transfer full): A %NULL-terminated array of strings,\n     listing the supported extension points of the module. The array\n     must be suitable for freeing with g_strfreev().\n\n Since: 2.24"]
    pub fn g_io_module_query() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_io_scheduler_push_job(
        job_func: GIOSchedulerJobFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
        io_priority: gint,
        cancellable: *mut GCancellable,
    );
}
extern "C" {
    pub fn g_io_scheduler_cancel_all_jobs();
}
extern "C" {
    pub fn g_io_scheduler_job_send_to_mainloop(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_scheduler_job_send_to_mainloop_async(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_list_model_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModel {
    _unused: [u8; 0],
}
pub type GListModel = _GListModel;
pub type GListModelInterface = _GListModelInterface;
pub type GListModel_autoptr = *mut GListModel;
pub type GListModel_listautoptr = *mut GList;
pub type GListModel_slistautoptr = *mut GSList;
pub type GListModel_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GListModelInterface {
    pub g_iface: GTypeInterface,
    pub get_item_type: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> GType>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> guint>,
    pub get_item: ::std::option::Option<
        unsafe extern "C" fn(list: *mut GListModel, position: guint) -> gpointer,
    >,
}
#[test]
fn bindgen_test_layout__GListModelInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GListModelInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GListModelInterface>(),
        40usize,
        concat!("Size of: ", stringify!(_GListModelInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GListModelInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GListModelInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_item_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_n_items) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_n_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_item)
        )
    );
}
extern "C" {
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
}
extern "C" {
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> guint;
}
extern "C" {
    pub fn g_list_model_get_item(list: *mut GListModel, position: guint) -> gpointer;
}
extern "C" {
    pub fn g_list_model_get_object(list: *mut GListModel, position: guint) -> *mut GObject;
}
extern "C" {
    pub fn g_list_model_items_changed(
        list: *mut GListModel,
        position: guint,
        removed: guint,
        added: guint,
    );
}
extern "C" {
    pub fn g_list_store_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListStore {
    _unused: [u8; 0],
}
pub type GListStore = _GListStore;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct GListStoreClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout_GListStoreClass() {
    const UNINIT: ::std::mem::MaybeUninit<GListStoreClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GListStoreClass>(),
        136usize,
        concat!("Size of: ", stringify!(GListStoreClass))
    );
    assert_eq!(
        ::std::mem::align_of::<GListStoreClass>(),
        8usize,
        concat!("Alignment of ", stringify!(GListStoreClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GListStoreClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type GListStore_autoptr = *mut GListStore;
pub type GListStore_listautoptr = *mut GList;
pub type GListStore_slistautoptr = *mut GSList;
pub type GListStore_queueautoptr = *mut GQueue;
pub type GListStoreClass_autoptr = *mut GListStoreClass;
pub type GListStoreClass_listautoptr = *mut GList;
pub type GListStoreClass_slistautoptr = *mut GSList;
pub type GListStoreClass_queueautoptr = *mut GQueue;
extern "C" {
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
}
extern "C" {
    pub fn g_list_store_insert(store: *mut GListStore, position: guint, item: gpointer);
}
extern "C" {
    pub fn g_list_store_insert_sorted(
        store: *mut GListStore,
        item: gpointer,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_list_store_sort(
        store: *mut GListStore,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_list_store_append(store: *mut GListStore, item: gpointer);
}
extern "C" {
    pub fn g_list_store_remove(store: *mut GListStore, position: guint);
}
extern "C" {
    pub fn g_list_store_remove_all(store: *mut GListStore);
}
extern "C" {
    pub fn g_list_store_splice(
        store: *mut GListStore,
        position: guint,
        n_removals: guint,
        additions: *mut gpointer,
        n_additions: guint,
    );
}
extern "C" {
    pub fn g_list_store_find(
        store: *mut GListStore,
        item: gpointer,
        position: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_list_store_find_with_equal_func(
        store: *mut GListStore,
        item: gpointer,
        equal_func: GEqualFunc,
        position: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_list_store_find_with_equal_func_full(
        store: *mut GListStore,
        item: gpointer,
        equal_func: GEqualFuncFull,
        user_data: gpointer,
        position: *mut guint,
    ) -> gboolean;
}
#[doc = " GLoadableIcon:\n\n Generic type for all kinds of icons that can be loaded\n as a stream."]
pub type GLoadableIconIface = _GLoadableIconIface;
#[doc = " GLoadableIconIface:\n @g_iface: The parent interface.\n @load: Loads an icon.\n @load_async: Loads an icon asynchronously.\n @load_finish: Finishes an asynchronous icon load.\n\n Interface for icons that can be loaded as a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GLoadableIconIface {
    pub g_iface: GTypeInterface,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            type_: *mut *mut ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
    pub load_async: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub load_finish: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            res: *mut GAsyncResult,
            type_: *mut *mut ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
}
#[test]
fn bindgen_test_layout__GLoadableIconIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GLoadableIconIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GLoadableIconIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GLoadableIconIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLoadableIconIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLoadableIconIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_async) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_finish) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load_finish)
        )
    );
}
extern "C" {
    pub fn g_loadable_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_loadable_icon_load(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        type_: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_loadable_icon_load_async(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_loadable_icon_load_finish(
        icon: *mut GLoadableIcon,
        res: *mut GAsyncResult,
        type_: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
#[doc = " GMemoryInputStream:\n\n Implements #GInputStream for arbitrary memory chunks."]
pub type GMemoryInputStreamClass = _GMemoryInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMemoryInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GMemoryInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GMemoryInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GMemoryInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMemoryInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryInputStreamClass>(),
        288usize,
        concat!("Size of: ", stringify!(_GMemoryInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_memory_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
}
extern "C" {
    pub fn g_memory_input_stream_new_from_data(
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut GBytes) -> *mut GInputStream;
}
extern "C" {
    pub fn g_memory_input_stream_add_data(
        stream: *mut GMemoryInputStream,
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream, bytes: *mut GBytes);
}
extern "C" {
    pub fn g_memory_monitor_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryMonitor {
    _unused: [u8; 0],
}
pub type GMemoryMonitor = _GMemoryMonitor;
pub type GMemoryMonitorInterface = _GMemoryMonitorInterface;
pub type GMemoryMonitor_autoptr = *mut GMemoryMonitor;
pub type GMemoryMonitor_listautoptr = *mut GList;
pub type GMemoryMonitor_slistautoptr = *mut GSList;
pub type GMemoryMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMemoryMonitorInterface {
    pub g_iface: GTypeInterface,
    pub low_memory_warning: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GMemoryMonitor, level: GMemoryMonitorWarningLevel),
    >,
}
#[test]
fn bindgen_test_layout__GMemoryMonitorInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryMonitorInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryMonitorInterface>(),
        24usize,
        concat!("Size of: ", stringify!(_GMemoryMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryMonitorInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_memory_warning) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryMonitorInterface),
            "::",
            stringify!(low_memory_warning)
        )
    );
}
extern "C" {
    pub fn g_memory_monitor_dup_default() -> *mut GMemoryMonitor;
}
#[doc = " GMemoryOutputStream:\n\n Implements #GOutputStream for arbitrary memory chunks."]
pub type GMemoryOutputStreamClass = _GMemoryOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GMemoryOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GMemoryOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GMemoryOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMemoryOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryOutputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GMemoryOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[doc = " GReallocFunc:\n @data: memory block to reallocate\n @size: size to reallocate @data to\n\n Changes the size of the memory block pointed to by @data to\n @size bytes.\n\n The function should have the same semantics as realloc().\n\n Returns: a pointer to the reallocated memory"]
pub type GReallocFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, size: gsize) -> gpointer>;
extern "C" {
    pub fn g_memory_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_memory_output_stream_new(
        data: gpointer,
        size: gsize,
        realloc_function: GReallocFunc,
        destroy_function: GDestroyNotify,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
}
extern "C" {
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
extern "C" {
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
extern "C" {
    pub fn g_memory_output_stream_get_data_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
extern "C" {
    pub fn g_memory_output_stream_steal_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
extern "C" {
    pub fn g_memory_output_stream_steal_as_bytes(ostream: *mut GMemoryOutputStream) -> *mut GBytes;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelPrivate {
    _unused: [u8; 0],
}
pub type GMenuModelPrivate = _GMenuModelPrivate;
#[doc = " GMenuModelClass::get_item_attributes:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item\n\n Gets all the attributes associated with the item in the menu model.\n/\n/**\n GMenuModelClass::get_item_links:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @links: (out) (element-type utf8 Gio.MenuModel): Links from the item\n\n Gets all the links associated with the item in the menu model."]
pub type GMenuModelClass = _GMenuModelClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate;
pub type GMenuAttributeIterClass = _GMenuAttributeIterClass;
pub type GMenuAttributeIter = _GMenuAttributeIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuLinkIterPrivate = _GMenuLinkIterPrivate;
pub type GMenuLinkIterClass = _GMenuLinkIterClass;
pub type GMenuLinkIter = _GMenuLinkIter;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMenuModel {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuModelPrivate,
}
#[test]
fn bindgen_test_layout__GMenuModel() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuModel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuModel>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuModel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuModel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuModel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModel),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModel),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GMenuModelClass::get_item_attributes:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item\n\n Gets all the attributes associated with the item in the menu model.\n/\n/**\n GMenuModelClass::get_item_links:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @links: (out) (element-type utf8 Gio.MenuModel): Links from the item\n\n Gets all the links associated with the item in the menu model."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMenuModelClass {
    pub parent_class: GObjectClass,
    pub is_mutable: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gboolean>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gint>,
    pub get_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attributes: *mut *mut GHashTable,
        ),
    >,
    pub iterate_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuAttributeIter,
    >,
    pub get_item_attribute_value: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attribute: *const gchar,
            expected_type: *const GVariantType,
        ) -> *mut GVariant,
    >,
    pub get_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint, links: *mut *mut GHashTable),
    >,
    pub iterate_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuLinkIter,
    >,
    pub get_item_link: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            link: *const gchar,
        ) -> *mut GMenuModel,
    >,
}
#[test]
fn bindgen_test_layout__GMenuModelClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuModelClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuModelClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GMenuModelClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuModelClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuModelClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_mutable) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(is_mutable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_n_items) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_n_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_attributes) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterate_item_attributes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(iterate_item_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_attribute_value) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_attribute_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_links) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterate_item_links) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(iterate_item_links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_link) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_link)
        )
    );
}
extern "C" {
    pub fn g_menu_model_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
}
extern "C" {
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> gint;
}
extern "C" {
    pub fn g_menu_model_iterate_item_attributes(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuAttributeIter;
}
extern "C" {
    pub fn g_menu_model_get_item_attribute_value(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_menu_model_get_item_attribute(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_model_iterate_item_links(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuLinkIter;
}
extern "C" {
    pub fn g_menu_model_get_item_link(
        model: *mut GMenuModel,
        item_index: gint,
        link: *const gchar,
    ) -> *mut GMenuModel;
}
extern "C" {
    pub fn g_menu_model_items_changed(
        model: *mut GMenuModel,
        position: gint,
        removed: gint,
        added: gint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMenuAttributeIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuAttributeIterPrivate,
}
#[test]
fn bindgen_test_layout__GMenuAttributeIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuAttributeIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuAttributeIter>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuAttributeIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuAttributeIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuAttributeIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIter),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIter),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMenuAttributeIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuAttributeIter,
            out_name: *mut *const gchar,
            value: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GMenuAttributeIterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuAttributeIterClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuAttributeIterClass>(),
        144usize,
        concat!("Size of: ", stringify!(_GMenuAttributeIterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuAttributeIterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuAttributeIterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIterClass),
            "::",
            stringify!(get_next)
        )
    );
}
extern "C" {
    pub fn g_menu_attribute_iter_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_attribute_iter_get_next(
        iter: *mut GMenuAttributeIter,
        out_name: *mut *const gchar,
        value: *mut *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter) -> gboolean;
}
extern "C" {
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter) -> *const gchar;
}
extern "C" {
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter) -> *mut GVariant;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMenuLinkIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuLinkIterPrivate,
}
#[test]
fn bindgen_test_layout__GMenuLinkIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuLinkIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuLinkIter>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuLinkIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuLinkIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuLinkIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIter),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIter),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMenuLinkIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuLinkIter,
            out_link: *mut *const gchar,
            value: *mut *mut GMenuModel,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GMenuLinkIterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuLinkIterClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuLinkIterClass>(),
        144usize,
        concat!("Size of: ", stringify!(_GMenuLinkIterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuLinkIterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuLinkIterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIterClass),
            "::",
            stringify!(get_next)
        )
    );
}
extern "C" {
    pub fn g_menu_link_iter_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_link_iter_get_next(
        iter: *mut GMenuLinkIter,
        out_link: *mut *const gchar,
        value: *mut *mut GMenuModel,
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;
}
extern "C" {
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter) -> *const gchar;
}
extern "C" {
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter) -> *mut GMenuModel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuItem {
    _unused: [u8; 0],
}
pub type GMenuItem = _GMenuItem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenu {
    _unused: [u8; 0],
}
pub type GMenu = _GMenu;
extern "C" {
    pub fn g_menu_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_new() -> *mut GMenu;
}
extern "C" {
    pub fn g_menu_freeze(menu: *mut GMenu);
}
extern "C" {
    pub fn g_menu_insert_item(menu: *mut GMenu, position: gint, item: *mut GMenuItem);
}
extern "C" {
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
}
extern "C" {
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
}
extern "C" {
    pub fn g_menu_remove(menu: *mut GMenu, position: gint);
}
extern "C" {
    pub fn g_menu_remove_all(menu: *mut GMenu);
}
extern "C" {
    pub fn g_menu_insert(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
extern "C" {
    pub fn g_menu_append(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
extern "C" {
    pub fn g_menu_insert_section(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        section: *mut GMenuModel,
    );
}
extern "C" {
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_insert_submenu(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        submenu: *mut GMenuModel,
    );
}
extern "C" {
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_item_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_item_new(label: *const gchar, detailed_action: *const gchar) -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel, item_index: gint) -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_new_submenu(label: *const gchar, submenu: *mut GMenuModel)
        -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_new_section(label: *const gchar, section: *mut GMenuModel)
        -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_get_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_menu_item_get_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const gchar) -> *mut GMenuModel;
}
extern "C" {
    pub fn g_menu_item_set_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_menu_item_set_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_menu_item_set_link(
        menu_item: *mut GMenuItem,
        link: *const gchar,
        model: *mut GMenuModel,
    );
}
extern "C" {
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem, label: *const gchar);
}
extern "C" {
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem, submenu: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem, section: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_item_set_action_and_target_value(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        target_value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_menu_item_set_action_and_target(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_menu_item_set_detailed_action(
        menu_item: *mut GMenuItem,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
}
extern "C" {
    pub fn g_dbus_connection_export_menu_model(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        menu: *mut GMenuModel,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unexport_menu_model(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
#[doc = " GMountIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the mount's state has changed.\n @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.\n @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.\n @get_root: Gets a #GFile to the root directory of the #GMount.\n @get_name: Gets a string containing the name of the #GMount.\n @get_icon: Gets a #GIcon for the #GMount.\n @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.\n @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.\n @can_unmount: Checks if a #GMount can be unmounted.\n @can_eject: Checks if a #GMount can be ejected.\n @unmount: Starts unmounting a #GMount.\n @unmount_finish: Finishes an unmounting operation.\n @eject: Starts ejecting a #GMount.\n @eject_finish: Finishes an eject operation.\n @remount: Starts remounting a #GMount.\n @remount_finish: Finishes a remounting operation.\n @guess_content_type: Starts guessing the type of the content of a #GMount.\n     See g_mount_guess_content_type() for more information on content\n     type guessing. This operation was added in 2.18.\n @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.\n @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18\n @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.\n @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.\n @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.\n @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.\n\n Interface for implementing operations for mounts."]
pub type GMountIface = _GMountIface;
#[doc = " GMountIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the mount's state has changed.\n @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.\n @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.\n @get_root: Gets a #GFile to the root directory of the #GMount.\n @get_name: Gets a string containing the name of the #GMount.\n @get_icon: Gets a #GIcon for the #GMount.\n @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.\n @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.\n @can_unmount: Checks if a #GMount can be unmounted.\n @can_eject: Checks if a #GMount can be ejected.\n @unmount: Starts unmounting a #GMount.\n @unmount_finish: Finishes an unmounting operation.\n @eject: Starts ejecting a #GMount.\n @eject_finish: Finishes an eject operation.\n @remount: Starts remounting a #GMount.\n @remount_finish: Finishes a remounting operation.\n @guess_content_type: Starts guessing the type of the content of a #GMount.\n     See g_mount_guess_content_type() for more information on content\n     type guessing. This operation was added in 2.18.\n @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.\n @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18\n @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.\n @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.\n @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.\n @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.\n\n Interface for implementing operations for mounts."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMountIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmounted: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub get_root: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_volume: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GVolume>,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GDrive>,
    pub can_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub unmount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub remount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub remount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub guess_content_type: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub guess_content_type_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub guess_content_type_sync: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub pre_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmount_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_default_location:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
}
#[test]
fn bindgen_test_layout__GMountIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GMountIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMountIface>(),
        232usize,
        concat!("Size of: ", stringify!(_GMountIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmounted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmounted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_root) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uuid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volume) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_drive) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_unmount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(can_unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_eject) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_finish) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_finish) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remount) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(remount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remount_finish) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(remount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guess_content_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guess_content_type_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guess_content_type_sync) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_unmount) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(pre_unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_with_operation) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unmount_with_operation_finish) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation_finish) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_default_location) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_default_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sort_key) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_symbolic_icon) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
}
extern "C" {
    pub fn g_mount_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
}
extern "C" {
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
}
extern "C" {
    pub fn g_mount_get_name(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
}
extern "C" {
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
}
extern "C" {
    pub fn g_mount_get_uuid(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
}
extern "C" {
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
}
extern "C" {
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
}
extern "C" {
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
}
extern "C" {
    pub fn g_mount_unmount(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_unmount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_eject(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_eject_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_remount(
        mount: *mut GMount,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_remount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_guess_content_type(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_guess_content_type_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_mount_guess_content_type_sync(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
}
extern "C" {
    pub fn g_mount_shadow(mount: *mut GMount);
}
extern "C" {
    pub fn g_mount_unshadow(mount: *mut GMount);
}
extern "C" {
    pub fn g_mount_unmount_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_unmount_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_eject_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_eject_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const gchar;
}
#[doc = " GMountOperation:\n\n Class for providing authentication methods for mounting operations,\n such as mounting a file locally, or authenticating with a server."]
pub type GMountOperationClass = _GMountOperationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationPrivate {
    _unused: [u8; 0],
}
pub type GMountOperationPrivate = _GMountOperationPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMountOperation {
    pub parent_instance: GObject,
    pub priv_: *mut GMountOperationPrivate,
}
#[test]
fn bindgen_test_layout__GMountOperation() {
    const UNINIT: ::std::mem::MaybeUninit<_GMountOperation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMountOperation>(),
        32usize,
        concat!("Size of: ", stringify!(_GMountOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountOperation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperation),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperation),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GMountOperationClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            default_user: *const ::std::os::raw::c_char,
            default_domain: *const ::std::os::raw::c_char,
            flags: GAskPasswordFlags,
        ),
    >,
    #[doc = " GMountOperationClass::ask_question:\n @op: a #GMountOperation\n @message: string containing a message to display to the user\n @choices: (array zero-terminated=1) (element-type utf8): an array of\n    strings for each possible choice\n\n Virtual implementation of #GMountOperation::ask-question."]
    pub ask_question: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            choices: *mut *const ::std::os::raw::c_char,
        ),
    >,
    pub reply: ::std::option::Option<
        unsafe extern "C" fn(op: *mut GMountOperation, result: GMountOperationResult),
    >,
    pub aborted: ::std::option::Option<unsafe extern "C" fn(op: *mut GMountOperation)>,
    #[doc = " GMountOperationClass::show_processes:\n @op: a #GMountOperation\n @message: string containing a message to display to the user\n @processes: (element-type GPid): an array of #GPid for processes blocking\n    the operation\n @choices: (array zero-terminated=1) (element-type utf8): an array of\n    strings for each possible choice\n\n Virtual implementation of #GMountOperation::show-processes.\n\n Since: 2.22"]
    pub show_processes: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            processes: *mut GArray,
            choices: *mut *const gchar,
        ),
    >,
    pub show_unmount_progress: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            time_left: gint64,
            bytes_left: gint64,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMountOperationClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMountOperationClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMountOperationClass>(),
        256usize,
        concat!("Size of: ", stringify!(_GMountOperationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountOperationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountOperationClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(ask_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_question) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(ask_question)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aborted) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(aborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_processes) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(show_processes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_unmount_progress) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(show_unmount_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved9) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
}
extern "C" {
    pub fn g_mount_operation_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_operation_new() -> *mut GMountOperation;
}
extern "C" {
    pub fn g_mount_operation_get_username(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_operation_set_username(
        op: *mut GMountOperation,
        username: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_mount_operation_get_password(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_operation_set_password(
        op: *mut GMountOperation,
        password: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation, anonymous: gboolean);
}
extern "C" {
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_operation_set_domain(
        op: *mut GMountOperation,
        domain: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation) -> GPasswordSave;
}
extern "C" {
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation, save: GPasswordSave);
}
extern "C" {
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation, choice: ::std::os::raw::c_int);
}
extern "C" {
    pub fn g_mount_operation_reply(op: *mut GMountOperation, result: GMountOperationResult);
}
extern "C" {
    pub fn g_mount_operation_get_is_tcrypt_hidden_volume(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    pub fn g_mount_operation_set_is_tcrypt_hidden_volume(
        op: *mut GMountOperation,
        hidden_volume: gboolean,
    );
}
extern "C" {
    pub fn g_mount_operation_get_is_tcrypt_system_volume(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    pub fn g_mount_operation_set_is_tcrypt_system_volume(
        op: *mut GMountOperation,
        system_volume: gboolean,
    );
}
extern "C" {
    pub fn g_mount_operation_get_pim(op: *mut GMountOperation) -> guint;
}
extern "C" {
    pub fn g_mount_operation_set_pim(op: *mut GMountOperation, pim: guint);
}
pub type GNativeSocketAddressClass = _GNativeSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GNativeSocketAddressPrivate = _GNativeSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNativeSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GNativeSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GNativeSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeSocketAddress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GNativeSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNativeSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GNativeSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeSocketAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GNativeSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_native_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_native_socket_address_new(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
#[doc = " GVolumeMonitor:\n\n A Volume Monitor that watches for volume events."]
pub type GVolumeMonitorClass = _GVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVolumeMonitor {
    pub parent_instance: GObject,
    pub priv_: gpointer,
}
#[test]
fn bindgen_test_layout__GVolumeMonitor() {
    const UNINIT: ::std::mem::MaybeUninit<_GVolumeMonitor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVolumeMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GVolumeMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeMonitor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitor),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVolumeMonitorClass {
    pub parent_class: GObjectClass,
    pub volume_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub mount_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_pre_unmount: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub drive_connected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_disconnected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub is_supported: ::std::option::Option<unsafe extern "C" fn() -> gboolean>,
    pub get_connected_drives: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volumes: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_mounts: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volume_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GVolume,
    >,
    pub get_mount_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GMount,
    >,
    pub adopt_orphan_mount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            volume_monitor: *mut GVolumeMonitor,
        ) -> *mut GVolume,
    >,
    pub drive_eject_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_stop_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GVolumeMonitorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GVolumeMonitorClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVolumeMonitorClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GVolumeMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeMonitorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume_added) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume_removed) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume_changed) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_added) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_removed) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_pre_unmount) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_pre_unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_changed) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_connected) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_disconnected) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_disconnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_changed) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_supported) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(is_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connected_drives) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_connected_drives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volumes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_volumes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mounts) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_mounts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volume_for_uuid) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_volume_for_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mount_for_uuid) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_mount_for_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adopt_orphan_mount) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(adopt_orphan_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_eject_button) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_eject_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_stop_button) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_stop_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    pub fn g_volume_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
}
extern "C" {
    pub fn g_volume_monitor_get_connected_drives(volume_monitor: *mut GVolumeMonitor)
        -> *mut GList;
}
extern "C" {
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
extern "C" {
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
extern "C" {
    pub fn g_volume_monitor_get_volume_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GVolume;
}
extern "C" {
    pub fn g_volume_monitor_get_mount_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GMount;
}
extern "C" {
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount) -> *mut GVolume;
}
pub type GNativeVolumeMonitor = _GNativeVolumeMonitor;
pub type GNativeVolumeMonitorClass = _GNativeVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}
#[test]
fn bindgen_test_layout__GNativeVolumeMonitor() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeVolumeMonitor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeVolumeMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GNativeVolumeMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeVolumeMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeVolumeMonitor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: ::std::option::Option<
        unsafe extern "C" fn(
            mount_path: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
        ) -> *mut GMount,
    >,
}
#[test]
fn bindgen_test_layout__GNativeVolumeMonitorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeVolumeMonitorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeVolumeMonitorClass>(),
        344usize,
        concat!("Size of: ", stringify!(_GNativeVolumeMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeVolumeMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeVolumeMonitorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mount_for_mount_path) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitorClass),
            "::",
            stringify!(get_mount_for_mount_path)
        )
    );
}
extern "C" {
    pub fn g_native_volume_monitor_get_type() -> GType;
}
pub type GNetworkAddressClass = _GNetworkAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressPrivate {
    _unused: [u8; 0],
}
pub type GNetworkAddressPrivate = _GNetworkAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNetworkAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkAddressPrivate,
}
#[test]
fn bindgen_test_layout__GNetworkAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GNetworkAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNetworkAddressClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GNetworkAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkAddressClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GNetworkAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_network_address_get_type() -> GType;
}
extern "C" {
    pub fn g_network_address_new(hostname: *const gchar, port: guint16) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_new_loopback(port: guint16) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_parse(
        host_and_port: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_parse_uri(
        uri: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress) -> *const gchar;
}
extern "C" {
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> guint16;
}
extern "C" {
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress) -> *const gchar;
}
pub type GNetworkMonitorInterface = _GNetworkMonitorInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNetworkMonitorInterface {
    pub g_iface: GTypeInterface,
    pub network_changed: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GNetworkMonitor, network_available: gboolean),
    >,
    pub can_reach: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_reach_async: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub can_reach_finish: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GNetworkMonitorInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkMonitorInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkMonitorInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GNetworkMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkMonitorInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(network_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_reach) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_reach_async) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_reach_finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach_finish)
        )
    );
}
extern "C" {
    pub fn g_network_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
}
extern "C" {
    pub fn g_network_monitor_get_network_available(monitor: *mut GNetworkMonitor) -> gboolean;
}
extern "C" {
    pub fn g_network_monitor_get_network_metered(monitor: *mut GNetworkMonitor) -> gboolean;
}
extern "C" {
    pub fn g_network_monitor_get_connectivity(
        monitor: *mut GNetworkMonitor,
    ) -> GNetworkConnectivity;
}
extern "C" {
    pub fn g_network_monitor_can_reach(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_network_monitor_can_reach_async(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_network_monitor_can_reach_finish(
        monitor: *mut GNetworkMonitor,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GNetworkServiceClass = _GNetworkServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServicePrivate {
    _unused: [u8; 0],
}
pub type GNetworkServicePrivate = _GNetworkServicePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNetworkService {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkServicePrivate,
}
#[test]
fn bindgen_test_layout__GNetworkService() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkService>(),
        32usize,
        concat!("Size of: ", stringify!(_GNetworkService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkService),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GNetworkServiceClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GNetworkServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkServiceClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkServiceClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GNetworkServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_network_service_get_type() -> GType;
}
extern "C" {
    pub fn g_network_service_new(
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_service_get_service(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_get_domain(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService, scheme: *const gchar);
}
extern "C" {
    pub fn g_notification_get_type() -> GType;
}
extern "C" {
    pub fn g_notification_new(title: *const gchar) -> *mut GNotification;
}
extern "C" {
    pub fn g_notification_set_title(notification: *mut GNotification, title: *const gchar);
}
extern "C" {
    pub fn g_notification_set_body(notification: *mut GNotification, body: *const gchar);
}
extern "C" {
    pub fn g_notification_set_icon(notification: *mut GNotification, icon: *mut GIcon);
}
extern "C" {
    pub fn g_notification_set_urgent(notification: *mut GNotification, urgent: gboolean);
}
extern "C" {
    pub fn g_notification_set_priority(
        notification: *mut GNotification,
        priority: GNotificationPriority,
    );
}
extern "C" {
    pub fn g_notification_set_category(notification: *mut GNotification, category: *const gchar);
}
extern "C" {
    pub fn g_notification_add_button(
        notification: *mut GNotification,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_notification_add_button_with_target(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_notification_add_button_with_target_value(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target: *mut GVariant,
    );
}
extern "C" {
    pub fn g_notification_set_default_action(
        notification: *mut GNotification,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_notification_set_default_action_and_target(
        notification: *mut GNotification,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_notification_set_default_action_and_target_value(
        notification: *mut GNotification,
        action: *const gchar,
        target: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionPrivate {
    _unused: [u8; 0],
}
pub type GPermissionPrivate = _GPermissionPrivate;
pub type GPermissionClass = _GPermissionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPermission {
    pub parent_instance: GObject,
    pub priv_: *mut GPermissionPrivate,
}
#[test]
fn bindgen_test_layout__GPermission() {
    const UNINIT: ::std::mem::MaybeUninit<_GPermission> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPermission>(),
        32usize,
        concat!("Size of: ", stringify!(_GPermission))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPermission>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPermission))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermission),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermission),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPermissionClass {
    pub parent_class: GObjectClass,
    pub acquire: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub acquire_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub acquire_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub release_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub reserved: [gpointer; 16usize],
}
#[test]
fn bindgen_test_layout__GPermissionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GPermissionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPermissionClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GPermissionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPermissionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPermissionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn g_permission_get_type() -> GType;
}
extern "C" {
    pub fn g_permission_acquire(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_acquire_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_permission_acquire_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_release(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_release_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_permission_release_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    pub fn g_permission_get_can_acquire(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    pub fn g_permission_get_can_release(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    pub fn g_permission_impl_update(
        permission: *mut GPermission,
        allowed: gboolean,
        can_acquire: gboolean,
        can_release: gboolean,
    );
}
#[doc = " GPollableInputStream:\n\n An interface for a #GInputStream that can be polled for readability.\n\n Since: 2.28"]
pub type GPollableInputStreamInterface = _GPollableInputStreamInterface;
#[doc = " GPollableInputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableInputStream instance is actually pollable\n @is_readable: Checks if the stream is readable\n @create_source: Creates a #GSource to poll the stream\n @read_nonblocking: Does a non-blocking read or returns\n   %G_IO_ERROR_WOULD_BLOCK\n\n The interface for pollable input streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @read_nonblocking calls\n g_pollable_input_stream_is_readable(), and then calls\n g_input_stream_read() if it returns %TRUE. This means you only need\n to override it if it is possible that your @is_readable\n implementation may return %TRUE when the stream is not actually\n readable.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPollableInputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub is_readable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub read_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
}
#[test]
fn bindgen_test_layout__GPollableInputStreamInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollableInputStreamInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollableInputStreamInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GPollableInputStreamInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollableInputStreamInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollableInputStreamInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_poll) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(can_poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_readable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(is_readable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_nonblocking) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(read_nonblocking)
        )
    );
}
extern "C" {
    pub fn g_pollable_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_input_stream_is_readable(stream: *mut GPollableInputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_input_stream_create_source(
        stream: *mut GPollableInputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_input_stream_read_nonblocking(
        stream: *mut GPollableInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
#[doc = " GPollableOutputStream:\n\n An interface for a #GOutputStream that can be polled for writeability.\n\n Since: 2.28"]
pub type GPollableOutputStreamInterface = _GPollableOutputStreamInterface;
#[doc = " GPollableOutputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableOutputStream instance is actually pollable\n @is_writable: Checks if the stream is writable\n @create_source: Creates a #GSource to poll the stream\n @write_nonblocking: Does a non-blocking write or returns\n   %G_IO_ERROR_WOULD_BLOCK\n @writev_nonblocking: Does a vectored non-blocking write, or returns\n   %G_POLLABLE_RETURN_WOULD_BLOCK\n\n The interface for pollable output streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @write_nonblocking calls\n g_pollable_output_stream_is_writable(), and then calls\n g_output_stream_write() if it returns %TRUE. This means you only\n need to override it if it is possible that your @is_writable\n implementation may return %TRUE when the stream is not actually\n writable.\n\n The default implementation of @writev_nonblocking calls\n g_pollable_output_stream_write_nonblocking() for each vector, and converts\n its return value and error (if set) to a #GPollableReturn. You should\n override this where possible to avoid having to allocate a #GError to return\n %G_IO_ERROR_WOULD_BLOCK.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPollableOutputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub is_writable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub write_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub writev_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GPollableReturn,
    >,
}
#[test]
fn bindgen_test_layout__GPollableOutputStreamInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollableOutputStreamInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollableOutputStreamInterface>(),
        56usize,
        concat!("Size of: ", stringify!(_GPollableOutputStreamInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollableOutputStreamInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollableOutputStreamInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_poll) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(can_poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_writable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(is_writable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_nonblocking) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(write_nonblocking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_nonblocking) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(writev_nonblocking)
        )
    );
}
extern "C" {
    pub fn g_pollable_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_pollable_output_stream_can_poll(stream: *mut GPollableOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_output_stream_is_writable(stream: *mut GPollableOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_output_stream_create_source(
        stream: *mut GPollableOutputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_output_stream_write_nonblocking(
        stream: *mut GPollableOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_pollable_output_stream_writev_nonblocking(
        stream: *mut GPollableOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GPollableReturn;
}
extern "C" {
    pub fn g_pollable_source_new(pollable_stream: *mut GObject) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_source_new_full(
        pollable_stream: gpointer,
        child_source: *mut GSource,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_pollable_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_pollable_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_power_profile_monitor_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPowerProfileMonitor {
    _unused: [u8; 0],
}
pub type GPowerProfileMonitor = _GPowerProfileMonitor;
pub type GPowerProfileMonitorInterface = _GPowerProfileMonitorInterface;
pub type GPowerProfileMonitor_autoptr = *mut GPowerProfileMonitor;
pub type GPowerProfileMonitor_listautoptr = *mut GList;
pub type GPowerProfileMonitor_slistautoptr = *mut GSList;
pub type GPowerProfileMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GPowerProfileMonitorInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GPowerProfileMonitorInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GPowerProfileMonitorInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPowerProfileMonitorInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GPowerProfileMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPowerProfileMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPowerProfileMonitorInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPowerProfileMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_power_profile_monitor_dup_default() -> *mut GPowerProfileMonitor;
}
extern "C" {
    pub fn g_power_profile_monitor_get_power_saver_enabled(
        monitor: *mut GPowerProfileMonitor,
    ) -> gboolean;
}
extern "C" {
    pub fn g_property_action_get_type() -> GType;
}
extern "C" {
    pub fn g_property_action_new(
        name: *const gchar,
        object: gpointer,
        property_name: *const gchar,
    ) -> *mut GPropertyAction;
}
#[doc = " GProxy:\n\n Interface that handles proxy connection and payload.\n\n Since: 2.26"]
pub type GProxyInterface = _GProxyInterface;
#[doc = " GProxyInterface:\n @g_iface: The parent interface.\n @connect: Connect to proxy server and wrap (if required) the #connection\n           to handle payload.\n @connect_async: Same as connect() but asynchronous.\n @connect_finish: Returns the result of connect_async()\n @supports_hostname: Returns whether the proxy supports hostname lookups.\n\n Provides an interface for handling proxy connection and payload.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GProxyInterface {
    pub g_iface: GTypeInterface,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub connect_async: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub connect_finish: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub supports_hostname:
        ::std::option::Option<unsafe extern "C" fn(proxy: *mut GProxy) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GProxyInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GProxyInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_async) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_finish) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_hostname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(supports_hostname)
        )
    );
}
extern "C" {
    pub fn g_proxy_get_type() -> GType;
}
extern "C" {
    pub fn g_proxy_get_default_for_protocol(protocol: *const gchar) -> *mut GProxy;
}
extern "C" {
    pub fn g_proxy_connect(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_proxy_connect_async(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_proxy_connect_finish(
        proxy: *mut GProxy,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;
}
pub type GProxyAddressClass = _GProxyAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressPrivate = _GProxyAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    pub priv_: *mut GProxyAddressPrivate,
}
#[test]
fn bindgen_test_layout__GProxyAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddress>(),
        40usize,
        concat!("Size of: ", stringify!(_GProxyAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GProxyAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddressClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GProxyAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_proxy_address_get_type() -> GType;
}
extern "C" {
    pub fn g_proxy_address_new(
        inetaddr: *mut GInetAddress,
        port: guint16,
        protocol: *const gchar,
        dest_hostname: *const gchar,
        dest_port: guint16,
        username: *const gchar,
        password: *const gchar,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress) -> guint16;
}
extern "C" {
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const gchar;
}
#[doc = " GSocketAddressEnumerator:\n\n Enumerator type for objects that contain or generate\n #GSocketAddress instances."]
pub type GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketAddressEnumerator {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GSocketAddressEnumerator() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddressEnumerator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressEnumerator>(),
        24usize,
        concat!("Size of: ", stringify!(_GSocketAddressEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressEnumerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GSocketAddressEnumeratorClass:\n @next: Virtual method for g_socket_address_enumerator_next().\n @next_async: Virtual method for g_socket_address_enumerator_next_async().\n @next_finish: Virtual method for g_socket_address_enumerator_next_finish().\n\n Class structure for #GSocketAddressEnumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketAddressEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
    pub next_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
}
#[test]
fn bindgen_test_layout__GSocketAddressEnumeratorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddressEnumeratorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressEnumeratorClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GSocketAddressEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressEnumeratorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next_finish)
        )
    );
}
extern "C" {
    pub fn g_socket_address_enumerator_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_address_enumerator_next(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_address_enumerator_next_async(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_address_enumerator_next_finish(
        enumerator: *mut GSocketAddressEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
#[doc = " GProxyAddressEnumerator:\n\n A subclass of #GSocketAddressEnumerator that takes another address\n enumerator and wraps each of its results in a #GProxyAddress as\n directed by the default #GProxyResolver."]
pub type GProxyAddressEnumeratorClass = _GProxyAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub priv_: *mut GProxyAddressEnumeratorPrivate,
}
#[test]
fn bindgen_test_layout__GProxyAddressEnumerator() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddressEnumerator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressEnumerator>(),
        32usize,
        concat!("Size of: ", stringify!(_GProxyAddressEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressEnumerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumerator),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GProxyAddressEnumeratorClass:\n\n Class structure for #GProxyAddressEnumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GProxyAddressEnumeratorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddressEnumeratorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressEnumeratorClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GProxyAddressEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressEnumeratorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
}
extern "C" {
    pub fn g_proxy_address_enumerator_get_type() -> GType;
}
pub type GProxyResolverInterface = _GProxyResolverInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GProxyResolverInterface {
    pub g_iface: GTypeInterface,
    pub is_supported:
        ::std::option::Option<unsafe extern "C" fn(resolver: *mut GProxyResolver) -> gboolean>,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub lookup_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GProxyResolverInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyResolverInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyResolverInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GProxyResolverInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyResolverInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyResolverInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_supported) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(is_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_async) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup_finish)
        )
    );
}
extern "C" {
    pub fn g_proxy_resolver_get_type() -> GType;
}
extern "C" {
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
}
extern "C" {
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver) -> gboolean;
}
extern "C" {
    pub fn g_proxy_resolver_lookup(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_proxy_resolver_lookup_async(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_proxy_resolver_lookup_finish(
        resolver: *mut GProxyResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
pub type GRemoteActionGroupInterface = _GRemoteActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GRemoteActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub activate_action_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
    pub change_action_state_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GRemoteActionGroupInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GRemoteActionGroupInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRemoteActionGroupInterface>(),
        32usize,
        concat!("Size of: ", stringify!(_GRemoteActionGroupInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRemoteActionGroupInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRemoteActionGroupInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate_action_full) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(activate_action_full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_action_state_full) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(change_action_state_full)
        )
    );
}
extern "C" {
    pub fn g_remote_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_remote_action_group_activate_action_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
extern "C" {
    pub fn g_remote_action_group_change_action_state_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverPrivate {
    _unused: [u8; 0],
}
pub type GResolverPrivate = _GResolverPrivate;
pub type GResolverClass = _GResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GResolverPrivate,
}
#[test]
fn bindgen_test_layout__GResolver() {
    const UNINIT: ::std::mem::MaybeUninit<_GResolver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GResolver>(),
        32usize,
        concat!("Size of: ", stringify!(_GResolver))
    );
    assert_eq!(
        ::std::mem::align_of::<_GResolver>(),
        8usize,
        concat!("Alignment of ", stringify!(_GResolver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolver),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolver),
            "::",
            stringify!(priv_)
        )
    );
}
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: GResolverNameLookupFlags =
    0;
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY:
    GResolverNameLookupFlags = 1;
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY:
    GResolverNameLookupFlags = 2;
#[doc = " GResolverNameLookupFlags:\n @G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: default behavior (same as g_resolver_lookup_by_name())\n @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY: only resolve ipv4 addresses\n @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY: only resolve ipv6 addresses\n\n Flags to modify lookup behavior.\n\n Since: 2.60"]
pub type GResolverNameLookupFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GResolverClass {
    pub parent_class: GObjectClass,
    pub reload: ::std::option::Option<unsafe extern "C" fn(resolver: *mut GResolver)>,
    pub lookup_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_address: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_by_address_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_address_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_service: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_service_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_service_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_records_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags_async:\n @resolver: a #GResolver\n @hostname: the hostname to resolve\n @flags: extra #GResolverNameLookupFlags to modify the lookup\n @cancellable: (nullable): a #GCancellable\n @callback: (scope async): a #GAsyncReadyCallback to call when completed\n @user_data: data to pass to @callback\n\n Asynchronous version of GResolverClass::lookup_by_name_with_flags\n\n GResolverClass::lookup_by_name_with_flags_finish will be called to get\n the result.\n\n Since: 2.60"]
    pub lookup_by_name_with_flags_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            flags: GResolverNameLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags_finish:\n @resolver: a #GResolver\n @result: a #GAsyncResult\n @error: (nullable): a pointer to a %NULL #GError\n\n Gets the result from GResolverClass::lookup_by_name_with_flags_async\n\n Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.\n Since: 2.60"]
    pub lookup_by_name_with_flags_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags:\n @resolver: a #GResolver\n @hostname: the hostname to resolve\n @flags: extra #GResolverNameLookupFlags to modify the lookup\n @cancellable: (nullable): a #GCancellable\n @error: (nullable): a pointer to a %NULL #GError\n\n This is identical to GResolverClass::lookup_by_name except it takes\n @flags which modifies the behavior of the lookup. See #GResolverNameLookupFlags\n for more details.\n\n Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.\n Since: 2.60"]
    pub lookup_by_name_with_flags: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            flags: GResolverNameLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
}
#[test]
fn bindgen_test_layout__GResolverClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GResolverClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GResolverClass>(),
        264usize,
        concat!("Size of: ", stringify!(_GResolverClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GResolverClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GResolverClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reload) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(reload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name_async) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name_finish) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_address) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_address_async) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_address_finish) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_service) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_service_async) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_service_finish) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_records) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_records_async) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_records_finish) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records_finish)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_by_name_with_flags_async) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_with_flags_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_by_name_with_flags_finish) as usize - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_with_flags_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name_with_flags) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_with_flags)
        )
    );
}
extern "C" {
    pub fn g_resolver_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_get_default() -> *mut GResolver;
}
extern "C" {
    pub fn g_resolver_set_default(resolver: *mut GResolver);
}
extern "C" {
    pub fn g_resolver_lookup_by_name(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_by_name_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_by_name_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        flags: GResolverNameLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags(
        resolver: *mut GResolver,
        hostname: *const gchar,
        flags: GResolverNameLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_free_addresses(addresses: *mut GList);
}
extern "C" {
    pub fn g_resolver_lookup_by_address(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_resolver_lookup_by_address_async(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_by_address_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_resolver_lookup_service(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_service_async(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_service_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_records(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_records_async(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_records_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_free_targets(targets: *mut GList);
}
extern "C" {
    pub fn g_resolver_get_timeout(resolver: *mut GResolver) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn g_resolver_set_timeout(resolver: *mut GResolver, timeout_ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn g_resolver_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_resource_error_quark() -> GQuark;
}
pub type GStaticResource = _GStaticResource;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GStaticResource {
    pub data: *const guint8,
    pub data_len: gsize,
    pub resource: *mut GResource,
    pub next: *mut GStaticResource,
    pub padding: gpointer,
}
#[test]
fn bindgen_test_layout__GStaticResource() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticResource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticResource>(),
        40usize,
        concat!("Size of: ", stringify!(_GStaticResource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticResource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticResource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_resource_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_new_from_data(data: *mut GBytes, error: *mut *mut GError) -> *mut GResource;
}
extern "C" {
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
}
extern "C" {
    pub fn g_resource_unref(resource: *mut GResource);
}
extern "C" {
    pub fn g_resource_load(filename: *const gchar, error: *mut *mut GError) -> *mut GResource;
}
extern "C" {
    pub fn g_resource_open_stream(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_resource_lookup_data(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_resource_enumerate_children(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_resource_get_info(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_resources_register(resource: *mut GResource);
}
extern "C" {
    pub fn g_resources_unregister(resource: *mut GResource);
}
extern "C" {
    pub fn g_resources_open_stream(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_resources_lookup_data(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_resources_enumerate_children(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_resources_get_info(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);
}
extern "C" {
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
}
extern "C" {
    pub fn g_static_resource_get_resource(static_resource: *mut GStaticResource) -> *mut GResource;
}
#[doc = " GSeekable:\n\n Seek object for streaming operations."]
pub type GSeekableIface = _GSeekableIface;
#[doc = " GSeekableIface:\n @g_iface: The parent interface.\n @tell: Tells the current location within a stream.\n @can_seek: Checks if seeking is supported by the stream.\n @seek: Seeks to a location within a stream.\n @can_truncate: Checks if truncation is supported by the stream.\n @truncate_fn: Truncates a stream.\n\n Provides an interface for implementing seekable functionality on I/O Streams."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSeekableIface {
    pub g_iface: GTypeInterface,
    pub tell: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GSeekableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GSeekableIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSeekableIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GSeekableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSeekableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSeekableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_truncate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_fn) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(truncate_fn)
        )
    );
}
extern "C" {
    pub fn g_seekable_get_type() -> GType;
}
extern "C" {
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> goffset;
}
extern "C" {
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
}
extern "C" {
    pub fn g_seekable_seek(
        seekable: *mut GSeekable,
        offset: goffset,
        type_: GSeekType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
}
extern "C" {
    pub fn g_seekable_truncate(
        seekable: *mut GSeekable,
        offset: goffset,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaSource {
    _unused: [u8; 0],
}
pub type GSettingsSchemaSource = _GSettingsSchemaSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchema {
    _unused: [u8; 0],
}
pub type GSettingsSchema = _GSettingsSchema;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaKey {
    _unused: [u8; 0],
}
pub type GSettingsSchemaKey = _GSettingsSchemaKey;
extern "C" {
    pub fn g_settings_schema_source_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_schema_source_get_default() -> *mut GSettingsSchemaSource;
}
extern "C" {
    pub fn g_settings_schema_source_ref(
        source: *mut GSettingsSchemaSource,
    ) -> *mut GSettingsSchemaSource;
}
extern "C" {
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
}
extern "C" {
    pub fn g_settings_schema_source_new_from_directory(
        directory: *const gchar,
        parent: *mut GSettingsSchemaSource,
        trusted: gboolean,
        error: *mut *mut GError,
    ) -> *mut GSettingsSchemaSource;
}
extern "C" {
    pub fn g_settings_schema_source_lookup(
        source: *mut GSettingsSchemaSource,
        schema_id: *const gchar,
        recursive: gboolean,
    ) -> *mut GSettingsSchema;
}
extern "C" {
    pub fn g_settings_schema_source_list_schemas(
        source: *mut GSettingsSchemaSource,
        recursive: gboolean,
        non_relocatable: *mut *mut *mut gchar,
        relocatable: *mut *mut *mut gchar,
    );
}
extern "C" {
    pub fn g_settings_schema_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema) -> *mut GSettingsSchema;
}
extern "C" {
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);
}
extern "C" {
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_get_key(
        schema: *mut GSettingsSchema,
        name: *const gchar,
    ) -> *mut GSettingsSchemaKey;
}
extern "C" {
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema, name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_schema_key_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey) -> *mut GSettingsSchemaKey;
}
extern "C" {
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);
}
extern "C" {
    pub fn g_settings_schema_key_get_value_type(
        key: *mut GSettingsSchemaKey,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn g_settings_schema_key_get_default_value(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_schema_key_range_check(
        key: *mut GSettingsSchemaKey,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsPrivate {
    _unused: [u8; 0],
}
pub type GSettingsPrivate = _GSettingsPrivate;
pub type GSettingsClass = _GSettingsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSettingsClass {
    pub parent_class: GObjectClass,
    pub writable_changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub writable_change_event: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut GSettings, key: GQuark) -> gboolean,
    >,
    pub change_event: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut GSettings,
            keys: *const GQuark,
            n_keys: gint,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 20usize],
}
#[test]
fn bindgen_test_layout__GSettingsClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSettingsClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSettingsClass>(),
        328usize,
        concat!("Size of: ", stringify!(_GSettingsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSettingsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSettingsClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writable_changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(writable_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writable_change_event) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(writable_change_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_event) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(change_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSettings {
    pub parent_instance: GObject,
    pub priv_: *mut GSettingsPrivate,
}
#[test]
fn bindgen_test_layout__GSettings() {
    const UNINIT: ::std::mem::MaybeUninit<_GSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSettings>(),
        32usize,
        concat!("Size of: ", stringify!(_GSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettings),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettings),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_settings_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_list_schemas() -> *const *const gchar;
}
extern "C" {
    pub fn g_settings_list_relocatable_schemas() -> *const *const gchar;
}
extern "C" {
    pub fn g_settings_new(schema_id: *const gchar) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_with_path(schema_id: *const gchar, path: *const gchar) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_with_backend(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
    ) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_with_backend_and_path(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_full(
        schema: *mut GSettingsSchema,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_list_children(settings: *mut GSettings) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_range_check(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_set_value(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_get_user_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_get_default_value(
        settings: *mut GSettings,
        key: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_set(
        settings: *mut GSettings,
        key: *const gchar,
        format: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get(settings: *mut GSettings, key: *const gchar, format: *const gchar, ...);
}
extern "C" {
    pub fn g_settings_reset(settings: *mut GSettings, key: *const gchar);
}
extern "C" {
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const gchar) -> gint;
}
extern "C" {
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const gchar, value: gint)
        -> gboolean;
}
extern "C" {
    pub fn g_settings_get_int64(settings: *mut GSettings, key: *const gchar) -> gint64;
}
extern "C" {
    pub fn g_settings_set_int64(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint64,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const gchar) -> guint;
}
extern "C" {
    pub fn g_settings_set_uint(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_uint64(settings: *mut GSettings, key: *const gchar) -> guint64;
}
extern "C" {
    pub fn g_settings_set_uint64(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint64,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_settings_set_string(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_settings_set_boolean(
        settings: *mut GSettings,
        key: *const gchar,
        value: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const gchar) -> gdouble;
}
extern "C" {
    pub fn g_settings_set_double(
        settings: *mut GSettings,
        key: *const gchar,
        value: gdouble,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_set_strv(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const gchar) -> gint;
}
extern "C" {
    pub fn g_settings_set_enum(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const gchar) -> guint;
}
extern "C" {
    pub fn g_settings_set_flags(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const gchar) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_is_writable(settings: *mut GSettings, name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_settings_delay(settings: *mut GSettings);
}
extern "C" {
    pub fn g_settings_apply(settings: *mut GSettings);
}
extern "C" {
    pub fn g_settings_revert(settings: *mut GSettings);
}
extern "C" {
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
}
extern "C" {
    pub fn g_settings_sync();
}
#[doc = " GSettingsBindSetMapping:\n @value: a #GValue containing the property value to map\n @expected_type: the #GVariantType to create\n @user_data: user data that was specified when the binding was created\n\n The type for the function that is used to convert an object property\n value to a #GVariant for storing it in #GSettings.\n\n Returns: a new #GVariant holding the data from @value,\n     or %NULL in case of an error"]
pub type GSettingsBindSetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const GValue,
        expected_type: *const GVariantType,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
#[doc = " GSettingsBindGetMapping:\n @value: return location for the property value\n @variant: the #GVariant\n @user_data: user data that was specified when the binding was created\n\n The type for the function that is used to convert from #GSettings to\n an object property. The @value is already initialized to hold values\n of the appropriate type.\n\n Returns: %TRUE if the conversion succeeded, %FALSE in case of an error"]
pub type GSettingsBindGetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GValue,
        variant: *mut GVariant,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSettingsGetMapping:\n @value: the #GVariant to map, or %NULL\n @result: (out): the result of the mapping\n @user_data: (closure): the user data that was passed to\n g_settings_get_mapped()\n\n The type of the function that is used to convert from a value stored\n in a #GSettings to a value that is useful to the application.\n\n If the value is successfully mapped, the result should be stored at\n @result and %TRUE returned.  If mapping fails (for example, if @value\n is not in the right format) then %FALSE should be returned.\n\n If @value is %NULL then it means that the mapping function is being\n given a \"last chance\" to successfully return a valid value.  %TRUE\n must be returned in this case.\n\n Returns: %TRUE if the conversion succeeded, %FALSE in case of an error"]
pub type GSettingsGetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GVariant,
        result: *mut gpointer,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GSettingsBindFlags_G_SETTINGS_BIND_DEFAULT: GSettingsBindFlags = 0;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET: GSettingsBindFlags = 1;
pub const GSettingsBindFlags_G_SETTINGS_BIND_SET: GSettingsBindFlags = 2;
pub const GSettingsBindFlags_G_SETTINGS_BIND_NO_SENSITIVITY: GSettingsBindFlags = 4;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET_NO_CHANGES: GSettingsBindFlags = 8;
pub const GSettingsBindFlags_G_SETTINGS_BIND_INVERT_BOOLEAN: GSettingsBindFlags = 16;
#[doc = " GSettingsBindFlags:\n @G_SETTINGS_BIND_DEFAULT: Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`\n @G_SETTINGS_BIND_GET: Update the #GObject property when the setting changes.\n     It is an error to use this flag if the property is not writable.\n @G_SETTINGS_BIND_SET: Update the setting when the #GObject property changes.\n     It is an error to use this flag if the property is not readable.\n @G_SETTINGS_BIND_NO_SENSITIVITY: Do not try to bind a \"sensitivity\" property to the writability of the setting\n @G_SETTINGS_BIND_GET_NO_CHANGES: When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property\n     value initially from the setting, but do not listen for changes of the setting\n @G_SETTINGS_BIND_INVERT_BOOLEAN: When passed to g_settings_bind(), uses a pair of mapping functions that invert\n     the boolean value when mapping between the setting and the property.  The setting and property must both\n     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().\n\n Flags used when creating a binding. These flags determine in which\n direction the binding works. The default is to synchronize in both\n directions."]
pub type GSettingsBindFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_settings_bind(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
    );
}
extern "C" {
    pub fn g_settings_bind_with_mapping(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
        get_mapping: GSettingsBindGetMapping,
        set_mapping: GSettingsBindSetMapping,
        user_data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_settings_bind_writable(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        inverted: gboolean,
    );
}
extern "C" {
    pub fn g_settings_unbind(object: gpointer, property: *const gchar);
}
extern "C" {
    pub fn g_settings_create_action(settings: *mut GSettings, key: *const gchar) -> *mut GAction;
}
extern "C" {
    pub fn g_settings_get_mapped(
        settings: *mut GSettings,
        key: *const gchar,
        mapping: GSettingsGetMapping,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_simple_action_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_action_new(
        name: *const gchar,
        parameter_type: *const GVariantType,
    ) -> *mut GSimpleAction;
}
extern "C" {
    pub fn g_simple_action_new_stateful(
        name: *const gchar,
        parameter_type: *const GVariantType,
        state: *mut GVariant,
    ) -> *mut GSimpleAction;
}
extern "C" {
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction, enabled: gboolean);
}
extern "C" {
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction, value: *mut GVariant);
}
extern "C" {
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction, state_hint: *mut GVariant);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupPrivate {
    _unused: [u8; 0],
}
pub type GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate;
pub type GSimpleActionGroupClass = _GSimpleActionGroupClass;
#[doc = " GSimpleActionGroup:\n\n The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSimpleActionGroup {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleActionGroupPrivate,
}
#[test]
fn bindgen_test_layout__GSimpleActionGroup() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleActionGroup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleActionGroup>(),
        32usize,
        concat!("Size of: ", stringify!(_GSimpleActionGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleActionGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleActionGroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroup),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroup),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSimpleActionGroupClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__GSimpleActionGroupClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleActionGroupClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleActionGroupClass>(),
        232usize,
        concat!("Size of: ", stringify!(_GSimpleActionGroupClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleActionGroupClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleActionGroupClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroupClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroupClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_simple_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
}
extern "C" {
    pub fn g_simple_action_group_lookup(
        simple: *mut GSimpleActionGroup,
        action_name: *const gchar,
    ) -> *mut GAction;
}
extern "C" {
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup, action: *mut GAction);
}
extern "C" {
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup, action_name: *const gchar);
}
extern "C" {
    pub fn g_simple_action_group_add_entries(
        simple: *mut GSimpleActionGroup,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResultClass {
    _unused: [u8; 0],
}
#[doc = " GSimpleAsyncResult:\n\n A simple implementation of #GAsyncResult."]
pub type GSimpleAsyncResultClass = _GSimpleAsyncResultClass;
extern "C" {
    pub fn g_simple_async_result_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_async_result_new(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        source_tag: gpointer,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_new_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_new_from_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_new_take_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_set_op_res_gpointer(
        simple: *mut GSimpleAsyncResult,
        op_res: gpointer,
        destroy_op_res: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_simple_async_result_get_op_res_gpointer(simple: *mut GSimpleAsyncResult) -> gpointer;
}
extern "C" {
    pub fn g_simple_async_result_set_op_res_gssize(simple: *mut GSimpleAsyncResult, op_res: gssize);
}
extern "C" {
    pub fn g_simple_async_result_get_op_res_gssize(simple: *mut GSimpleAsyncResult) -> gssize;
}
extern "C" {
    pub fn g_simple_async_result_set_op_res_gboolean(
        simple: *mut GSimpleAsyncResult,
        op_res: gboolean,
    );
}
extern "C" {
    pub fn g_simple_async_result_get_op_res_gboolean(simple: *mut GSimpleAsyncResult) -> gboolean;
}
extern "C" {
    pub fn g_simple_async_result_set_check_cancellable(
        simple: *mut GSimpleAsyncResult,
        check_cancellable: *mut GCancellable,
    );
}
extern "C" {
    pub fn g_simple_async_result_get_source_tag(simple: *mut GSimpleAsyncResult) -> gpointer;
}
extern "C" {
    pub fn g_simple_async_result_set_handle_cancellation(
        simple: *mut GSimpleAsyncResult,
        handle_cancellation: gboolean,
    );
}
extern "C" {
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
}
extern "C" {
    pub fn g_simple_async_result_complete_in_idle(simple: *mut GSimpleAsyncResult);
}
extern "C" {
    pub fn g_simple_async_result_run_in_thread(
        simple: *mut GSimpleAsyncResult,
        func: GSimpleAsyncThreadFunc,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
    );
}
extern "C" {
    pub fn g_simple_async_result_set_from_error(
        simple: *mut GSimpleAsyncResult,
        error: *const GError,
    );
}
extern "C" {
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult, error: *mut GError);
}
extern "C" {
    pub fn g_simple_async_result_propagate_error(
        simple: *mut GSimpleAsyncResult,
        dest: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_simple_async_result_set_error(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_simple_async_result_set_error_va(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn g_simple_async_result_is_valid(
        result: *mut GAsyncResult,
        source: *mut GObject,
        source_tag: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_simple_async_report_error_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_simple_async_report_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    );
}
extern "C" {
    pub fn g_simple_async_report_take_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    );
}
extern "C" {
    pub fn g_simple_io_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_io_stream_new(
        input_stream: *mut GInputStream,
        output_stream: *mut GOutputStream,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_simple_permission_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;
}
#[doc = " GSimpleProxyResolver:\n\n A #GProxyResolver implementation for using a fixed set of proxies."]
pub type GSimpleProxyResolver = _GSimpleProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverPrivate {
    _unused: [u8; 0],
}
pub type GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate;
pub type GSimpleProxyResolverClass = _GSimpleProxyResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSimpleProxyResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleProxyResolverPrivate,
}
#[test]
fn bindgen_test_layout__GSimpleProxyResolver() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleProxyResolver> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleProxyResolver>(),
        32usize,
        concat!("Size of: ", stringify!(_GSimpleProxyResolver))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleProxyResolver>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleProxyResolver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolver),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolver),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSimpleProxyResolverClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSimpleProxyResolverClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleProxyResolverClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleProxyResolverClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GSimpleProxyResolverClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleProxyResolverClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleProxyResolverClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_simple_proxy_resolver_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_proxy_resolver_new(
        default_proxy: *const gchar,
        ignore_hosts: *mut *mut gchar,
    ) -> *mut GProxyResolver;
}
extern "C" {
    pub fn g_simple_proxy_resolver_set_default_proxy(
        resolver: *mut GSimpleProxyResolver,
        default_proxy: *const gchar,
    );
}
extern "C" {
    pub fn g_simple_proxy_resolver_set_ignore_hosts(
        resolver: *mut GSimpleProxyResolver,
        ignore_hosts: *mut *mut gchar,
    );
}
extern "C" {
    pub fn g_simple_proxy_resolver_set_uri_proxy(
        resolver: *mut GSimpleProxyResolver,
        uri_scheme: *const gchar,
        proxy: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketPrivate {
    _unused: [u8; 0],
}
pub type GSocketPrivate = _GSocketPrivate;
pub type GSocketClass = _GSocketClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GSocketClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved9) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved10) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved10)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocket {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketPrivate,
}
#[test]
fn bindgen_test_layout__GSocket() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocket>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocket))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocket>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocket),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocket),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_new(
        family: GSocketFamily,
        type_: GSocketType,
        protocol: GSocketProtocol,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_new_from_fd(fd: gint, error: *mut *mut GError) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_get_fd(socket: *mut GSocket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
}
extern "C" {
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
}
extern "C" {
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
}
extern "C" {
    pub fn g_socket_get_local_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_get_remote_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
}
extern "C" {
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
}
extern "C" {
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> gint;
}
extern "C" {
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: gint);
}
extern "C" {
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> guint;
}
extern "C" {
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: guint);
}
extern "C" {
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> guint;
}
extern "C" {
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: guint);
}
extern "C" {
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
}
extern "C" {
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket, loopback: gboolean);
}
extern "C" {
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> guint;
}
extern "C" {
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: guint);
}
extern "C" {
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_bind(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        allow_reuse: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_join_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_leave_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_join_multicast_group_ssm(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: *mut GInetAddress,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_leave_multicast_group_ssm(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: *mut GInetAddress,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_connect(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_check_connect_result(socket: *mut GSocket, error: *mut *mut GError)
        -> gboolean;
}
extern "C" {
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> gssize;
}
extern "C" {
    pub fn g_socket_condition_check(socket: *mut GSocket, condition: GIOCondition) -> GIOCondition;
}
extern "C" {
    pub fn g_socket_condition_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_condition_timed_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        timeout_us: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_accept(
        socket: *mut GSocket,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_listen(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_socket_receive(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_receive_from(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_to(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_receive_message(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        vectors: *mut GInputVector,
        num_vectors: gint,
        messages: *mut *mut *mut GSocketControlMessage,
        num_messages: *mut gint,
        flags: *mut gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_message(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *mut GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_receive_messages(
        socket: *mut GSocket,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_socket_send_messages(
        socket: *mut GSocket,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_socket_close(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_socket_shutdown(
        socket: *mut GSocket,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_create_source(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_get_credentials(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_socket_receive_with_blocking(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_with_blocking(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_message_with_timeout(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *const GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        timeout_us: gint64,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GPollableReturn;
}
extern "C" {
    pub fn g_socket_get_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientPrivate {
    _unused: [u8; 0],
}
pub type GSocketClientPrivate = _GSocketClientPrivate;
pub type GSocketClientClass = _GSocketClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketClientClass {
    pub parent_class: GObjectClass,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut GSocketClient,
            event: GSocketClientEvent,
            connectable: *mut GSocketConnectable,
            connection: *mut GIOStream,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketClientClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketClientClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketClientClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GSocketClientClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClientClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClientClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketClient {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketClientPrivate,
}
#[test]
fn bindgen_test_layout__GSocketClient() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketClient> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketClient>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketClient))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClient>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClient),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClient),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_client_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_client_new() -> *mut GSocketClient;
}
extern "C" {
    pub fn g_socket_client_get_family(client: *mut GSocketClient) -> GSocketFamily;
}
extern "C" {
    pub fn g_socket_client_set_family(client: *mut GSocketClient, family: GSocketFamily);
}
extern "C" {
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient) -> GSocketType;
}
extern "C" {
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient, type_: GSocketType);
}
extern "C" {
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient) -> GSocketProtocol;
}
extern "C" {
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient, protocol: GSocketProtocol);
}
extern "C" {
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_client_set_local_address(
        client: *mut GSocketClient,
        address: *mut GSocketAddress,
    );
}
extern "C" {
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> guint;
}
extern "C" {
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient, timeout: guint);
}
extern "C" {
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient) -> gboolean;
}
extern "C" {
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient, enable: gboolean);
}
extern "C" {
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
}
extern "C" {
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
}
extern "C" {
    pub fn g_socket_client_get_tls_validation_flags(
        client: *mut GSocketClient,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_socket_client_set_tls_validation_flags(
        client: *mut GSocketClient,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient) -> *mut GProxyResolver;
}
extern "C" {
    pub fn g_socket_client_set_proxy_resolver(
        client: *mut GSocketClient,
        proxy_resolver: *mut GProxyResolver,
    );
}
extern "C" {
    pub fn g_socket_client_connect(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_host(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_service(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_uri(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_async(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_host_async(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_to_host_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_service_async(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_to_service_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_uri_async(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_to_uri_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_add_application_proxy(
        client: *mut GSocketClient,
        protocol: *const gchar,
    );
}
#[doc = " GSocketConnectable:\n\n Interface for objects that contain or generate a #GSocketAddress."]
pub type GSocketConnectableIface = _GSocketConnectableIface;
#[doc = " GSocketConnectableIface:\n @g_iface: The parent interface.\n @enumerate: Creates a #GSocketAddressEnumerator\n @proxy_enumerate: Creates a #GProxyAddressEnumerator\n @to_string: Format the connectables address as a string for debugging.\n    Implementing this is optional. (Since: 2.48)\n\n Provides an interface for returning a #GSocketAddressEnumerator\n and #GProxyAddressEnumerator"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketConnectableIface {
    pub g_iface: GTypeInterface,
    pub enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub proxy_enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub to_string: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GSocketConnectableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketConnectableIface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnectableIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketConnectableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnectableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnectableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proxy_enumerate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(proxy_enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(to_string)
        )
    );
}
extern "C" {
    pub fn g_socket_connectable_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_connectable_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
extern "C" {
    pub fn g_socket_connectable_proxy_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
extern "C" {
    pub fn g_socket_connectable_to_string(connectable: *mut GSocketConnectable) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionPrivate {
    _unused: [u8; 0],
}
pub type GSocketConnectionPrivate = _GSocketConnectionPrivate;
pub type GSocketConnectionClass = _GSocketConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketConnectionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GSocketConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GSocketConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GSocketConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnection>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_connection_is_connected(connection: *mut GSocketConnection) -> gboolean;
}
extern "C" {
    pub fn g_socket_connection_connect(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_connection_connect_async(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_connection_connect_finish(
        connection: *mut GSocketConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_connection_get_local_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_connection_get_remote_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_connection_factory_register_type(
        g_type: GType,
        family: GSocketFamily,
        type_: GSocketType,
        protocol: gint,
    );
}
extern "C" {
    pub fn g_socket_connection_factory_lookup_type(
        family: GSocketFamily,
        type_: GSocketType,
        protocol_id: gint,
    ) -> GType;
}
extern "C" {
    pub fn g_socket_connection_factory_create_connection(
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessagePrivate {
    _unused: [u8; 0],
}
pub type GSocketControlMessagePrivate = _GSocketControlMessagePrivate;
#[doc = " GSocketControlMessageClass:\n @get_size: gets the size of the message.\n @get_level: gets the protocol of the message.\n @get_type: gets the protocol specific type of the message.\n @serialize: Writes out the message data.\n @deserialize: Tries to deserialize a message.\n\n Class structure for #GSocketControlMessage."]
pub type GSocketControlMessageClass = _GSocketControlMessageClass;
#[doc = " GSocketControlMessageClass:\n @get_size: gets the size of the message.\n @get_level: gets the protocol of the message.\n @get_type: gets the protocol specific type of the message.\n @serialize: Writes out the message data.\n @deserialize: Tries to deserialize a message.\n\n Class structure for #GSocketControlMessage."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketControlMessageClass {
    pub parent_class: GObjectClass,
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(message: *mut GSocketControlMessage) -> gsize>,
    pub get_level: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub serialize: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage, data: gpointer),
    >,
    pub deserialize: ::std::option::Option<
        unsafe extern "C" fn(
            level: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            size: gsize,
            data: gpointer,
        ) -> *mut GSocketControlMessage,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketControlMessageClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketControlMessageClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketControlMessageClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GSocketControlMessageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketControlMessageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketControlMessageClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_level) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketControlMessage {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketControlMessagePrivate,
}
#[test]
fn bindgen_test_layout__GSocketControlMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketControlMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketControlMessage>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketControlMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketControlMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketControlMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessage),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_control_message_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_control_message_get_size(message: *mut GSocketControlMessage) -> gsize;
}
extern "C" {
    pub fn g_socket_control_message_get_level(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_socket_control_message_get_msg_type(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_socket_control_message_serialize(message: *mut GSocketControlMessage, data: gpointer);
}
extern "C" {
    pub fn g_socket_control_message_deserialize(
        level: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        size: gsize,
        data: gpointer,
    ) -> *mut GSocketControlMessage;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerPrivate {
    _unused: [u8; 0],
}
pub type GSocketListenerPrivate = _GSocketListenerPrivate;
#[doc = " GSocketListenerClass:\n @changed: virtual method called when the set of socket listened to changes\n\n Class structure for #GSocketListener."]
pub type GSocketListenerClass = _GSocketListenerClass;
#[doc = " GSocketListenerClass:\n @changed: virtual method called when the set of socket listened to changes\n\n Class structure for #GSocketListener."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketListenerClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(listener: *mut GSocketListener)>,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut GSocketListener,
            event: GSocketListenerEvent,
            socket: *mut GSocket,
        ),
    >,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketListenerClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketListenerClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketListenerClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GSocketListenerClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketListenerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketListenerClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketListener {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketListenerPrivate,
}
#[test]
fn bindgen_test_layout__GSocketListener() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketListener> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketListener>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketListener))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketListener>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketListener))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListener),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListener),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_listener_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_listener_new() -> *mut GSocketListener;
}
extern "C" {
    pub fn g_socket_listener_set_backlog(
        listener: *mut GSocketListener,
        listen_backlog: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_socket_listener_add_socket(
        listener: *mut GSocketListener,
        socket: *mut GSocket,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_listener_add_address(
        listener: *mut GSocketListener,
        address: *mut GSocketAddress,
        type_: GSocketType,
        protocol: GSocketProtocol,
        source_object: *mut GObject,
        effective_address: *mut *mut GSocketAddress,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_listener_add_inet_port(
        listener: *mut GSocketListener,
        port: guint16,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_listener_add_any_inet_port(
        listener: *mut GSocketListener,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> guint16;
}
extern "C" {
    pub fn g_socket_listener_accept_socket(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_listener_accept_socket_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_listener_accept_socket_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_listener_accept(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_listener_accept_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_listener_accept_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GSocketServicePrivate = _GSocketServicePrivate;
#[doc = " GSocketServiceClass:\n @incoming: signal emitted when new connections are accepted\n\n Class structure for #GSocketService."]
pub type GSocketServiceClass = _GSocketServiceClass;
#[doc = " GSocketServiceClass:\n @incoming: signal emitted when new connections are accepted\n\n Class structure for #GSocketService."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketServiceClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketServiceClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GSocketServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(incoming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GSocketService {
    pub parent_instance: GSocketListener,
    pub priv_: *mut GSocketServicePrivate,
}
#[test]
fn bindgen_test_layout__GSocketService() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketService>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketService),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_service_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_service_new() -> *mut GSocketService;
}
extern "C" {
    pub fn g_socket_service_start(service: *mut GSocketService);
}
extern "C" {
    pub fn g_socket_service_stop(service: *mut GSocketService);
}
extern "C" {
    pub fn g_socket_service_is_active(service: *mut GSocketService) -> gboolean;
}
extern "C" {
    pub fn g_srv_target_get_type() -> GType;
}
extern "C" {
    pub fn g_srv_target_new(
        hostname: *const gchar,
        port: guint16,
        priority: guint16,
        weight: guint16,
    ) -> *mut GSrvTarget;
}
extern "C" {
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
}
extern "C" {
    pub fn g_srv_target_free(target: *mut GSrvTarget);
}
extern "C" {
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const gchar;
}
extern "C" {
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    pub fn g_srv_target_list_sort(targets: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_subprocess_get_type() -> GType;
}
extern "C" {
    #[doc = " Core API"]
    pub fn g_subprocess_new(
        flags: GSubprocessFlags,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_newv(
        argv: *const *const gchar,
        flags: GSubprocessFlags,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
extern "C" {
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
extern "C" {
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess) -> *const gchar;
}
extern "C" {
    pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess, signal_num: gint);
}
extern "C" {
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
}
extern "C" {
    pub fn g_subprocess_wait(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_wait_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_wait_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_wait_check(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_wait_check_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_wait_check_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    pub fn g_subprocess_communicate(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_communicate_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_communicate_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_communicate_utf8(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_communicate_utf8_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_communicate_utf8_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_launcher_get_type() -> GType;
}
extern "C" {
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags) -> *mut GSubprocessLauncher;
}
extern "C" {
    pub fn g_subprocess_launcher_spawn(
        self_: *mut GSubprocessLauncher,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_launcher_spawnv(
        self_: *mut GSubprocessLauncher,
        argv: *const *const gchar,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_launcher_set_environ(self_: *mut GSubprocessLauncher, env: *mut *mut gchar);
}
extern "C" {
    pub fn g_subprocess_launcher_setenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_unsetenv(self_: *mut GSubprocessLauncher, variable: *const gchar);
}
extern "C" {
    pub fn g_subprocess_launcher_getenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_subprocess_launcher_set_cwd(self_: *mut GSubprocessLauncher, cwd: *const gchar);
}
extern "C" {
    pub fn g_subprocess_launcher_set_flags(
        self_: *mut GSubprocessLauncher,
        flags: GSubprocessFlags,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_set_stdin_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_take_stdin_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    pub fn g_subprocess_launcher_set_stdout_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_take_stdout_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    pub fn g_subprocess_launcher_set_stderr_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_take_stderr_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    pub fn g_subprocess_launcher_take_fd(
        self_: *mut GSubprocessLauncher,
        source_fd: gint,
        target_fd: gint,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_close(self_: *mut GSubprocessLauncher);
}
extern "C" {
    pub fn g_subprocess_launcher_set_child_setup(
        self_: *mut GSubprocessLauncher,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTaskClass {
    _unused: [u8; 0],
}
pub type GTaskClass = _GTaskClass;
extern "C" {
    pub fn g_task_get_type() -> GType;
}
extern "C" {
    pub fn g_task_new(
        source_object: gpointer,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
    ) -> *mut GTask;
}
extern "C" {
    pub fn g_task_report_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        error: *mut GError,
    );
}
extern "C" {
    pub fn g_task_report_new_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_task_set_task_data(
        task: *mut GTask,
        task_data: gpointer,
        task_data_destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_task_set_priority(task: *mut GTask, priority: gint);
}
extern "C" {
    pub fn g_task_set_check_cancellable(task: *mut GTask, check_cancellable: gboolean);
}
extern "C" {
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
}
extern "C" {
    pub fn g_task_set_name(task: *mut GTask, name: *const gchar);
}
extern "C" {
    pub fn g_task_set_static_name(task: *mut GTask, name: *const gchar);
}
extern "C" {
    pub fn g_task_get_source_object(task: *mut GTask) -> gpointer;
}
extern "C" {
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
}
extern "C" {
    pub fn g_task_get_priority(task: *mut GTask) -> gint;
}
extern "C" {
    pub fn g_task_get_context(task: *mut GTask) -> *mut GMainContext;
}
extern "C" {
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
}
extern "C" {
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
}
extern "C" {
    pub fn g_task_get_name(task: *mut GTask) -> *const gchar;
}
extern "C" {
    pub fn g_task_is_valid(result: gpointer, source_object: gpointer) -> gboolean;
}
pub type GTaskThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut GTask,
        source_object: gpointer,
        task_data: gpointer,
        cancellable: *mut GCancellable,
    ),
>;
extern "C" {
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
}
extern "C" {
    pub fn g_task_run_in_thread_sync(task: *mut GTask, task_func: GTaskThreadFunc);
}
extern "C" {
    pub fn g_task_set_return_on_cancel(task: *mut GTask, return_on_cancel: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_attach_source(task: *mut GTask, source: *mut GSource, callback: GSourceFunc);
}
extern "C" {
    pub fn g_task_return_pointer(
        task: *mut GTask,
        result: gpointer,
        result_destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
}
extern "C" {
    pub fn g_task_return_int(task: *mut GTask, result: gssize);
}
extern "C" {
    pub fn g_task_return_error(task: *mut GTask, error: *mut GError);
}
extern "C" {
    pub fn g_task_return_new_error(
        task: *mut GTask,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_task_return_value(task: *mut GTask, result: *mut GValue);
}
extern "C" {
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_propagate_pointer(task: *mut GTask, error: *mut *mut GError) -> gpointer;
}
extern "C" {
    pub fn g_task_propagate_boolean(task: *mut GTask, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_task_propagate_int(task: *mut GTask, error: *mut *mut GError) -> gssize;
}
extern "C" {
    pub fn g_task_propagate_value(
        task: *mut GTask,
        value: *mut GValue,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_print_alive_tasks();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpConnectionPrivate = _GTcpConnectionPrivate;
pub type GTcpConnectionClass = _GTcpConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[test]
fn bindgen_test_layout__GTcpConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpConnectionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GTcpConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GTcpConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTcpConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpConnection>(),
        48usize,
        concat!("Size of: ", stringify!(_GTcpConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_tcp_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tcp_connection_set_graceful_disconnect(
        connection: *mut GTcpConnection,
        graceful_disconnect: gboolean,
    );
}
extern "C" {
    pub fn g_tcp_connection_get_graceful_disconnect(connection: *mut GTcpConnection) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate;
pub type GTcpWrapperConnectionClass = _GTcpWrapperConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}
#[test]
fn bindgen_test_layout__GTcpWrapperConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpWrapperConnectionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpWrapperConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GTcpWrapperConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpWrapperConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpWrapperConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub priv_: *mut GTcpWrapperConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTcpWrapperConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpWrapperConnection> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpWrapperConnection>(),
        56usize,
        concat!("Size of: ", stringify!(_GTcpWrapperConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpWrapperConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpWrapperConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tcp_wrapper_connection_new(
        base_io_stream: *mut GIOStream,
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_tcp_wrapper_connection_get_base_io_stream(
        conn: *mut GTcpWrapperConnection,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_test_dbus_get_type() -> GType;
}
extern "C" {
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
}
extern "C" {
    pub fn g_test_dbus_get_flags(self_: *mut GTestDBus) -> GTestDBusFlags;
}
extern "C" {
    pub fn g_test_dbus_get_bus_address(self_: *mut GTestDBus) -> *const gchar;
}
extern "C" {
    pub fn g_test_dbus_add_service_dir(self_: *mut GTestDBus, path: *const gchar);
}
extern "C" {
    pub fn g_test_dbus_up(self_: *mut GTestDBus);
}
extern "C" {
    pub fn g_test_dbus_stop(self_: *mut GTestDBus);
}
extern "C" {
    pub fn g_test_dbus_down(self_: *mut GTestDBus);
}
extern "C" {
    pub fn g_test_dbus_unset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIconClass {
    _unused: [u8; 0],
}
#[doc = " GThemedIcon:\n\n An implementation of #GIcon for themed icons."]
pub type GThemedIconClass = _GThemedIconClass;
extern "C" {
    pub fn g_themed_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_themed_icon_new(iconname: *const ::std::os::raw::c_char) -> *mut GIcon;
}
extern "C" {
    pub fn g_themed_icon_new_with_default_fallbacks(
        iconname: *const ::std::os::raw::c_char,
    ) -> *mut GIcon;
}
extern "C" {
    pub fn g_themed_icon_new_from_names(
        iconnames: *mut *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut GIcon;
}
extern "C" {
    pub fn g_themed_icon_prepend_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_themed_icon_append_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon) -> *const *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate;
pub type GThreadedSocketServiceClass = _GThreadedSocketServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GThreadedSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GThreadedSocketServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadedSocketServiceClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadedSocketServiceClass>(),
        296usize,
        concat!("Size of: ", stringify!(_GThreadedSocketServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadedSocketServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadedSocketServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub priv_: *mut GThreadedSocketServicePrivate,
}
#[test]
fn bindgen_test_layout__GThreadedSocketService() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadedSocketService> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadedSocketService>(),
        48usize,
        concat!("Size of: ", stringify!(_GThreadedSocketService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadedSocketService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadedSocketService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketService),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_threaded_socket_service_get_type() -> GType;
}
extern "C" {
    pub fn g_threaded_socket_service_new(max_threads: ::std::os::raw::c_int)
        -> *mut GSocketService;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackend {
    _unused: [u8; 0],
}
pub type GTlsBackend = _GTlsBackend;
#[doc = " GTlsBackendInterface:\n @g_iface: The parent interface.\n @supports_tls: returns whether the backend supports TLS.\n @supports_dtls: returns whether the backend supports DTLS\n @get_default_database: returns a default #GTlsDatabase instance.\n @get_certificate_type: returns the #GTlsCertificate implementation type\n @get_client_connection_type: returns the #GTlsClientConnection implementation type\n @get_server_connection_type: returns the #GTlsServerConnection implementation type\n @get_file_database_type: returns the #GTlsFileDatabase implementation type.\n @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type\n @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type\n\n Provides an interface for describing TLS-related types.\n\n Since: 2.28"]
pub type GTlsBackendInterface = _GTlsBackendInterface;
#[doc = " GTlsBackendInterface:\n @g_iface: The parent interface.\n @supports_tls: returns whether the backend supports TLS.\n @supports_dtls: returns whether the backend supports DTLS\n @get_default_database: returns a default #GTlsDatabase instance.\n @get_certificate_type: returns the #GTlsCertificate implementation type\n @get_client_connection_type: returns the #GTlsClientConnection implementation type\n @get_server_connection_type: returns the #GTlsServerConnection implementation type\n @get_file_database_type: returns the #GTlsFileDatabase implementation type.\n @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type\n @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type\n\n Provides an interface for describing TLS-related types.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsBackendInterface {
    pub g_iface: GTypeInterface,
    pub supports_tls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_certificate_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_file_database_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_default_database:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> *mut GTlsDatabase>,
    pub supports_dtls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_dtls_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_dtls_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
}
#[test]
fn bindgen_test_layout__GTlsBackendInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsBackendInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsBackendInterface>(),
        88usize,
        concat!("Size of: ", stringify!(_GTlsBackendInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsBackendInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsBackendInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_tls) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(supports_tls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_certificate_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_certificate_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_client_connection_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_client_connection_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_server_connection_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_server_connection_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_file_database_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_file_database_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_default_database) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_default_database)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dtls) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(supports_dtls)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_dtls_client_connection_type) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_dtls_client_connection_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_dtls_server_connection_type) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_dtls_server_connection_type)
        )
    );
}
extern "C" {
    pub fn g_tls_backend_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
}
extern "C" {
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend) -> *mut GTlsDatabase;
}
extern "C" {
    pub fn g_tls_backend_set_default_database(
        backend: *mut GTlsBackend,
        database: *mut GTlsDatabase,
    );
}
extern "C" {
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;
}
extern "C" {
    pub fn g_tls_backend_supports_dtls(backend: *mut GTlsBackend) -> gboolean;
}
extern "C" {
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_dtls_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_dtls_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
pub type GTlsCertificateClass = _GTlsCertificateClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificatePrivate {
    _unused: [u8; 0],
}
pub type GTlsCertificatePrivate = _GTlsCertificatePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsCertificate {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsCertificatePrivate,
}
#[test]
fn bindgen_test_layout__GTlsCertificate() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsCertificate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsCertificate>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsCertificate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsCertificate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsCertificate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificate),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificate),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsCertificateClass {
    pub parent_class: GObjectClass,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            cert: *mut GTlsCertificate,
            identity: *mut GSocketConnectable,
            trusted_ca: *mut GTlsCertificate,
        ) -> GTlsCertificateFlags,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsCertificateClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsCertificateClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsCertificateClass>(),
        208usize,
        concat!("Size of: ", stringify!(_GTlsCertificateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsCertificateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsCertificateClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_certificate_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_certificate_new_from_pem(
        data: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_pkcs12(
        data: *const guint8,
        length: gsize,
        password: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_file_with_password(
        file: *const gchar,
        password: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_files(
        cert_file: *const gchar,
        key_file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_pkcs11_uris(
        pkcs11_uri: *const gchar,
        private_key_pkcs11_uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_list_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_verify(
        cert: *mut GTlsCertificate,
        identity: *mut GSocketConnectable,
        trusted_ca: *mut GTlsCertificate,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_certificate_is_same(
        cert_one: *mut GTlsCertificate,
        cert_two: *mut GTlsCertificate,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_certificate_get_not_valid_before(cert: *mut GTlsCertificate) -> *mut GDateTime;
}
extern "C" {
    pub fn g_tls_certificate_get_not_valid_after(cert: *mut GTlsCertificate) -> *mut GDateTime;
}
extern "C" {
    pub fn g_tls_certificate_get_subject_name(cert: *mut GTlsCertificate) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_certificate_get_issuer_name(cert: *mut GTlsCertificate) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_certificate_get_dns_names(cert: *mut GTlsCertificate) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_tls_certificate_get_ip_addresses(cert: *mut GTlsCertificate) -> *mut GPtrArray;
}
#[doc = " GTlsConnectionClass:\n @parent_class: The parent class.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)\n\n The class structure for the #GTlsConnection type.\n\n Since: 2.28"]
pub type GTlsConnectionClass = _GTlsConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTlsConnectionPrivate = _GTlsConnectionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GTlsConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTlsConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsConnection>(),
        40usize,
        concat!("Size of: ", stringify!(_GTlsConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnection),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GTlsConnectionClass:\n @parent_class: The parent class.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)\n\n The class structure for the #GTlsConnection type.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GTlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_binding_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            type_: GTlsChannelBindingType,
            data: *mut GByteArray,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_negotiated_protocol:
        ::std::option::Option<unsafe extern "C" fn(conn: *mut GTlsConnection) -> *const gchar>,
    pub padding: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GTlsConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsConnectionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsConnectionClass>(),
        352usize,
        concat!("Size of: ", stringify!(_GTlsConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_certificate) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(accept_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_async) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_finish) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_binding_data) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(get_binding_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_negotiated_protocol) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(get_negotiated_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_connection_set_use_system_certdb(
        conn: *mut GTlsConnection,
        use_system_certdb: gboolean,
    );
}
extern "C" {
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection, database: *mut GTlsDatabase);
}
extern "C" {
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection) -> *mut GTlsDatabase;
}
extern "C" {
    pub fn g_tls_connection_set_certificate(
        conn: *mut GTlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
extern "C" {
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_connection_set_interaction(
        conn: *mut GTlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
extern "C" {
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection) -> *mut GTlsInteraction;
}
extern "C" {
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection)
        -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_connection_get_peer_certificate_errors(
        conn: *mut GTlsConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_connection_set_require_close_notify(
        conn: *mut GTlsConnection,
        require_close_notify: gboolean,
    );
}
extern "C" {
    pub fn g_tls_connection_get_require_close_notify(conn: *mut GTlsConnection) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_set_rehandshake_mode(
        conn: *mut GTlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
extern "C" {
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection) -> GTlsRehandshakeMode;
}
extern "C" {
    pub fn g_tls_connection_set_advertised_protocols(
        conn: *mut GTlsConnection,
        protocols: *const *const gchar,
    );
}
extern "C" {
    pub fn g_tls_connection_get_negotiated_protocol(conn: *mut GTlsConnection) -> *const gchar;
}
extern "C" {
    pub fn g_tls_connection_get_channel_binding_data(
        conn: *mut GTlsConnection,
        type_: GTlsChannelBindingType,
        data: *mut GByteArray,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_handshake(
        conn: *mut GTlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_handshake_async(
        conn: *mut GTlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_connection_handshake_finish(
        conn: *mut GTlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_get_protocol_version(conn: *mut GTlsConnection) -> GTlsProtocolVersion;
}
extern "C" {
    pub fn g_tls_connection_get_ciphersuite_name(conn: *mut GTlsConnection) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_tls_channel_binding_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_tls_connection_emit_accept_certificate(
        conn: *mut GTlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
#[doc = " GTlsClientConnectionInterface:\n @g_iface: The parent interface.\n @copy_session_state: Copies session state from one #GTlsClientConnection to another.\n\n vtable for a #GTlsClientConnection implementation.\n\n Since: 2.26"]
pub type GTlsClientConnectionInterface = _GTlsClientConnectionInterface;
#[doc = " GTlsClientConnectionInterface:\n @g_iface: The parent interface.\n @copy_session_state: Copies session state from one #GTlsClientConnection to another.\n\n vtable for a #GTlsClientConnection implementation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
    pub copy_session_state: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GTlsClientConnection, source: *mut GTlsClientConnection),
    >,
}
#[test]
fn bindgen_test_layout__GTlsClientConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsClientConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsClientConnectionInterface>(),
        24usize,
        concat!("Size of: ", stringify!(_GTlsClientConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsClientConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsClientConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsClientConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_session_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsClientConnectionInterface),
            "::",
            stringify!(copy_session_state)
        )
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_client_connection_new(
        base_io_stream: *mut GIOStream,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_tls_client_connection_get_validation_flags(
        conn: *mut GTlsClientConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_client_connection_set_validation_flags(
        conn: *mut GTlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_server_identity(
        conn: *mut GTlsClientConnection,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_tls_client_connection_set_server_identity(
        conn: *mut GTlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_use_ssl3(conn: *mut GTlsClientConnection) -> gboolean;
}
extern "C" {
    pub fn g_tls_client_connection_set_use_ssl3(
        conn: *mut GTlsClientConnection,
        use_ssl3: gboolean,
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_accepted_cas(conn: *mut GTlsClientConnection) -> *mut GList;
}
extern "C" {
    pub fn g_tls_client_connection_copy_session_state(
        conn: *mut GTlsClientConnection,
        source: *mut GTlsClientConnection,
    );
}
pub type GTlsDatabaseClass = _GTlsDatabaseClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabasePrivate {
    _unused: [u8; 0],
}
pub type GTlsDatabasePrivate = _GTlsDatabasePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsDatabase {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsDatabasePrivate,
}
#[test]
fn bindgen_test_layout__GTlsDatabase() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsDatabase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsDatabase>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsDatabase))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsDatabase>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsDatabase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabase),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabase),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsDatabaseClass {
    pub parent_class: GObjectClass,
    pub verify_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub verify_chain_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub verify_chain_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub create_certificate_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
        ) -> *mut gchar,
    >,
    pub lookup_certificate_for_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_for_handle_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_for_handle_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_issuer_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificates_issued_by: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_certificates_issued_by_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificates_issued_by_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub padding: [gpointer; 16usize],
}
#[test]
fn bindgen_test_layout__GTlsDatabaseClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsDatabaseClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsDatabaseClass>(),
        368usize,
        concat!("Size of: ", stringify!(_GTlsDatabaseClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsDatabaseClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsDatabaseClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_chain) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_chain_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_chain_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_certificate_handle) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(create_certificate_handle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_for_handle) as usize - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_for_handle_async) as usize - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_for_handle_finish) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_certificate_issuer) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_issuer_async) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_issuer_finish) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer_finish)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificates_issued_by) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificates_issued_by_async) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificates_issued_by_finish) as usize
                - ptr as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_database_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_database_verify_chain(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_database_verify_chain_async(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_verify_chain_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_database_create_certificate_handle(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle_async(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer_async(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by_async(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
#[doc = " GTlsFileDatabaseInterface:\n @g_iface: The parent interface.\n\n Provides an interface for #GTlsFileDatabase implementations.\n"]
pub type GTlsFileDatabaseInterface = _GTlsFileDatabaseInterface;
#[doc = " GTlsFileDatabaseInterface:\n @g_iface: The parent interface.\n\n Provides an interface for #GTlsFileDatabase implementations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsFileDatabaseInterface {
    pub g_iface: GTypeInterface,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsFileDatabaseInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsFileDatabaseInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsFileDatabaseInterface>(),
        80usize,
        concat!("Size of: ", stringify!(_GTlsFileDatabaseInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsFileDatabaseInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsFileDatabaseInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsFileDatabaseInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsFileDatabaseInterface),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_file_database_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_file_database_new(
        anchors: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsDatabase;
}
pub type GTlsInteractionClass = _GTlsInteractionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionPrivate {
    _unused: [u8; 0],
}
pub type GTlsInteractionPrivate = _GTlsInteractionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsInteraction {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsInteractionPrivate,
}
#[test]
fn bindgen_test_layout__GTlsInteraction() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsInteraction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsInteraction>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsInteraction))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsInteraction>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsInteraction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteraction),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteraction),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsInteractionClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub ask_password_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub ask_password_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub request_certificate_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub padding: [gpointer; 21usize],
}
#[test]
fn bindgen_test_layout__GTlsInteractionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsInteractionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsInteractionClass>(),
        352usize,
        concat!("Size of: ", stringify!(_GTlsInteractionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsInteractionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsInteractionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_certificate) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_certificate_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_certificate_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_interaction_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_interaction_invoke_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_ask_password_async(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_interaction_ask_password_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_invoke_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_request_certificate_async(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_interaction_request_certificate_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
#[doc = " GTlsPasswordClass:\n @get_value: virtual method for g_tls_password_get_value()\n @set_value: virtual method for g_tls_password_set_value()\n @get_default_warning: virtual method for g_tls_password_get_warning() if no\n  value has been set using g_tls_password_set_warning()\n\n Class structure for #GTlsPassword."]
pub type GTlsPasswordClass = _GTlsPasswordClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordPrivate {
    _unused: [u8; 0],
}
pub type GTlsPasswordPrivate = _GTlsPasswordPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsPassword {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsPasswordPrivate,
}
#[test]
fn bindgen_test_layout__GTlsPassword() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsPassword> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsPassword>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsPassword))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsPassword>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsPassword))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPassword),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPassword),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GTlsPasswordClass:\n @get_value: virtual method for g_tls_password_get_value()\n @set_value: virtual method for g_tls_password_set_value()\n @get_default_warning: virtual method for g_tls_password_get_warning() if no\n  value has been set using g_tls_password_set_warning()\n\n Class structure for #GTlsPassword."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsPasswordClass {
    pub parent_class: GObjectClass,
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(password: *mut GTlsPassword, length: *mut gsize) -> *const guchar,
    >,
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            password: *mut GTlsPassword,
            value: *mut guchar,
            length: gssize,
            destroy: GDestroyNotify,
        ),
    >,
    pub get_default_warning:
        ::std::option::Option<unsafe extern "C" fn(password: *mut GTlsPassword) -> *const gchar>,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GTlsPasswordClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsPasswordClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsPasswordClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GTlsPasswordClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsPasswordClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsPasswordClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_default_warning) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(get_default_warning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_password_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_password_new(
        flags: GTlsPasswordFlags,
        description: *const gchar,
    ) -> *mut GTlsPassword;
}
extern "C" {
    pub fn g_tls_password_get_value(
        password: *mut GTlsPassword,
        length: *mut gsize,
    ) -> *const guchar;
}
extern "C" {
    pub fn g_tls_password_set_value(
        password: *mut GTlsPassword,
        value: *const guchar,
        length: gssize,
    );
}
extern "C" {
    pub fn g_tls_password_set_value_full(
        password: *mut GTlsPassword,
        value: *mut guchar,
        length: gssize,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword) -> GTlsPasswordFlags;
}
extern "C" {
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword, flags: GTlsPasswordFlags);
}
extern "C" {
    pub fn g_tls_password_get_description(password: *mut GTlsPassword) -> *const gchar;
}
extern "C" {
    pub fn g_tls_password_set_description(password: *mut GTlsPassword, description: *const gchar);
}
extern "C" {
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword) -> *const gchar;
}
extern "C" {
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword, warning: *const gchar);
}
#[doc = " GTlsServerConnection:\n\n TLS server-side connection. This is the server-side implementation\n of a #GTlsConnection.\n\n Since: 2.28"]
pub type GTlsServerConnectionInterface = _GTlsServerConnectionInterface;
#[doc = " GTlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GTlsServerConnection implementation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GTlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GTlsServerConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsServerConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsServerConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTlsServerConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsServerConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsServerConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsServerConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_tls_server_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_server_connection_new(
        base_io_stream: *mut GIOStream,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
pub type GUnixConnection = _GUnixConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnectionPrivate {
    _unused: [u8; 0],
}
pub type GUnixConnectionPrivate = _GUnixConnectionPrivate;
pub type GUnixConnectionClass = _GUnixConnectionClass;
pub type GUnixConnection_autoptr = *mut GUnixConnection;
pub type GUnixConnection_listautoptr = *mut GList;
pub type GUnixConnection_slistautoptr = *mut GSList;
pub type GUnixConnection_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[test]
fn bindgen_test_layout__GUnixConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixConnectionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GUnixConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GUnixConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GUnixConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixConnection>(),
        48usize,
        concat!("Size of: ", stringify!(_GUnixConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_unix_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_connection_send_fd(
        connection: *mut GUnixConnection,
        fd: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unix_connection_receive_fd(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_unix_connection_send_credentials(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unix_connection_send_credentials_async(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_unix_connection_send_credentials_finish(
        connection: *mut GUnixConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unix_connection_receive_credentials(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_unix_connection_receive_credentials_async(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_unix_connection_receive_credentials_finish(
        connection: *mut GUnixConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessagePrivate {
    _unused: [u8; 0],
}
pub type GUnixCredentialsMessagePrivate = _GUnixCredentialsMessagePrivate;
#[doc = " GUnixCredentialsMessageClass:\n\n Class structure for #GUnixCredentialsMessage.\n\n Since: 2.26"]
pub type GUnixCredentialsMessageClass = _GUnixCredentialsMessageClass;
pub type GUnixCredentialsMessage_autoptr = *mut GUnixCredentialsMessage;
pub type GUnixCredentialsMessage_listautoptr = *mut GList;
pub type GUnixCredentialsMessage_slistautoptr = *mut GSList;
pub type GUnixCredentialsMessage_queueautoptr = *mut GQueue;
#[doc = " GUnixCredentialsMessageClass:\n\n Class structure for #GUnixCredentialsMessage.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixCredentialsMessageClass {
    pub parent_class: GSocketControlMessageClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GUnixCredentialsMessageClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixCredentialsMessageClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixCredentialsMessageClass>(),
        232usize,
        concat!("Size of: ", stringify!(_GUnixCredentialsMessageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixCredentialsMessageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixCredentialsMessageClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessageClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessageClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
}
#[doc = " GUnixCredentialsMessage:\n\n The #GUnixCredentialsMessage structure contains only private data\n and should only be accessed using the provided API.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixCredentialsMessage {
    pub parent_instance: GSocketControlMessage,
    pub priv_: *mut GUnixCredentialsMessagePrivate,
}
#[test]
fn bindgen_test_layout__GUnixCredentialsMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixCredentialsMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixCredentialsMessage>(),
        40usize,
        concat!("Size of: ", stringify!(_GUnixCredentialsMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixCredentialsMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixCredentialsMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessage),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_unix_credentials_message_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_credentials_message_new() -> *mut GSocketControlMessage;
}
extern "C" {
    pub fn g_unix_credentials_message_new_with_credentials(
        credentials: *mut GCredentials,
    ) -> *mut GSocketControlMessage;
}
extern "C" {
    pub fn g_unix_credentials_message_get_credentials(
        message: *mut GUnixCredentialsMessage,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_unix_credentials_message_is_supported() -> gboolean;
}
pub type GUnixFDList_autoptr = *mut GUnixFDList;
pub type GUnixFDList_listautoptr = *mut GList;
pub type GUnixFDList_slistautoptr = *mut GSList;
pub type GUnixFDList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDListPrivate {
    _unused: [u8; 0],
}
pub type GUnixFDListPrivate = _GUnixFDListPrivate;
pub type GUnixFDListClass = _GUnixFDListClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixFDListClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GUnixFDListClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixFDListClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixFDListClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GUnixFDListClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixFDListClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixFDListClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixFDList {
    pub parent_instance: GObject,
    pub priv_: *mut GUnixFDListPrivate,
}
#[test]
fn bindgen_test_layout__GUnixFDList() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixFDList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixFDList>(),
        32usize,
        concat!("Size of: ", stringify!(_GUnixFDList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixFDList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixFDList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDList),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDList),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_unix_fd_list_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_fd_list_new() -> *mut GUnixFDList;
}
extern "C" {
    pub fn g_unix_fd_list_new_from_array(fds: *const gint, n_fds: gint) -> *mut GUnixFDList;
}
extern "C" {
    pub fn g_unix_fd_list_append(list: *mut GUnixFDList, fd: gint, error: *mut *mut GError)
        -> gint;
}
extern "C" {
    pub fn g_unix_fd_list_get_length(list: *mut GUnixFDList) -> gint;
}
extern "C" {
    pub fn g_unix_fd_list_get(
        list: *mut GUnixFDList,
        index_: gint,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_unix_fd_list_peek_fds(list: *mut GUnixFDList, length: *mut gint) -> *const gint;
}
extern "C" {
    pub fn g_unix_fd_list_steal_fds(list: *mut GUnixFDList, length: *mut gint) -> *mut gint;
}
pub type GUnixSocketAddress = _GUnixSocketAddress;
pub type GUnixSocketAddressClass = _GUnixSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GUnixSocketAddressPrivate = _GUnixSocketAddressPrivate;
pub type GUnixSocketAddress_autoptr = *mut GUnixSocketAddress;
pub type GUnixSocketAddress_listautoptr = *mut GList;
pub type GUnixSocketAddress_slistautoptr = *mut GSList;
pub type GUnixSocketAddress_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GUnixSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GUnixSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixSocketAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GUnixSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GUnixSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GUnixSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixSocketAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GUnixSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_unix_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_socket_address_new(path: *const gchar) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_unix_socket_address_new_abstract(
        path: *const gchar,
        path_len: gint,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_unix_socket_address_new_with_type(
        path: *const gchar,
        path_len: gint,
        type_: GUnixSocketAddressType,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_unix_socket_address_get_path(
        address: *mut GUnixSocketAddress,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_unix_socket_address_get_path_len(address: *mut GUnixSocketAddress) -> gsize;
}
extern "C" {
    pub fn g_unix_socket_address_get_address_type(
        address: *mut GUnixSocketAddress,
    ) -> GUnixSocketAddressType;
}
extern "C" {
    pub fn g_unix_socket_address_get_is_abstract(address: *mut GUnixSocketAddress) -> gboolean;
}
extern "C" {
    pub fn g_unix_socket_address_abstract_names_supported() -> gboolean;
}
#[doc = " GVfsFileLookupFunc:\n @vfs: a #GVfs\n @identifier: the identifier to look up a #GFile for. This can either\n     be an URI or a parse name as returned by g_file_get_parse_name()\n @user_data: user data passed to the function\n\n This function type is used by g_vfs_register_uri_scheme() to make it\n possible for a client to associate an URI scheme to a different #GFile\n implementation.\n\n The client should return a reference to the new file that has been\n created for @uri, or %NULL to continue with the default implementation.\n\n Returns: (transfer full): a #GFile for @identifier.\n\n Since: 2.50"]
pub type GVfsFileLookupFunc = ::std::option::Option<
    unsafe extern "C" fn(
        vfs: *mut GVfs,
        identifier: *const ::std::os::raw::c_char,
        user_data: gpointer,
    ) -> *mut GFile,
>;
#[doc = " GVfs:\n\n Virtual File System object."]
pub type GVfsClass = _GVfsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVfs {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GVfs() {
    const UNINIT: ::std::mem::MaybeUninit<_GVfs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVfs>(),
        24usize,
        concat!("Size of: ", stringify!(_GVfs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVfs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVfs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfs),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVfsClass {
    pub parent_class: GObjectClass,
    pub is_active: ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> gboolean>,
    pub get_file_for_path: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, path: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_file_for_uri: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_supported_uri_schemes:
        ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> *const *const gchar>,
    pub parse_name: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            parse_name: *const ::std::os::raw::c_char,
        ) -> *mut GFile,
    >,
    pub local_file_add_info: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            device: guint64,
            attribute_matcher: *mut GFileAttributeMatcher,
            info: *mut GFileInfo,
            cancellable: *mut GCancellable,
            extra_data: *mut gpointer,
            free_extra_data: *mut GDestroyNotify,
        ),
    >,
    pub add_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, list: *mut GFileAttributeInfoList),
    >,
    pub local_file_set_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub local_file_removed: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, filename: *const ::std::os::raw::c_char),
    >,
    pub local_file_moved: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            source: *const ::std::os::raw::c_char,
            dest: *const ::std::os::raw::c_char,
        ),
    >,
    pub deserialize_icon: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, value: *mut GVariant) -> *mut GIcon,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GVfsClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GVfsClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVfsClass>(),
        272usize,
        concat!("Size of: ", stringify!(_GVfsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVfsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVfsClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_active) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(is_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_file_for_path) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_file_for_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_file_for_uri) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_file_for_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_uri_schemes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_supported_uri_schemes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_name) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(parse_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_add_info) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_add_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_writable_namespaces) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(add_writable_namespaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_set_attributes) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_set_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_removed) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_moved) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_moved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deserialize_icon) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(deserialize_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    pub fn g_vfs_get_type() -> GType;
}
extern "C" {
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
}
extern "C" {
    pub fn g_vfs_get_file_for_path(
        vfs: *mut GVfs,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char)
        -> *mut GFile;
}
extern "C" {
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs) -> *const *const gchar;
}
extern "C" {
    pub fn g_vfs_parse_name(
        vfs: *mut GVfs,
        parse_name: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_vfs_get_default() -> *mut GVfs;
}
extern "C" {
    pub fn g_vfs_get_local() -> *mut GVfs;
}
extern "C" {
    pub fn g_vfs_register_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
        uri_func: GVfsFileLookupFunc,
        uri_data: gpointer,
        uri_destroy: GDestroyNotify,
        parse_name_func: GVfsFileLookupFunc,
        parse_name_data: gpointer,
        parse_name_destroy: GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_vfs_unregister_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
#[doc = " GVolumeIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the volume's state has changed.\n @removed: The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.\n @get_name: Gets a string containing the name of the #GVolume.\n @get_icon: Gets a #GIcon for the #GVolume.\n @get_uuid: Gets the UUID for the #GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_drive: Gets a #GDrive the volume is located on. Returns %NULL if the #GVolume is not associated with a #GDrive.\n @get_mount: Gets a #GMount representing the mounted volume. Returns %NULL if the #GVolume is not mounted.\n @can_mount: Returns %TRUE if the #GVolume can be mounted.\n @can_eject: Checks if a #GVolume can be ejected.\n @mount_fn: Mounts a given #GVolume.\n     #GVolume implementations must emit the #GMountOperation::aborted\n     signal before completing a mount operation that is aborted while\n     awaiting input from the user through a #GMountOperation instance.\n @mount_finish: Finishes a mount operation.\n @eject: Ejects a given #GVolume.\n @eject_finish: Finishes an eject operation.\n @get_identifier: Returns the [identifier][volume-identifier] of the given kind, or %NULL if\n    the #GVolume doesn't have one.\n @enumerate_identifiers: Returns an array strings listing the kinds\n    of [identifiers][volume-identifier] which the #GVolume has.\n @should_automount: Returns %TRUE if the #GVolume should be automatically mounted.\n @get_activation_root: Returns the activation root for the #GVolume if it is known in advance or %NULL if\n   it is not known.\n @eject_with_operation: Starts ejecting a #GVolume using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_sort_key: Gets a key used for sorting #GVolume instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GVolume. Since 2.34.\n\n Interface for implementing operations for mountable volumes."]
pub type GVolumeIface = _GVolumeIface;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GVolumeIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub removed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GDrive>,
    pub get_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GMount>,
    pub can_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub mount_fn: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            kind: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub should_automount:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub get_activation_root:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GFile>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
}
#[test]
fn bindgen_test_layout__GVolumeIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GVolumeIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVolumeIface>(),
        184usize,
        concat!("Size of: ", stringify!(_GVolumeIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uuid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_drive) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_mount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(can_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_eject) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_fn) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(mount_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_finish) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(mount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_finish) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_identifiers) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(enumerate_identifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).should_automount) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(should_automount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_activation_root) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_activation_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation_finish) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sort_key) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_symbolic_icon) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
}
extern "C" {
    pub fn g_volume_get_type() -> GType;
}
extern "C" {
    pub fn g_volume_get_name(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
}
extern "C" {
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
}
extern "C" {
    pub fn g_volume_get_uuid(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
}
extern "C" {
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
}
extern "C" {
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    pub fn g_volume_mount(
        volume: *mut GVolume,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_volume_mount_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_volume_eject(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_volume_eject_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_volume_get_identifier(
        volume: *mut GVolume,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume)
        -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
}
extern "C" {
    pub fn g_volume_eject_with_operation(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_volume_eject_with_operation_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const gchar;
}
pub type GZlibCompressorClass = _GZlibCompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GZlibCompressorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GZlibCompressorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GZlibCompressorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GZlibCompressorClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GZlibCompressorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GZlibCompressorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GZlibCompressorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GZlibCompressorClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_zlib_compressor_get_type() -> GType;
}
extern "C" {
    pub fn g_zlib_compressor_new(
        format: GZlibCompressorFormat,
        level: ::std::os::raw::c_int,
    ) -> *mut GZlibCompressor;
}
extern "C" {
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_zlib_compressor_set_file_info(
        compressor: *mut GZlibCompressor,
        file_info: *mut GFileInfo,
    );
}
pub type GZlibDecompressorClass = _GZlibDecompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _GZlibDecompressorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GZlibDecompressorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GZlibDecompressorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GZlibDecompressorClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GZlibDecompressorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GZlibDecompressorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GZlibDecompressorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GZlibDecompressorClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_zlib_decompressor_get_type() -> GType;
}
extern "C" {
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat) -> *mut GZlibDecompressor;
}
extern "C" {
    pub fn g_zlib_decompressor_get_file_info(
        decompressor: *mut GZlibDecompressor,
    ) -> *mut GFileInfo;
}
pub type GAction_autoptr = *mut GAction;
pub type GAction_listautoptr = *mut GList;
pub type GAction_slistautoptr = *mut GSList;
pub type GAction_queueautoptr = *mut GQueue;
pub type GActionMap_autoptr = *mut GActionMap;
pub type GActionMap_listautoptr = *mut GList;
pub type GActionMap_slistautoptr = *mut GSList;
pub type GActionMap_queueautoptr = *mut GQueue;
pub type GAppInfo_autoptr = *mut GAppInfo;
pub type GAppInfo_listautoptr = *mut GList;
pub type GAppInfo_slistautoptr = *mut GSList;
pub type GAppInfo_queueautoptr = *mut GQueue;
pub type GAppLaunchContext_autoptr = *mut GAppLaunchContext;
pub type GAppLaunchContext_listautoptr = *mut GList;
pub type GAppLaunchContext_slistautoptr = *mut GSList;
pub type GAppLaunchContext_queueautoptr = *mut GQueue;
pub type GAppInfoMonitor_autoptr = *mut GAppInfoMonitor;
pub type GAppInfoMonitor_listautoptr = *mut GList;
pub type GAppInfoMonitor_slistautoptr = *mut GSList;
pub type GAppInfoMonitor_queueautoptr = *mut GQueue;
pub type GApplicationCommandLine_autoptr = *mut GApplicationCommandLine;
pub type GApplicationCommandLine_listautoptr = *mut GList;
pub type GApplicationCommandLine_slistautoptr = *mut GSList;
pub type GApplicationCommandLine_queueautoptr = *mut GQueue;
pub type GApplication_autoptr = *mut GApplication;
pub type GApplication_listautoptr = *mut GList;
pub type GApplication_slistautoptr = *mut GSList;
pub type GApplication_queueautoptr = *mut GQueue;
pub type GAsyncInitable_autoptr = *mut GAsyncInitable;
pub type GAsyncInitable_listautoptr = *mut GList;
pub type GAsyncInitable_slistautoptr = *mut GSList;
pub type GAsyncInitable_queueautoptr = *mut GQueue;
pub type GAsyncResult_autoptr = *mut GAsyncResult;
pub type GAsyncResult_listautoptr = *mut GList;
pub type GAsyncResult_slistautoptr = *mut GSList;
pub type GAsyncResult_queueautoptr = *mut GQueue;
pub type GBufferedInputStream_autoptr = *mut GBufferedInputStream;
pub type GBufferedInputStream_listautoptr = *mut GList;
pub type GBufferedInputStream_slistautoptr = *mut GSList;
pub type GBufferedInputStream_queueautoptr = *mut GQueue;
pub type GBufferedOutputStream_autoptr = *mut GBufferedOutputStream;
pub type GBufferedOutputStream_listautoptr = *mut GList;
pub type GBufferedOutputStream_slistautoptr = *mut GSList;
pub type GBufferedOutputStream_queueautoptr = *mut GQueue;
pub type GBytesIcon_autoptr = *mut GBytesIcon;
pub type GBytesIcon_listautoptr = *mut GList;
pub type GBytesIcon_slistautoptr = *mut GSList;
pub type GBytesIcon_queueautoptr = *mut GQueue;
pub type GCancellable_autoptr = *mut GCancellable;
pub type GCancellable_listautoptr = *mut GList;
pub type GCancellable_slistautoptr = *mut GSList;
pub type GCancellable_queueautoptr = *mut GQueue;
pub type GCharsetConverter_autoptr = *mut GCharsetConverter;
pub type GCharsetConverter_listautoptr = *mut GList;
pub type GCharsetConverter_slistautoptr = *mut GSList;
pub type GCharsetConverter_queueautoptr = *mut GQueue;
pub type GConverter_autoptr = *mut GConverter;
pub type GConverter_listautoptr = *mut GList;
pub type GConverter_slistautoptr = *mut GSList;
pub type GConverter_queueautoptr = *mut GQueue;
pub type GConverterInputStream_autoptr = *mut GConverterInputStream;
pub type GConverterInputStream_listautoptr = *mut GList;
pub type GConverterInputStream_slistautoptr = *mut GSList;
pub type GConverterInputStream_queueautoptr = *mut GQueue;
pub type GConverterOutputStream_autoptr = *mut GConverterOutputStream;
pub type GConverterOutputStream_listautoptr = *mut GList;
pub type GConverterOutputStream_slistautoptr = *mut GSList;
pub type GConverterOutputStream_queueautoptr = *mut GQueue;
pub type GCredentials_autoptr = *mut GCredentials;
pub type GCredentials_listautoptr = *mut GList;
pub type GCredentials_slistautoptr = *mut GSList;
pub type GCredentials_queueautoptr = *mut GQueue;
pub type GDatagramBased_autoptr = *mut GDatagramBased;
pub type GDatagramBased_listautoptr = *mut GList;
pub type GDatagramBased_slistautoptr = *mut GSList;
pub type GDatagramBased_queueautoptr = *mut GQueue;
pub type GDataInputStream_autoptr = *mut GDataInputStream;
pub type GDataInputStream_listautoptr = *mut GList;
pub type GDataInputStream_slistautoptr = *mut GSList;
pub type GDataInputStream_queueautoptr = *mut GQueue;
pub type GDataOutputStream_autoptr = *mut GDataOutputStream;
pub type GDataOutputStream_listautoptr = *mut GList;
pub type GDataOutputStream_slistautoptr = *mut GSList;
pub type GDataOutputStream_queueautoptr = *mut GQueue;
pub type GDBusActionGroup_autoptr = *mut GDBusActionGroup;
pub type GDBusActionGroup_listautoptr = *mut GList;
pub type GDBusActionGroup_slistautoptr = *mut GSList;
pub type GDBusActionGroup_queueautoptr = *mut GQueue;
pub type GDBusAuthObserver_autoptr = *mut GDBusAuthObserver;
pub type GDBusAuthObserver_listautoptr = *mut GList;
pub type GDBusAuthObserver_slistautoptr = *mut GSList;
pub type GDBusAuthObserver_queueautoptr = *mut GQueue;
pub type GDBusConnection_autoptr = *mut GDBusConnection;
pub type GDBusConnection_listautoptr = *mut GList;
pub type GDBusConnection_slistautoptr = *mut GSList;
pub type GDBusConnection_queueautoptr = *mut GQueue;
pub type GDBusInterface_autoptr = *mut GDBusInterface;
pub type GDBusInterface_listautoptr = *mut GList;
pub type GDBusInterface_slistautoptr = *mut GSList;
pub type GDBusInterface_queueautoptr = *mut GQueue;
pub type GDBusInterfaceSkeleton_autoptr = *mut GDBusInterfaceSkeleton;
pub type GDBusInterfaceSkeleton_listautoptr = *mut GList;
pub type GDBusInterfaceSkeleton_slistautoptr = *mut GSList;
pub type GDBusInterfaceSkeleton_queueautoptr = *mut GQueue;
pub type GDBusMenuModel_autoptr = *mut GDBusMenuModel;
pub type GDBusMenuModel_listautoptr = *mut GList;
pub type GDBusMenuModel_slistautoptr = *mut GSList;
pub type GDBusMenuModel_queueautoptr = *mut GQueue;
pub type GDBusMessage_autoptr = *mut GDBusMessage;
pub type GDBusMessage_listautoptr = *mut GList;
pub type GDBusMessage_slistautoptr = *mut GSList;
pub type GDBusMessage_queueautoptr = *mut GQueue;
pub type GDBusMethodInvocation_autoptr = *mut GDBusMethodInvocation;
pub type GDBusMethodInvocation_listautoptr = *mut GList;
pub type GDBusMethodInvocation_slistautoptr = *mut GSList;
pub type GDBusMethodInvocation_queueautoptr = *mut GQueue;
pub type GDBusNodeInfo_autoptr = *mut GDBusNodeInfo;
pub type GDBusNodeInfo_listautoptr = *mut GList;
pub type GDBusNodeInfo_slistautoptr = *mut GSList;
pub type GDBusNodeInfo_queueautoptr = *mut GQueue;
pub type GDBusObject_autoptr = *mut GDBusObject;
pub type GDBusObject_listautoptr = *mut GList;
pub type GDBusObject_slistautoptr = *mut GSList;
pub type GDBusObject_queueautoptr = *mut GQueue;
pub type GDBusObjectManagerClient_autoptr = *mut GDBusObjectManagerClient;
pub type GDBusObjectManagerClient_listautoptr = *mut GList;
pub type GDBusObjectManagerClient_slistautoptr = *mut GSList;
pub type GDBusObjectManagerClient_queueautoptr = *mut GQueue;
pub type GDBusObjectManager_autoptr = *mut GDBusObjectManager;
pub type GDBusObjectManager_listautoptr = *mut GList;
pub type GDBusObjectManager_slistautoptr = *mut GSList;
pub type GDBusObjectManager_queueautoptr = *mut GQueue;
pub type GDBusObjectManagerServer_autoptr = *mut GDBusObjectManagerServer;
pub type GDBusObjectManagerServer_listautoptr = *mut GList;
pub type GDBusObjectManagerServer_slistautoptr = *mut GSList;
pub type GDBusObjectManagerServer_queueautoptr = *mut GQueue;
pub type GDBusObjectProxy_autoptr = *mut GDBusObjectProxy;
pub type GDBusObjectProxy_listautoptr = *mut GList;
pub type GDBusObjectProxy_slistautoptr = *mut GSList;
pub type GDBusObjectProxy_queueautoptr = *mut GQueue;
pub type GDBusObjectSkeleton_autoptr = *mut GDBusObjectSkeleton;
pub type GDBusObjectSkeleton_listautoptr = *mut GList;
pub type GDBusObjectSkeleton_slistautoptr = *mut GSList;
pub type GDBusObjectSkeleton_queueautoptr = *mut GQueue;
pub type GDBusProxy_autoptr = *mut GDBusProxy;
pub type GDBusProxy_listautoptr = *mut GList;
pub type GDBusProxy_slistautoptr = *mut GSList;
pub type GDBusProxy_queueautoptr = *mut GQueue;
pub type GDBusServer_autoptr = *mut GDBusServer;
pub type GDBusServer_listautoptr = *mut GList;
pub type GDBusServer_slistautoptr = *mut GSList;
pub type GDBusServer_queueautoptr = *mut GQueue;
pub type GDrive_autoptr = *mut GDrive;
pub type GDrive_listautoptr = *mut GList;
pub type GDrive_slistautoptr = *mut GSList;
pub type GDrive_queueautoptr = *mut GQueue;
pub type GEmblemedIcon_autoptr = *mut GEmblemedIcon;
pub type GEmblemedIcon_listautoptr = *mut GList;
pub type GEmblemedIcon_slistautoptr = *mut GSList;
pub type GEmblemedIcon_queueautoptr = *mut GQueue;
pub type GEmblem_autoptr = *mut GEmblem;
pub type GEmblem_listautoptr = *mut GList;
pub type GEmblem_slistautoptr = *mut GSList;
pub type GEmblem_queueautoptr = *mut GQueue;
pub type GFileEnumerator_autoptr = *mut GFileEnumerator;
pub type GFileEnumerator_listautoptr = *mut GList;
pub type GFileEnumerator_slistautoptr = *mut GSList;
pub type GFileEnumerator_queueautoptr = *mut GQueue;
pub type GFile_autoptr = *mut GFile;
pub type GFile_listautoptr = *mut GList;
pub type GFile_slistautoptr = *mut GSList;
pub type GFile_queueautoptr = *mut GQueue;
pub type GFileAttributeInfoList_autoptr = *mut GFileAttributeInfoList;
pub type GFileAttributeInfoList_listautoptr = *mut GList;
pub type GFileAttributeInfoList_slistautoptr = *mut GSList;
pub type GFileAttributeInfoList_queueautoptr = *mut GQueue;
pub type GFileIcon_autoptr = *mut GFileIcon;
pub type GFileIcon_listautoptr = *mut GList;
pub type GFileIcon_slistautoptr = *mut GSList;
pub type GFileIcon_queueautoptr = *mut GQueue;
pub type GFileInfo_autoptr = *mut GFileInfo;
pub type GFileInfo_listautoptr = *mut GList;
pub type GFileInfo_slistautoptr = *mut GSList;
pub type GFileInfo_queueautoptr = *mut GQueue;
pub type GFileInputStream_autoptr = *mut GFileInputStream;
pub type GFileInputStream_listautoptr = *mut GList;
pub type GFileInputStream_slistautoptr = *mut GSList;
pub type GFileInputStream_queueautoptr = *mut GQueue;
pub type GFileIOStream_autoptr = *mut GFileIOStream;
pub type GFileIOStream_listautoptr = *mut GList;
pub type GFileIOStream_slistautoptr = *mut GSList;
pub type GFileIOStream_queueautoptr = *mut GQueue;
pub type GFileMonitor_autoptr = *mut GFileMonitor;
pub type GFileMonitor_listautoptr = *mut GList;
pub type GFileMonitor_slistautoptr = *mut GSList;
pub type GFileMonitor_queueautoptr = *mut GQueue;
pub type GFilenameCompleter_autoptr = *mut GFilenameCompleter;
pub type GFilenameCompleter_listautoptr = *mut GList;
pub type GFilenameCompleter_slistautoptr = *mut GSList;
pub type GFilenameCompleter_queueautoptr = *mut GQueue;
pub type GFileOutputStream_autoptr = *mut GFileOutputStream;
pub type GFileOutputStream_listautoptr = *mut GList;
pub type GFileOutputStream_slistautoptr = *mut GSList;
pub type GFileOutputStream_queueautoptr = *mut GQueue;
pub type GFilterInputStream_autoptr = *mut GFilterInputStream;
pub type GFilterInputStream_listautoptr = *mut GList;
pub type GFilterInputStream_slistautoptr = *mut GSList;
pub type GFilterInputStream_queueautoptr = *mut GQueue;
pub type GFilterOutputStream_autoptr = *mut GFilterOutputStream;
pub type GFilterOutputStream_listautoptr = *mut GList;
pub type GFilterOutputStream_slistautoptr = *mut GSList;
pub type GFilterOutputStream_queueautoptr = *mut GQueue;
pub type GIcon_autoptr = *mut GIcon;
pub type GIcon_listautoptr = *mut GList;
pub type GIcon_slistautoptr = *mut GSList;
pub type GIcon_queueautoptr = *mut GQueue;
pub type GInetAddress_autoptr = *mut GInetAddress;
pub type GInetAddress_listautoptr = *mut GList;
pub type GInetAddress_slistautoptr = *mut GSList;
pub type GInetAddress_queueautoptr = *mut GQueue;
pub type GInetAddressMask_autoptr = *mut GInetAddressMask;
pub type GInetAddressMask_listautoptr = *mut GList;
pub type GInetAddressMask_slistautoptr = *mut GSList;
pub type GInetAddressMask_queueautoptr = *mut GQueue;
pub type GInetSocketAddress_autoptr = *mut GInetSocketAddress;
pub type GInetSocketAddress_listautoptr = *mut GList;
pub type GInetSocketAddress_slistautoptr = *mut GSList;
pub type GInetSocketAddress_queueautoptr = *mut GQueue;
pub type GInitable_autoptr = *mut GInitable;
pub type GInitable_listautoptr = *mut GList;
pub type GInitable_slistautoptr = *mut GSList;
pub type GInitable_queueautoptr = *mut GQueue;
pub type GInputStream_autoptr = *mut GInputStream;
pub type GInputStream_listautoptr = *mut GList;
pub type GInputStream_slistautoptr = *mut GSList;
pub type GInputStream_queueautoptr = *mut GQueue;
pub type GIOModule_autoptr = *mut GIOModule;
pub type GIOModule_listautoptr = *mut GList;
pub type GIOModule_slistautoptr = *mut GSList;
pub type GIOModule_queueautoptr = *mut GQueue;
pub type GIOStream_autoptr = *mut GIOStream;
pub type GIOStream_listautoptr = *mut GList;
pub type GIOStream_slistautoptr = *mut GSList;
pub type GIOStream_queueautoptr = *mut GQueue;
pub type GLoadableIcon_autoptr = *mut GLoadableIcon;
pub type GLoadableIcon_listautoptr = *mut GList;
pub type GLoadableIcon_slistautoptr = *mut GSList;
pub type GLoadableIcon_queueautoptr = *mut GQueue;
pub type GMemoryInputStream_autoptr = *mut GMemoryInputStream;
pub type GMemoryInputStream_listautoptr = *mut GList;
pub type GMemoryInputStream_slistautoptr = *mut GSList;
pub type GMemoryInputStream_queueautoptr = *mut GQueue;
pub type GMemoryOutputStream_autoptr = *mut GMemoryOutputStream;
pub type GMemoryOutputStream_listautoptr = *mut GList;
pub type GMemoryOutputStream_slistautoptr = *mut GSList;
pub type GMemoryOutputStream_queueautoptr = *mut GQueue;
pub type GMenu_autoptr = *mut GMenu;
pub type GMenu_listautoptr = *mut GList;
pub type GMenu_slistautoptr = *mut GSList;
pub type GMenu_queueautoptr = *mut GQueue;
pub type GMenuItem_autoptr = *mut GMenuItem;
pub type GMenuItem_listautoptr = *mut GList;
pub type GMenuItem_slistautoptr = *mut GSList;
pub type GMenuItem_queueautoptr = *mut GQueue;
pub type GMenuModel_autoptr = *mut GMenuModel;
pub type GMenuModel_listautoptr = *mut GList;
pub type GMenuModel_slistautoptr = *mut GSList;
pub type GMenuModel_queueautoptr = *mut GQueue;
pub type GMenuAttributeIter_autoptr = *mut GMenuAttributeIter;
pub type GMenuAttributeIter_listautoptr = *mut GList;
pub type GMenuAttributeIter_slistautoptr = *mut GSList;
pub type GMenuAttributeIter_queueautoptr = *mut GQueue;
pub type GMenuLinkIter_autoptr = *mut GMenuLinkIter;
pub type GMenuLinkIter_listautoptr = *mut GList;
pub type GMenuLinkIter_slistautoptr = *mut GSList;
pub type GMenuLinkIter_queueautoptr = *mut GQueue;
pub type GMount_autoptr = *mut GMount;
pub type GMount_listautoptr = *mut GList;
pub type GMount_slistautoptr = *mut GSList;
pub type GMount_queueautoptr = *mut GQueue;
pub type GMountOperation_autoptr = *mut GMountOperation;
pub type GMountOperation_listautoptr = *mut GList;
pub type GMountOperation_slistautoptr = *mut GSList;
pub type GMountOperation_queueautoptr = *mut GQueue;
pub type GNativeVolumeMonitor_autoptr = *mut GNativeVolumeMonitor;
pub type GNativeVolumeMonitor_listautoptr = *mut GList;
pub type GNativeVolumeMonitor_slistautoptr = *mut GSList;
pub type GNativeVolumeMonitor_queueautoptr = *mut GQueue;
pub type GNetworkAddress_autoptr = *mut GNetworkAddress;
pub type GNetworkAddress_listautoptr = *mut GList;
pub type GNetworkAddress_slistautoptr = *mut GSList;
pub type GNetworkAddress_queueautoptr = *mut GQueue;
pub type GNetworkMonitor_autoptr = *mut GNetworkMonitor;
pub type GNetworkMonitor_listautoptr = *mut GList;
pub type GNetworkMonitor_slistautoptr = *mut GSList;
pub type GNetworkMonitor_queueautoptr = *mut GQueue;
pub type GNetworkService_autoptr = *mut GNetworkService;
pub type GNetworkService_listautoptr = *mut GList;
pub type GNetworkService_slistautoptr = *mut GSList;
pub type GNetworkService_queueautoptr = *mut GQueue;
pub type GNotification_autoptr = *mut GNotification;
pub type GNotification_listautoptr = *mut GList;
pub type GNotification_slistautoptr = *mut GSList;
pub type GNotification_queueautoptr = *mut GQueue;
pub type GOutputStream_autoptr = *mut GOutputStream;
pub type GOutputStream_listautoptr = *mut GList;
pub type GOutputStream_slistautoptr = *mut GSList;
pub type GOutputStream_queueautoptr = *mut GQueue;
pub type GPermission_autoptr = *mut GPermission;
pub type GPermission_listautoptr = *mut GList;
pub type GPermission_slistautoptr = *mut GSList;
pub type GPermission_queueautoptr = *mut GQueue;
pub type GPollableInputStream_autoptr = *mut GPollableInputStream;
pub type GPollableInputStream_listautoptr = *mut GList;
pub type GPollableInputStream_slistautoptr = *mut GSList;
pub type GPollableInputStream_queueautoptr = *mut GQueue;
pub type GPollableOutputStream_autoptr = *mut GPollableOutputStream;
pub type GPollableOutputStream_listautoptr = *mut GList;
pub type GPollableOutputStream_slistautoptr = *mut GSList;
pub type GPollableOutputStream_queueautoptr = *mut GQueue;
pub type GPropertyAction_autoptr = *mut GPropertyAction;
pub type GPropertyAction_listautoptr = *mut GList;
pub type GPropertyAction_slistautoptr = *mut GSList;
pub type GPropertyAction_queueautoptr = *mut GQueue;
pub type GProxyAddressEnumerator_autoptr = *mut GProxyAddressEnumerator;
pub type GProxyAddressEnumerator_listautoptr = *mut GList;
pub type GProxyAddressEnumerator_slistautoptr = *mut GSList;
pub type GProxyAddressEnumerator_queueautoptr = *mut GQueue;
pub type GProxyAddress_autoptr = *mut GProxyAddress;
pub type GProxyAddress_listautoptr = *mut GList;
pub type GProxyAddress_slistautoptr = *mut GSList;
pub type GProxyAddress_queueautoptr = *mut GQueue;
pub type GProxy_autoptr = *mut GProxy;
pub type GProxy_listautoptr = *mut GList;
pub type GProxy_slistautoptr = *mut GSList;
pub type GProxy_queueautoptr = *mut GQueue;
pub type GProxyResolver_autoptr = *mut GProxyResolver;
pub type GProxyResolver_listautoptr = *mut GList;
pub type GProxyResolver_slistautoptr = *mut GSList;
pub type GProxyResolver_queueautoptr = *mut GQueue;
pub type GRemoteActionGroup_autoptr = *mut GRemoteActionGroup;
pub type GRemoteActionGroup_listautoptr = *mut GList;
pub type GRemoteActionGroup_slistautoptr = *mut GSList;
pub type GRemoteActionGroup_queueautoptr = *mut GQueue;
pub type GResolver_autoptr = *mut GResolver;
pub type GResolver_listautoptr = *mut GList;
pub type GResolver_slistautoptr = *mut GSList;
pub type GResolver_queueautoptr = *mut GQueue;
pub type GResource_autoptr = *mut GResource;
pub type GResource_listautoptr = *mut GList;
pub type GResource_slistautoptr = *mut GSList;
pub type GResource_queueautoptr = *mut GQueue;
pub type GSeekable_autoptr = *mut GSeekable;
pub type GSeekable_listautoptr = *mut GList;
pub type GSeekable_slistautoptr = *mut GSList;
pub type GSeekable_queueautoptr = *mut GQueue;
pub type GSettingsBackend_autoptr = *mut GSettingsBackend;
pub type GSettingsBackend_listautoptr = *mut GList;
pub type GSettingsBackend_slistautoptr = *mut GSList;
pub type GSettingsBackend_queueautoptr = *mut GQueue;
pub type GSettingsSchema_autoptr = *mut GSettingsSchema;
pub type GSettingsSchema_listautoptr = *mut GList;
pub type GSettingsSchema_slistautoptr = *mut GSList;
pub type GSettingsSchema_queueautoptr = *mut GQueue;
pub type GSettingsSchemaKey_autoptr = *mut GSettingsSchemaKey;
pub type GSettingsSchemaKey_listautoptr = *mut GList;
pub type GSettingsSchemaKey_slistautoptr = *mut GSList;
pub type GSettingsSchemaKey_queueautoptr = *mut GQueue;
pub type GSettingsSchemaSource_autoptr = *mut GSettingsSchemaSource;
pub type GSettingsSchemaSource_listautoptr = *mut GList;
pub type GSettingsSchemaSource_slistautoptr = *mut GSList;
pub type GSettingsSchemaSource_queueautoptr = *mut GQueue;
pub type GSettings_autoptr = *mut GSettings;
pub type GSettings_listautoptr = *mut GList;
pub type GSettings_slistautoptr = *mut GSList;
pub type GSettings_queueautoptr = *mut GQueue;
pub type GSimpleActionGroup_autoptr = *mut GSimpleActionGroup;
pub type GSimpleActionGroup_listautoptr = *mut GList;
pub type GSimpleActionGroup_slistautoptr = *mut GSList;
pub type GSimpleActionGroup_queueautoptr = *mut GQueue;
pub type GSimpleAction_autoptr = *mut GSimpleAction;
pub type GSimpleAction_listautoptr = *mut GList;
pub type GSimpleAction_slistautoptr = *mut GSList;
pub type GSimpleAction_queueautoptr = *mut GQueue;
pub type GSimpleAsyncResult_autoptr = *mut GSimpleAsyncResult;
pub type GSimpleAsyncResult_listautoptr = *mut GList;
pub type GSimpleAsyncResult_slistautoptr = *mut GSList;
pub type GSimpleAsyncResult_queueautoptr = *mut GQueue;
pub type GSimplePermission_autoptr = *mut GSimplePermission;
pub type GSimplePermission_listautoptr = *mut GList;
pub type GSimplePermission_slistautoptr = *mut GSList;
pub type GSimplePermission_queueautoptr = *mut GQueue;
pub type GSimpleProxyResolver_autoptr = *mut GSimpleProxyResolver;
pub type GSimpleProxyResolver_listautoptr = *mut GList;
pub type GSimpleProxyResolver_slistautoptr = *mut GSList;
pub type GSimpleProxyResolver_queueautoptr = *mut GQueue;
pub type GSocketAddressEnumerator_autoptr = *mut GSocketAddressEnumerator;
pub type GSocketAddressEnumerator_listautoptr = *mut GList;
pub type GSocketAddressEnumerator_slistautoptr = *mut GSList;
pub type GSocketAddressEnumerator_queueautoptr = *mut GQueue;
pub type GSocketAddress_autoptr = *mut GSocketAddress;
pub type GSocketAddress_listautoptr = *mut GList;
pub type GSocketAddress_slistautoptr = *mut GSList;
pub type GSocketAddress_queueautoptr = *mut GQueue;
pub type GSocketClient_autoptr = *mut GSocketClient;
pub type GSocketClient_listautoptr = *mut GList;
pub type GSocketClient_slistautoptr = *mut GSList;
pub type GSocketClient_queueautoptr = *mut GQueue;
pub type GSocketConnectable_autoptr = *mut GSocketConnectable;
pub type GSocketConnectable_listautoptr = *mut GList;
pub type GSocketConnectable_slistautoptr = *mut GSList;
pub type GSocketConnectable_queueautoptr = *mut GQueue;
pub type GSocketConnection_autoptr = *mut GSocketConnection;
pub type GSocketConnection_listautoptr = *mut GList;
pub type GSocketConnection_slistautoptr = *mut GSList;
pub type GSocketConnection_queueautoptr = *mut GQueue;
pub type GSocketControlMessage_autoptr = *mut GSocketControlMessage;
pub type GSocketControlMessage_listautoptr = *mut GList;
pub type GSocketControlMessage_slistautoptr = *mut GSList;
pub type GSocketControlMessage_queueautoptr = *mut GQueue;
pub type GSocket_autoptr = *mut GSocket;
pub type GSocket_listautoptr = *mut GList;
pub type GSocket_slistautoptr = *mut GSList;
pub type GSocket_queueautoptr = *mut GQueue;
pub type GSocketListener_autoptr = *mut GSocketListener;
pub type GSocketListener_listautoptr = *mut GList;
pub type GSocketListener_slistautoptr = *mut GSList;
pub type GSocketListener_queueautoptr = *mut GQueue;
pub type GSocketService_autoptr = *mut GSocketService;
pub type GSocketService_listautoptr = *mut GList;
pub type GSocketService_slistautoptr = *mut GSList;
pub type GSocketService_queueautoptr = *mut GQueue;
pub type GSubprocess_autoptr = *mut GSubprocess;
pub type GSubprocess_listautoptr = *mut GList;
pub type GSubprocess_slistautoptr = *mut GSList;
pub type GSubprocess_queueautoptr = *mut GQueue;
pub type GSubprocessLauncher_autoptr = *mut GSubprocessLauncher;
pub type GSubprocessLauncher_listautoptr = *mut GList;
pub type GSubprocessLauncher_slistautoptr = *mut GSList;
pub type GSubprocessLauncher_queueautoptr = *mut GQueue;
pub type GTask_autoptr = *mut GTask;
pub type GTask_listautoptr = *mut GList;
pub type GTask_slistautoptr = *mut GSList;
pub type GTask_queueautoptr = *mut GQueue;
pub type GTcpConnection_autoptr = *mut GTcpConnection;
pub type GTcpConnection_listautoptr = *mut GList;
pub type GTcpConnection_slistautoptr = *mut GSList;
pub type GTcpConnection_queueautoptr = *mut GQueue;
pub type GTcpWrapperConnection_autoptr = *mut GTcpWrapperConnection;
pub type GTcpWrapperConnection_listautoptr = *mut GList;
pub type GTcpWrapperConnection_slistautoptr = *mut GSList;
pub type GTcpWrapperConnection_queueautoptr = *mut GQueue;
pub type GTestDBus_autoptr = *mut GTestDBus;
pub type GTestDBus_listautoptr = *mut GList;
pub type GTestDBus_slistautoptr = *mut GSList;
pub type GTestDBus_queueautoptr = *mut GQueue;
pub type GThemedIcon_autoptr = *mut GThemedIcon;
pub type GThemedIcon_listautoptr = *mut GList;
pub type GThemedIcon_slistautoptr = *mut GSList;
pub type GThemedIcon_queueautoptr = *mut GQueue;
pub type GThreadedSocketService_autoptr = *mut GThreadedSocketService;
pub type GThreadedSocketService_listautoptr = *mut GList;
pub type GThreadedSocketService_slistautoptr = *mut GSList;
pub type GThreadedSocketService_queueautoptr = *mut GQueue;
pub type GTlsBackend_autoptr = *mut GTlsBackend;
pub type GTlsBackend_listautoptr = *mut GList;
pub type GTlsBackend_slistautoptr = *mut GSList;
pub type GTlsBackend_queueautoptr = *mut GQueue;
pub type GTlsCertificate_autoptr = *mut GTlsCertificate;
pub type GTlsCertificate_listautoptr = *mut GList;
pub type GTlsCertificate_slistautoptr = *mut GSList;
pub type GTlsCertificate_queueautoptr = *mut GQueue;
pub type GTlsClientConnection_autoptr = *mut GTlsClientConnection;
pub type GTlsClientConnection_listautoptr = *mut GList;
pub type GTlsClientConnection_slistautoptr = *mut GSList;
pub type GTlsClientConnection_queueautoptr = *mut GQueue;
pub type GTlsConnection_autoptr = *mut GTlsConnection;
pub type GTlsConnection_listautoptr = *mut GList;
pub type GTlsConnection_slistautoptr = *mut GSList;
pub type GTlsConnection_queueautoptr = *mut GQueue;
pub type GTlsDatabase_autoptr = *mut GTlsDatabase;
pub type GTlsDatabase_listautoptr = *mut GList;
pub type GTlsDatabase_slistautoptr = *mut GSList;
pub type GTlsDatabase_queueautoptr = *mut GQueue;
pub type GTlsFileDatabase_autoptr = *mut GTlsFileDatabase;
pub type GTlsFileDatabase_listautoptr = *mut GList;
pub type GTlsFileDatabase_slistautoptr = *mut GSList;
pub type GTlsFileDatabase_queueautoptr = *mut GQueue;
pub type GTlsInteraction_autoptr = *mut GTlsInteraction;
pub type GTlsInteraction_listautoptr = *mut GList;
pub type GTlsInteraction_slistautoptr = *mut GSList;
pub type GTlsInteraction_queueautoptr = *mut GQueue;
pub type GTlsPassword_autoptr = *mut GTlsPassword;
pub type GTlsPassword_listautoptr = *mut GList;
pub type GTlsPassword_slistautoptr = *mut GSList;
pub type GTlsPassword_queueautoptr = *mut GQueue;
pub type GTlsServerConnection_autoptr = *mut GTlsServerConnection;
pub type GTlsServerConnection_listautoptr = *mut GList;
pub type GTlsServerConnection_slistautoptr = *mut GSList;
pub type GTlsServerConnection_queueautoptr = *mut GQueue;
pub type GVfs_autoptr = *mut GVfs;
pub type GVfs_listautoptr = *mut GList;
pub type GVfs_slistautoptr = *mut GSList;
pub type GVfs_queueautoptr = *mut GQueue;
pub type GVolume_autoptr = *mut GVolume;
pub type GVolume_listautoptr = *mut GList;
pub type GVolume_slistautoptr = *mut GSList;
pub type GVolume_queueautoptr = *mut GQueue;
pub type GVolumeMonitor_autoptr = *mut GVolumeMonitor;
pub type GVolumeMonitor_listautoptr = *mut GList;
pub type GVolumeMonitor_slistautoptr = *mut GSList;
pub type GVolumeMonitor_queueautoptr = *mut GQueue;
pub type GZlibCompressor_autoptr = *mut GZlibCompressor;
pub type GZlibCompressor_listautoptr = *mut GList;
pub type GZlibCompressor_slistautoptr = *mut GSList;
pub type GZlibCompressor_queueautoptr = *mut GQueue;
pub type GZlibDecompressor_autoptr = *mut GZlibDecompressor;
pub type GZlibDecompressor_listautoptr = *mut GList;
pub type GZlibDecompressor_slistautoptr = *mut GSList;
pub type GZlibDecompressor_queueautoptr = *mut GQueue;
#[doc = " VipsPel:\n\n A picture element. Cast this to whatever the associated VipsBandFormat says\n to get the value."]
pub type VipsPel = ::std::os::raw::c_uchar;
pub type VipsCallbackFn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsSListMap2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsSListMap4Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsSListFold2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub const VipsPrecision_VIPS_PRECISION_INTEGER: VipsPrecision = 0;
pub const VipsPrecision_VIPS_PRECISION_FLOAT: VipsPrecision = 1;
pub const VipsPrecision_VIPS_PRECISION_APPROXIMATE: VipsPrecision = 2;
pub const VipsPrecision_VIPS_PRECISION_LAST: VipsPrecision = 3;
pub type VipsPrecision = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_path_filename7(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_path_mode7(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type VipsImage = _VipsImage;
pub type VipsRegion = _VipsRegion;
pub type VipsBuf = _VipsBuf;
pub type VipsSource = _VipsSource;
pub type VipsTarget = _VipsTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsBuf {
    pub base: *mut ::std::os::raw::c_char,
    pub mx: ::std::os::raw::c_int,
    pub i: ::std::os::raw::c_int,
    pub full: gboolean,
    pub lasti: ::std::os::raw::c_int,
    pub dynamic: gboolean,
}
#[test]
fn bindgen_test_layout__VipsBuf() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsBuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsBuf>(),
        32usize,
        concat!("Size of: ", stringify!(_VipsBuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(mx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lasti) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(lasti)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(dynamic)
        )
    );
}
extern "C" {
    pub fn vips_buf_rewind(buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_buf_destroy(buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_buf_init(buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_buf_set_static(
        buf: *mut VipsBuf,
        base: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_buf_set_dynamic(buf: *mut VipsBuf, mx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_buf_init_static(
        buf: *mut VipsBuf,
        base: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_buf_init_dynamic(buf: *mut VipsBuf, mx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_buf_appendns(
        buf: *mut VipsBuf,
        str_: *const ::std::os::raw::c_char,
        sz: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_buf_appends(buf: *mut VipsBuf, str_: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn vips_buf_appendf(buf: *mut VipsBuf, fmt: *const ::std::os::raw::c_char, ...)
        -> gboolean;
}
extern "C" {
    pub fn vips_buf_vappendf(
        buf: *mut VipsBuf,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_buf_appendc(buf: *mut VipsBuf, ch: ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn vips_buf_appendsc(
        buf: *mut VipsBuf,
        quote: gboolean,
        str_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_buf_appendgv(buf: *mut VipsBuf, value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn vips_buf_append_size(buf: *mut VipsBuf, n: size_t) -> gboolean;
}
extern "C" {
    pub fn vips_buf_removec(buf: *mut VipsBuf, ch: ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn vips_buf_change(
        buf: *mut VipsBuf,
        o: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_buf_is_empty(buf: *mut VipsBuf) -> gboolean;
}
extern "C" {
    pub fn vips_buf_is_full(buf: *mut VipsBuf) -> gboolean;
}
extern "C" {
    pub fn vips_buf_all(buf: *mut VipsBuf) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_buf_firstline(buf: *mut VipsBuf) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_buf_appendg(buf: *mut VipsBuf, g: f64) -> gboolean;
}
extern "C" {
    pub fn vips_buf_appendd(buf: *mut VipsBuf, d: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    pub fn vips_buf_len(buf: *mut VipsBuf) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsDbuf {
    pub data: *mut ::std::os::raw::c_uchar,
    pub allocated_size: size_t,
    pub data_size: size_t,
    pub write_point: size_t,
}
#[test]
fn bindgen_test_layout__VipsDbuf() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsDbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsDbuf>(),
        32usize,
        concat!("Size of: ", stringify!(_VipsDbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsDbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsDbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(allocated_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_point) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(write_point)
        )
    );
}
pub type VipsDbuf = _VipsDbuf;
extern "C" {
    pub fn vips_dbuf_init(dbuf: *mut VipsDbuf);
}
extern "C" {
    pub fn vips_dbuf_minimum_size(dbuf: *mut VipsDbuf, size: size_t) -> gboolean;
}
extern "C" {
    pub fn vips_dbuf_allocate(dbuf: *mut VipsDbuf, size: size_t) -> gboolean;
}
extern "C" {
    pub fn vips_dbuf_read(
        dbuf: *mut VipsDbuf,
        data: *mut ::std::os::raw::c_uchar,
        size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn vips_dbuf_get_write(
        dbuf: *mut VipsDbuf,
        size: *mut size_t,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn vips_dbuf_write(
        dbuf: *mut VipsDbuf,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_dbuf_writef(
        dbuf: *mut VipsDbuf,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn vips_dbuf_write_amp(
        dbuf: *mut VipsDbuf,
        str_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_dbuf_reset(dbuf: *mut VipsDbuf);
}
extern "C" {
    pub fn vips_dbuf_destroy(dbuf: *mut VipsDbuf);
}
extern "C" {
    pub fn vips_dbuf_seek(
        dbuf: *mut VipsDbuf,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_dbuf_truncate(dbuf: *mut VipsDbuf);
}
extern "C" {
    pub fn vips_dbuf_tell(dbuf: *mut VipsDbuf) -> off_t;
}
extern "C" {
    pub fn vips_dbuf_string(dbuf: *mut VipsDbuf, size: *mut size_t)
        -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn vips_dbuf_steal(dbuf: *mut VipsDbuf, size: *mut size_t) -> *mut ::std::os::raw::c_uchar;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    const UNINIT: ::std::mem::MaybeUninit<__float2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    const UNINIT: ::std::mem::MaybeUninit<__double2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    const UNINIT: ::std::mem::MaybeUninit<exception> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn vips_enum_string(
        enm: GType,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_enum_nick(
        enm: GType,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_enum_from_nick(
        domain: *const ::std::os::raw::c_char,
        type_: GType,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_flags_from_nick(
        domain: *const ::std::os::raw::c_char,
        type_: GType,
        nick: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_slist_equal(l1: *mut GSList, l2: *mut GSList) -> gboolean;
}
extern "C" {
    pub fn vips_slist_map2(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_slist_map2_rev(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_slist_map4(
        list: *mut GSList,
        fn_: VipsSListMap4Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_slist_fold2(
        list: *mut GSList,
        start: *mut ::std::os::raw::c_void,
        fn_: VipsSListFold2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_slist_filter(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut GSList;
}
extern "C" {
    pub fn vips_slist_free_all(list: *mut GSList);
}
extern "C" {
    pub fn vips_map_equal(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_hash_table_map(
        hash: *mut GHashTable,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_strncpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_strrstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_ispostfix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_iscasepostfix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_isprefix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_break_token(
        str_: *mut ::std::os::raw::c_char,
        brk: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__chomp(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        size: size_t,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_snprintf(
        str_: *mut ::std::os::raw::c_char,
        size: size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_filename_suffix_match(
        path: *const ::std::os::raw::c_char,
        suffixes: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_file_length(fd: ::std::os::raw::c_int) -> gint64;
}
extern "C" {
    pub fn vips__write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__open(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__open_read(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn vips__file_open_read(
        filename: *const ::std::os::raw::c_char,
        fallback_dir: *const ::std::os::raw::c_char,
        text_mode: gboolean,
    ) -> *mut FILE;
}
extern "C" {
    pub fn vips__file_open_write(
        filename: *const ::std::os::raw::c_char,
        text_mode: gboolean,
    ) -> *mut FILE;
}
extern "C" {
    pub fn vips__file_read(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        length_out: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__file_read_name(
        name: *const ::std::os::raw::c_char,
        fallback_dir: *const ::std::os::raw::c_char,
        length_out: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__file_write(
        data: *mut ::std::os::raw::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__get_bytes(
        filename: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_uchar,
        len: gint64,
    ) -> gint64;
}
extern "C" {
    pub fn vips__fgetc(fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__gvalue_ref_string_new(text: *const ::std::os::raw::c_char) -> *mut GValue;
}
extern "C" {
    pub fn vips__gslist_gvalue_free(list: *mut GSList);
}
extern "C" {
    pub fn vips__gslist_gvalue_copy(list: *const GSList) -> *mut GSList;
}
extern "C" {
    pub fn vips__gslist_gvalue_merge(a: *mut GSList, b: *const GSList) -> *mut GSList;
}
extern "C" {
    pub fn vips__gslist_gvalue_get(list: *const GSList) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__seek_no_error(
        fd: ::std::os::raw::c_int,
        pos: gint64,
        whence: ::std::os::raw::c_int,
    ) -> gint64;
}
extern "C" {
    pub fn vips__seek(
        fd: ::std::os::raw::c_int,
        pos: gint64,
        whence: ::std::os::raw::c_int,
    ) -> gint64;
}
extern "C" {
    pub fn vips__ftruncate(fd: ::std::os::raw::c_int, pos: gint64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_existsf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_isdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mkdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rmdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rename(
        old_name: *const ::std::os::raw::c_char,
        new_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const VipsToken_VIPS_TOKEN_LEFT: VipsToken = 1;
pub const VipsToken_VIPS_TOKEN_RIGHT: VipsToken = 2;
pub const VipsToken_VIPS_TOKEN_STRING: VipsToken = 3;
pub const VipsToken_VIPS_TOKEN_EQUALS: VipsToken = 4;
pub const VipsToken_VIPS_TOKEN_COMMA: VipsToken = 5;
#[doc = " VipsToken:\n @VIPS_TOKEN_LEFT: left bracket\n @VIPS_TOKEN_RIGHT: right bracket\n @VIPS_TOKEN_STRING: string constant\n @VIPS_TOKEN_EQUALS: equals sign\n @VIPS_TOKEN_COMMA: comma\n\n Tokens returned by the vips lexical analyzer, see vips__token_get(). This\n is used to parse option strings for arguments.\n\n Left and right brackets can be any of (, {, [, <.\n\n Strings may be in double quotes, and may contain escaped quote characters,\n for example string, \"string\" and \"str\\\"ing\".\n"]
pub type VipsToken = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips__token_get(
        buffer: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__token_must(
        buffer: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__token_need(
        buffer: *const ::std::os::raw::c_char,
        need_token: VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__token_segment(
        p: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__token_segment_need(
        p: *const ::std::os::raw::c_char,
        need_token: VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__find_rightmost_brackets(
        p: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__filename_split8(
        name: *const ::std::os::raw::c_char,
        filename: *mut ::std::os::raw::c_char,
        option_string: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn vips_ispoweroftwo(p: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_amiMSBfirst() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__temp_name(format: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__change_suffix(
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
        new_suff: *const ::std::os::raw::c_char,
        olds: *mut *const ::std::os::raw::c_char,
        nolds: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_realpath(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__random(seed: guint32) -> guint32;
}
extern "C" {
    pub fn vips__random_add(seed: guint32, value: ::std::os::raw::c_int) -> guint32;
}
extern "C" {
    pub fn vips__icc_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__windows_prefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips__get_iso8601() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_strtod(str_: *const ::std::os::raw::c_char, out: *mut f64)
        -> ::std::os::raw::c_int;
}
pub type VipsObject = _VipsObject;
pub type VipsObjectClass = _VipsObjectClass;
pub const VipsArgumentFlags_VIPS_ARGUMENT_NONE: VipsArgumentFlags = 0;
pub const VipsArgumentFlags_VIPS_ARGUMENT_REQUIRED: VipsArgumentFlags = 1;
pub const VipsArgumentFlags_VIPS_ARGUMENT_CONSTRUCT: VipsArgumentFlags = 2;
pub const VipsArgumentFlags_VIPS_ARGUMENT_SET_ONCE: VipsArgumentFlags = 4;
pub const VipsArgumentFlags_VIPS_ARGUMENT_SET_ALWAYS: VipsArgumentFlags = 8;
pub const VipsArgumentFlags_VIPS_ARGUMENT_INPUT: VipsArgumentFlags = 16;
pub const VipsArgumentFlags_VIPS_ARGUMENT_OUTPUT: VipsArgumentFlags = 32;
pub const VipsArgumentFlags_VIPS_ARGUMENT_DEPRECATED: VipsArgumentFlags = 64;
pub const VipsArgumentFlags_VIPS_ARGUMENT_MODIFY: VipsArgumentFlags = 128;
pub const VipsArgumentFlags_VIPS_ARGUMENT_NON_HASHABLE: VipsArgumentFlags = 256;
pub type VipsArgumentFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArgument {
    pub pspec: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__VipsArgument() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArgument> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArgument>(),
        8usize,
        concat!("Size of: ", stringify!(_VipsArgument))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArgument>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArgument))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pspec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgument),
            "::",
            stringify!(pspec)
        )
    );
}
pub type VipsArgument = _VipsArgument;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArgumentClass {
    pub parent: VipsArgument,
    pub object_class: *mut VipsObjectClass,
    pub flags: VipsArgumentFlags,
    pub priority: ::std::os::raw::c_int,
    pub offset: guint,
}
#[test]
fn bindgen_test_layout__VipsArgumentClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArgumentClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArgumentClass>(),
        32usize,
        concat!("Size of: ", stringify!(_VipsArgumentClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArgumentClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArgumentClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(object_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(offset)
        )
    );
}
pub type VipsArgumentClass = _VipsArgumentClass;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArgumentInstance {
    pub parent: VipsArgument,
    pub argument_class: *mut VipsArgumentClass,
    pub object: *mut VipsObject,
    pub assigned: gboolean,
    pub close_id: gulong,
    pub invalidate_id: gulong,
}
#[test]
fn bindgen_test_layout__VipsArgumentInstance() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArgumentInstance> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArgumentInstance>(),
        48usize,
        concat!("Size of: ", stringify!(_VipsArgumentInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArgumentInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArgumentInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argument_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(argument_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assigned) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(assigned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(close_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(invalidate_id)
        )
    );
}
pub type VipsArgumentInstance = _VipsArgumentInstance;
pub type VipsArgumentTable = GHashTable;
extern "C" {
    pub fn vips_argument_get_id() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__object_set_member(
        object: *mut VipsObject,
        pspec: *mut GParamSpec,
        member: *mut *mut GObject,
        argument: *mut GObject,
    );
}
pub type VipsArgumentMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut VipsObject,
        pspec: *mut GParamSpec,
        argument_class: *mut VipsArgumentClass,
        argument_instance: *mut VipsArgumentInstance,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn vips_argument_map(
        object: *mut VipsObject,
        fn_: VipsArgumentMapFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_object_get_args(
        object: *mut VipsObject,
        names: *mut *mut *const ::std::os::raw::c_char,
        flags: *mut *mut ::std::os::raw::c_int,
        n_args: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type VipsArgumentClassMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        object_class: *mut VipsObjectClass,
        pspec: *mut GParamSpec,
        argument_class: *mut VipsArgumentClass,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn vips_argument_class_map(
        object_class: *mut VipsObjectClass,
        fn_: VipsArgumentClassMapFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_argument_class_needsstring(argument_class: *mut VipsArgumentClass) -> gboolean;
}
extern "C" {
    pub fn vips_object_get_argument(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        pspec: *mut *mut GParamSpec,
        argument_class: *mut *mut VipsArgumentClass,
        argument_instance: *mut *mut VipsArgumentInstance,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_argument_isset(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_object_get_argument_flags(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> VipsArgumentFlags;
}
extern "C" {
    pub fn vips_object_get_argument_priority(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsObject {
    pub parent_instance: GObject,
    pub constructed: gboolean,
    pub static_object: gboolean,
    pub argument_table: *mut VipsArgumentTable,
    pub nickname: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
    pub preclose: gboolean,
    pub close: gboolean,
    pub postclose: gboolean,
    pub local_memory: size_t,
}
#[test]
fn bindgen_test_layout__VipsObject() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsObject>(),
        80usize,
        concat!("Size of: ", stringify!(_VipsObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constructed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).static_object) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(static_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argument_table) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(argument_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nickname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(nickname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preclose) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(preclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postclose) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(postclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_memory) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(local_memory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsObjectClass {
    pub parent_class: GObjectClass,
    pub build: ::std::option::Option<
        unsafe extern "C" fn(object: *mut VipsObject) -> ::std::os::raw::c_int,
    >,
    pub postbuild: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut VipsObject,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub summary_class:
        ::std::option::Option<unsafe extern "C" fn(cls: *mut _VipsObjectClass, buf: *mut VipsBuf)>,
    pub summary:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub dump:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub sanity:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub rewind: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub preclose: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub close: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub postclose: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub new_from_string: ::std::option::Option<
        unsafe extern "C" fn(string: *const ::std::os::raw::c_char) -> *mut VipsObject,
    >,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub output_needs_arg: gboolean,
    pub output_to_arg: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut VipsObject,
            string: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub nickname: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub argument_table: *mut VipsArgumentTable,
    pub argument_table_traverse: *mut GSList,
    pub argument_table_traverse_gtype: GType,
    pub deprecated: gboolean,
    pub _vips_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__VipsObjectClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsObjectClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsObjectClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsObjectClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(build)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postbuild) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(postbuild)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).summary_class) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(summary_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).summary) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(summary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sanity) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(sanity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rewind) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(rewind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preclose) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(preclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postclose) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(postclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_from_string) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(new_from_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_string) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(to_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_needs_arg) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(output_needs_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_to_arg) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(output_to_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nickname) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(nickname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argument_table) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(argument_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argument_table_traverse) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(argument_table_traverse)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).argument_table_traverse_gtype) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(argument_table_traverse_gtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(deprecated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vips_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vips_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vips_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vips_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved4)
        )
    );
}
extern "C" {
    pub fn vips_value_is_null(psoec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn vips_object_set_property(
        gobject: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    pub fn vips_object_get_property(
        gobject: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    pub fn vips_object_preclose(object: *mut VipsObject);
}
extern "C" {
    pub fn vips_object_build(object: *mut VipsObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_summary_class(klass: *mut VipsObjectClass, buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_object_summary(object: *mut VipsObject, buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_object_dump(object: *mut VipsObject, buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_object_print_summary_class(klass: *mut VipsObjectClass);
}
extern "C" {
    pub fn vips_object_print_summary(object: *mut VipsObject);
}
extern "C" {
    pub fn vips_object_print_dump(object: *mut VipsObject);
}
extern "C" {
    pub fn vips_object_print_name(object: *mut VipsObject);
}
extern "C" {
    pub fn vips_object_sanity(object: *mut VipsObject) -> gboolean;
}
extern "C" {
    pub fn vips_object_get_type() -> GType;
}
extern "C" {
    pub fn vips_object_class_install_argument(
        cls: *mut VipsObjectClass,
        pspec: *mut GParamSpec,
        flags: VipsArgumentFlags,
        priority: ::std::os::raw::c_int,
        offset: guint,
    );
}
extern "C" {
    pub fn vips_object_set_argument_from_string(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_argument_needsstring(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_object_get_argument_to_string(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_set_required(
        object: *mut VipsObject,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type VipsObjectSetArguments = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut VipsObject,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn vips_object_new(
        type_: GType,
        set: VipsObjectSetArguments,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut VipsObject;
}
extern "C" {
    pub fn vips_object_set_valist(object: *mut VipsObject, ap: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_set(object: *mut VipsObject, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_set_from_string(
        object: *mut VipsObject,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_object_new_from_string(
        object_class: *mut VipsObjectClass,
        p: *const ::std::os::raw::c_char,
    ) -> *mut VipsObject;
}
extern "C" {
    pub fn vips_object_to_string(object: *mut VipsObject, buf: *mut VipsBuf);
}
extern "C" {
    pub fn vips_object_map(
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub type VipsTypeMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: GType,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsTypeMap2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: GType,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsClassMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut VipsObjectClass,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn vips_type_map(
        base: GType,
        fn_: VipsTypeMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_type_map_all(
        base: GType,
        fn_: VipsTypeMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_type_depth(type_: GType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_type_find(
        basename: *const ::std::os::raw::c_char,
        nickname: *const ::std::os::raw::c_char,
    ) -> GType;
}
extern "C" {
    pub fn vips_nickname_find(type_: GType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_class_map_all(
        type_: GType,
        fn_: VipsClassMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_class_find(
        basename: *const ::std::os::raw::c_char,
        nickname: *const ::std::os::raw::c_char,
    ) -> *const VipsObjectClass;
}
extern "C" {
    pub fn vips_object_local_array(
        parent: *mut VipsObject,
        n: ::std::os::raw::c_int,
    ) -> *mut *mut VipsObject;
}
extern "C" {
    pub fn vips_object_local_cb(vobject: *mut VipsObject, gobject: *mut GObject);
}
extern "C" {
    pub fn vips_object_set_static(object: *mut VipsObject, static_object: gboolean);
}
extern "C" {
    pub fn vips_object_print_all();
}
extern "C" {
    pub fn vips_object_sanity_all();
}
extern "C" {
    pub fn vips_object_rewind(object: *mut VipsObject);
}
extern "C" {
    pub fn vips_object_unref_outputs(object: *mut VipsObject);
}
extern "C" {
    pub fn vips_object_get_description(object: *mut VipsObject) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsThing {
    pub i: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsThing() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsThing> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsThing>(),
        4usize,
        concat!("Size of: ", stringify!(_VipsThing))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsThing>(),
        4usize,
        concat!("Alignment of ", stringify!(_VipsThing))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThing),
            "::",
            stringify!(i)
        )
    );
}
pub type VipsThing = _VipsThing;
extern "C" {
    pub fn vips_thing_get_type() -> GType;
}
extern "C" {
    pub fn vips_thing_new(i: ::std::os::raw::c_int) -> *mut VipsThing;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArea {
    pub data: *mut ::std::os::raw::c_void,
    pub length: size_t,
    pub n: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub lock: *mut GMutex,
    pub free_fn: VipsCallbackFn,
    pub client: *mut ::std::os::raw::c_void,
    pub type_: GType,
    pub sizeof_type: size_t,
}
#[test]
fn bindgen_test_layout__VipsArea() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArea> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArea>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsArea))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArea>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArea))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeof_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(sizeof_type)
        )
    );
}
pub type VipsArea = _VipsArea;
extern "C" {
    pub fn vips_area_copy(area: *mut VipsArea) -> *mut VipsArea;
}
extern "C" {
    pub fn vips_area_free_cb(
        mem: *mut ::std::os::raw::c_void,
        area: *mut VipsArea,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_area_unref(area: *mut VipsArea);
}
extern "C" {
    pub fn vips_area_new(
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut VipsArea;
}
extern "C" {
    pub fn vips_area_new_array(
        type_: GType,
        sizeof_type: size_t,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArea;
}
extern "C" {
    pub fn vips_area_new_array_object(n: ::std::os::raw::c_int) -> *mut VipsArea;
}
extern "C" {
    pub fn vips_area_get_data(
        area: *mut VipsArea,
        length: *mut size_t,
        n: *mut ::std::os::raw::c_int,
        type_: *mut GType,
        sizeof_type: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_area_get_type() -> GType;
}
extern "C" {
    pub fn vips_save_string_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSaveString {
    pub s: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsSaveString() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSaveString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSaveString>(),
        8usize,
        concat!("Size of: ", stringify!(_VipsSaveString))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSaveString>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSaveString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSaveString),
            "::",
            stringify!(s)
        )
    );
}
pub type VipsSaveString = _VipsSaveString;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsRefString {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsRefString() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsRefString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsRefString>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsRefString))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRefString>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsRefString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRefString),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsRefString = _VipsRefString;
extern "C" {
    pub fn vips_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut VipsRefString;
}
extern "C" {
    pub fn vips_ref_string_get(
        refstr: *mut VipsRefString,
        length: *mut size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_ref_string_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsBlob {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsBlob() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsBlob> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsBlob>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsBlob))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBlob>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBlob))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBlob),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsBlob = _VipsBlob;
extern "C" {
    pub fn vips_blob_new(
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> *mut VipsBlob;
}
extern "C" {
    pub fn vips_blob_copy(data: *const ::std::os::raw::c_void, length: size_t) -> *mut VipsBlob;
}
extern "C" {
    pub fn vips_blob_get(blob: *mut VipsBlob, length: *mut size_t)
        -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_blob_set(
        blob: *mut VipsBlob,
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    );
}
extern "C" {
    pub fn vips_blob_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArrayDouble {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsArrayDouble() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArrayDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArrayDouble>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsArrayDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArrayDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArrayDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArrayDouble),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsArrayDouble = _VipsArrayDouble;
extern "C" {
    pub fn vips_array_double_new(
        array: *const f64,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayDouble;
}
extern "C" {
    pub fn vips_array_double_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayDouble;
}
extern "C" {
    pub fn vips_array_double_get(
        array: *mut VipsArrayDouble,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
}
extern "C" {
    pub fn vips_array_double_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArrayInt {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsArrayInt() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArrayInt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArrayInt>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsArrayInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArrayInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArrayInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArrayInt),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsArrayInt = _VipsArrayInt;
extern "C" {
    pub fn vips_array_int_new(
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayInt;
}
extern "C" {
    pub fn vips_array_int_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayInt;
}
extern "C" {
    pub fn vips_array_int_get(
        array: *mut VipsArrayInt,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_array_int_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsArrayImage {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsArrayImage() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsArrayImage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsArrayImage>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsArrayImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArrayImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArrayImage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArrayImage),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsArrayImage = _VipsArrayImage;
extern "C" {
    pub fn vips_array_image_get_type() -> GType;
}
extern "C" {
    pub fn vips_value_set_area(
        value: *mut GValue,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vips_value_get_area(
        value: *const GValue,
        length: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_value_get_save_string(value: *const GValue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_value_set_save_string(value: *mut GValue, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips_value_set_save_stringf(value: *mut GValue, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vips_value_get_ref_string(
        value: *const GValue,
        length: *mut size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_value_set_ref_string(value: *mut GValue, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips_value_get_blob(
        value: *const GValue,
        length: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_value_set_blob(
        value: *mut GValue,
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    );
}
extern "C" {
    pub fn vips_value_set_blob_free(
        value: *mut GValue,
        data: *mut ::std::os::raw::c_void,
        length: size_t,
    );
}
extern "C" {
    pub fn vips_value_set_array(
        value: *mut GValue,
        n: ::std::os::raw::c_int,
        type_: GType,
        sizeof_type: size_t,
    );
}
extern "C" {
    pub fn vips_value_get_array(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
        type_: *mut GType,
        sizeof_type: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_value_get_array_double(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
}
extern "C" {
    pub fn vips_value_set_array_double(
        value: *mut GValue,
        array: *const f64,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_value_get_array_int(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_value_set_array_int(
        value: *mut GValue,
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_value_get_array_object(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut GObject;
}
extern "C" {
    pub fn vips_value_set_array_object(value: *mut GValue, n: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut vips__thread_profile: gboolean;
}
extern "C" {
    pub fn vips_profile_set(profile: gboolean);
}
extern "C" {
    pub fn vips__thread_profile_attach(thread_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips__thread_profile_detach();
}
extern "C" {
    pub fn vips__thread_profile_stop();
}
extern "C" {
    pub fn vips__thread_gate_start(gate_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips__thread_gate_stop(gate_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips__thread_malloc_free(size: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsConnection {
    pub parent_object: VipsObject,
    pub descriptor: ::std::os::raw::c_int,
    pub tracked_descriptor: ::std::os::raw::c_int,
    pub close_descriptor: ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsConnection>(),
        104usize,
        concat!("Size of: ", stringify!(_VipsConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsConnection),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsConnection),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracked_descriptor) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsConnection),
            "::",
            stringify!(tracked_descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_descriptor) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsConnection),
            "::",
            stringify!(close_descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsConnection),
            "::",
            stringify!(filename)
        )
    );
}
pub type VipsConnection = _VipsConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsConnectionClass {
    pub parent_class: VipsObjectClass,
}
#[test]
fn bindgen_test_layout__VipsConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsConnectionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsConnectionClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsConnectionClass = _VipsConnectionClass;
extern "C" {
    pub fn vips_connection_get_type() -> GType;
}
extern "C" {
    pub fn vips_connection_filename(
        connection: *mut VipsConnection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_connection_nick(connection: *mut VipsConnection) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_pipe_read_limit_set(limit: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSource {
    pub parent_object: VipsConnection,
    pub decode: gboolean,
    pub have_tested_seek: gboolean,
    pub is_pipe: gboolean,
    pub read_position: gint64,
    pub length: gint64,
    pub data: *const ::std::os::raw::c_void,
    pub header_bytes: *mut GByteArray,
    pub sniff: *mut GByteArray,
    pub blob: *mut VipsBlob,
    pub mmap_baseaddr: *mut ::std::os::raw::c_void,
    pub mmap_length: size_t,
}
#[test]
fn bindgen_test_layout__VipsSource() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSource>(),
        184usize,
        concat!("Size of: ", stringify!(_VipsSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_tested_seek) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(have_tested_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_pipe) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(is_pipe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_position) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(read_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_bytes) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(header_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sniff) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(sniff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap_baseaddr) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(mmap_baseaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap_length) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSource),
            "::",
            stringify!(mmap_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSourceClass {
    pub parent_class: VipsConnectionClass,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSource,
            arg2: *mut ::std::os::raw::c_void,
            arg3: size_t,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSource,
            arg2: gint64,
            arg3: ::std::os::raw::c_int,
        ) -> gint64,
    >,
}
#[test]
fn bindgen_test_layout__VipsSourceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSourceClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSourceClass>(),
        344usize,
        concat!("Size of: ", stringify!(_VipsSourceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSourceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSourceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceClass),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceClass),
            "::",
            stringify!(seek)
        )
    );
}
pub type VipsSourceClass = _VipsSourceClass;
extern "C" {
    pub fn vips_source_get_type() -> GType;
}
extern "C" {
    pub fn vips_source_new_from_descriptor(descriptor: ::std::os::raw::c_int) -> *mut VipsSource;
}
extern "C" {
    pub fn vips_source_new_from_file(filename: *const ::std::os::raw::c_char) -> *mut VipsSource;
}
extern "C" {
    pub fn vips_source_new_from_blob(blob: *mut VipsBlob) -> *mut VipsSource;
}
extern "C" {
    pub fn vips_source_new_from_target(target: *mut VipsTarget) -> *mut VipsSource;
}
extern "C" {
    pub fn vips_source_new_from_memory(
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut VipsSource;
}
extern "C" {
    pub fn vips_source_new_from_options(options: *const ::std::os::raw::c_char) -> *mut VipsSource;
}
extern "C" {
    pub fn vips_source_minimise(source: *mut VipsSource);
}
extern "C" {
    pub fn vips_source_unminimise(source: *mut VipsSource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_source_decode(source: *mut VipsSource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_source_read(
        source: *mut VipsSource,
        data: *mut ::std::os::raw::c_void,
        length: size_t,
    ) -> gint64;
}
extern "C" {
    pub fn vips_source_is_mappable(source: *mut VipsSource) -> gboolean;
}
extern "C" {
    pub fn vips_source_is_file(source: *mut VipsSource) -> gboolean;
}
extern "C" {
    pub fn vips_source_map(
        source: *mut VipsSource,
        length: *mut size_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_source_map_blob(source: *mut VipsSource) -> *mut VipsBlob;
}
extern "C" {
    pub fn vips_source_seek(
        source: *mut VipsSource,
        offset: gint64,
        whence: ::std::os::raw::c_int,
    ) -> gint64;
}
extern "C" {
    pub fn vips_source_rewind(source: *mut VipsSource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_source_sniff_at_most(
        source: *mut VipsSource,
        data: *mut *mut ::std::os::raw::c_uchar,
        length: size_t,
    ) -> gint64;
}
extern "C" {
    pub fn vips_source_sniff(
        source: *mut VipsSource,
        length: size_t,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn vips_source_length(source: *mut VipsSource) -> gint64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSourceCustom {
    pub parent_object: VipsSource,
}
#[test]
fn bindgen_test_layout__VipsSourceCustom() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSourceCustom> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSourceCustom>(),
        184usize,
        concat!("Size of: ", stringify!(_VipsSourceCustom))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSourceCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSourceCustom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceCustom),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsSourceCustom = _VipsSourceCustom;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSourceCustomClass {
    pub parent_class: VipsSourceClass,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSourceCustom,
            arg2: *mut ::std::os::raw::c_void,
            arg3: gint64,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSourceCustom,
            arg2: gint64,
            arg3: ::std::os::raw::c_int,
        ) -> gint64,
    >,
}
#[test]
fn bindgen_test_layout__VipsSourceCustomClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSourceCustomClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSourceCustomClass>(),
        360usize,
        concat!("Size of: ", stringify!(_VipsSourceCustomClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSourceCustomClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSourceCustomClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceCustomClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceCustomClass),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceCustomClass),
            "::",
            stringify!(seek)
        )
    );
}
pub type VipsSourceCustomClass = _VipsSourceCustomClass;
extern "C" {
    pub fn vips_source_custom_get_type() -> GType;
}
extern "C" {
    pub fn vips_source_custom_new() -> *mut VipsSourceCustom;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsGInputStream {
    pub parent_instance: GInputStream,
    pub source: *mut VipsSource,
}
#[test]
fn bindgen_test_layout__VipsGInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsGInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsGInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_VipsGInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsGInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsGInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsGInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsGInputStream),
            "::",
            stringify!(source)
        )
    );
}
pub type VipsGInputStream = _VipsGInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsGInputStreamClass {
    pub parent_class: GInputStreamClass,
}
#[test]
fn bindgen_test_layout__VipsGInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsGInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsGInputStreamClass>(),
        248usize,
        concat!("Size of: ", stringify!(_VipsGInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsGInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsGInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsGInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsGInputStreamClass = _VipsGInputStreamClass;
extern "C" {
    pub fn vips_g_input_stream_new_from_source(source: *mut VipsSource) -> *mut GInputStream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSourceGInputStream {
    pub parent_instance: VipsSource,
    pub stream: *mut GInputStream,
    pub seekable: *mut GSeekable,
    pub info: *mut GFileInfo,
}
#[test]
fn bindgen_test_layout__VipsSourceGInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSourceGInputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSourceGInputStream>(),
        208usize,
        concat!("Size of: ", stringify!(_VipsSourceGInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSourceGInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSourceGInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceGInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceGInputStream),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seekable) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceGInputStream),
            "::",
            stringify!(seekable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceGInputStream),
            "::",
            stringify!(info)
        )
    );
}
pub type VipsSourceGInputStream = _VipsSourceGInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSourceGInputStreamClass {
    pub parent_class: VipsSourceClass,
}
#[test]
fn bindgen_test_layout__VipsSourceGInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSourceGInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSourceGInputStreamClass>(),
        344usize,
        concat!("Size of: ", stringify!(_VipsSourceGInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSourceGInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSourceGInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSourceGInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsSourceGInputStreamClass = _VipsSourceGInputStreamClass;
extern "C" {
    pub fn vips_source_g_input_stream_new(stream: *mut GInputStream)
        -> *mut VipsSourceGInputStream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsTarget {
    pub parent_object: VipsConnection,
    pub memory: gboolean,
    pub ended: gboolean,
    pub memory_buffer: *mut GString,
    pub blob: *mut VipsBlob,
    pub output_buffer: [::std::os::raw::c_uchar; 8500usize],
    pub write_point: ::std::os::raw::c_int,
    pub position: off_t,
    pub delete_on_close: gboolean,
    pub delete_on_close_filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsTarget() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsTarget> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsTarget>(),
        8656usize,
        concat!("Size of: ", stringify!(_VipsTarget))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsTarget>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsTarget))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ended) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(ended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_buffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(memory_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_buffer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(output_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_point) as usize - ptr as usize },
        8628usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(write_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        8632usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_on_close) as usize - ptr as usize },
        8640usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(delete_on_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_on_close_filename) as usize - ptr as usize },
        8648usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTarget),
            "::",
            stringify!(delete_on_close_filename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsTargetClass {
    pub parent_class: VipsConnectionClass,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTarget,
            arg2: *const ::std::os::raw::c_void,
            arg3: size_t,
        ) -> gint64,
    >,
    pub finish: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VipsTarget)>,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTarget,
            arg2: *mut ::std::os::raw::c_void,
            arg3: size_t,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTarget,
            offset: off_t,
            whence: ::std::os::raw::c_int,
        ) -> off_t,
    >,
    pub end:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VipsTarget) -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout__VipsTargetClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsTargetClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsTargetClass>(),
        368usize,
        concat!("Size of: ", stringify!(_VipsTargetClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsTargetClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsTargetClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetClass),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetClass),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetClass),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetClass),
            "::",
            stringify!(end)
        )
    );
}
pub type VipsTargetClass = _VipsTargetClass;
extern "C" {
    pub fn vips_target_get_type() -> GType;
}
extern "C" {
    pub fn vips_target_new_to_descriptor(descriptor: ::std::os::raw::c_int) -> *mut VipsTarget;
}
extern "C" {
    pub fn vips_target_new_to_file(filename: *const ::std::os::raw::c_char) -> *mut VipsTarget;
}
extern "C" {
    pub fn vips_target_new_to_memory() -> *mut VipsTarget;
}
extern "C" {
    pub fn vips_target_new_temp(target: *mut VipsTarget) -> *mut VipsTarget;
}
extern "C" {
    pub fn vips_target_write(
        target: *mut VipsTarget,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_target_read(
        target: *mut VipsTarget,
        buffer: *mut ::std::os::raw::c_void,
        length: size_t,
    ) -> gint64;
}
extern "C" {
    pub fn vips_target_seek(
        target: *mut VipsTarget,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn vips_target_end(target: *mut VipsTarget) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_target_finish(target: *mut VipsTarget);
}
extern "C" {
    pub fn vips_target_steal(
        target: *mut VipsTarget,
        length: *mut size_t,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn vips_target_steal_text(target: *mut VipsTarget) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_target_putc(
        target: *mut VipsTarget,
        ch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_target_writes(
        target: *mut VipsTarget,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_target_writef(
        target: *mut VipsTarget,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_target_write_amp(
        target: *mut VipsTarget,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsTargetCustom {
    pub parent_object: VipsTarget,
}
#[test]
fn bindgen_test_layout__VipsTargetCustom() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsTargetCustom> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsTargetCustom>(),
        8656usize,
        concat!("Size of: ", stringify!(_VipsTargetCustom))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsTargetCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsTargetCustom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustom),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsTargetCustom = _VipsTargetCustom;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsTargetCustomClass {
    pub parent_class: VipsTargetClass,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTargetCustom,
            arg2: *const ::std::os::raw::c_void,
            arg3: gint64,
        ) -> gint64,
    >,
    pub finish: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VipsTargetCustom)>,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTargetCustom,
            arg2: *mut ::std::os::raw::c_void,
            arg3: gint64,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTargetCustom,
            arg2: gint64,
            arg3: ::std::os::raw::c_int,
        ) -> gint64,
    >,
    pub end: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VipsTargetCustom) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__VipsTargetCustomClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsTargetCustomClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsTargetCustomClass>(),
        408usize,
        concat!("Size of: ", stringify!(_VipsTargetCustomClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsTargetCustomClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsTargetCustomClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustomClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustomClass),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustomClass),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustomClass),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustomClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsTargetCustomClass),
            "::",
            stringify!(end)
        )
    );
}
pub type VipsTargetCustomClass = _VipsTargetCustomClass;
extern "C" {
    pub fn vips_target_custom_get_type() -> GType;
}
extern "C" {
    pub fn vips_target_custom_new() -> *mut VipsTargetCustom;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSbuf {
    pub parent_object: VipsObject,
    pub source: *mut VipsSource,
    pub input_buffer: [::std::os::raw::c_uchar; 4097usize],
    pub chars_in_buffer: ::std::os::raw::c_int,
    pub read_point: ::std::os::raw::c_int,
    pub line: [::std::os::raw::c_uchar; 4097usize],
}
#[test]
fn bindgen_test_layout__VipsSbuf() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSbuf>(),
        8296usize,
        concat!("Size of: ", stringify!(_VipsSbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbuf),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbuf),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_buffer) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbuf),
            "::",
            stringify!(input_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chars_in_buffer) as usize - ptr as usize },
        4188usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbuf),
            "::",
            stringify!(chars_in_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_point) as usize - ptr as usize },
        4192usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbuf),
            "::",
            stringify!(read_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        4196usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbuf),
            "::",
            stringify!(line)
        )
    );
}
pub type VipsSbuf = _VipsSbuf;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsSbufClass {
    pub parent_class: VipsObjectClass,
}
#[test]
fn bindgen_test_layout__VipsSbufClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsSbufClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsSbufClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsSbufClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsSbufClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsSbufClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsSbufClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsSbufClass = _VipsSbufClass;
extern "C" {
    pub fn vips_sbuf_get_type() -> GType;
}
extern "C" {
    pub fn vips_sbuf_new_from_source(source: *mut VipsSource) -> *mut VipsSbuf;
}
extern "C" {
    pub fn vips_sbuf_unbuffer(sbuf: *mut VipsSbuf);
}
extern "C" {
    pub fn vips_sbuf_getc(sbuf: *mut VipsSbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sbuf_ungetc(sbuf: *mut VipsSbuf);
}
extern "C" {
    pub fn vips_sbuf_require(
        sbuf: *mut VipsSbuf,
        require: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sbuf_get_line(sbuf: *mut VipsSbuf) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_sbuf_get_line_copy(sbuf: *mut VipsSbuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_sbuf_get_non_whitespace(sbuf: *mut VipsSbuf) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_sbuf_skip_whitespace(sbuf: *mut VipsSbuf) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsRect {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsRect() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsRect>(),
        16usize,
        concat!("Size of: ", stringify!(_VipsRect))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRect>(),
        4usize,
        concat!("Alignment of ", stringify!(_VipsRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(height)
        )
    );
}
pub type VipsRect = _VipsRect;
extern "C" {
    pub fn vips_rect_isempty(r: *const VipsRect) -> gboolean;
}
extern "C" {
    pub fn vips_rect_includespoint(
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_rect_includesrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
extern "C" {
    pub fn vips_rect_equalsrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
extern "C" {
    pub fn vips_rect_overlapsrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
extern "C" {
    pub fn vips_rect_marginadjust(r: *mut VipsRect, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_rect_intersectrect(r1: *const VipsRect, r2: *const VipsRect, out: *mut VipsRect);
}
extern "C" {
    pub fn vips_rect_unionrect(r1: *const VipsRect, r2: *const VipsRect, out: *mut VipsRect);
}
extern "C" {
    pub fn vips_rect_dup(r: *const VipsRect) -> *mut VipsRect;
}
extern "C" {
    pub fn vips_rect_normalise(r: *mut VipsRect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct VipsWindow {
    pub ref_count: ::std::os::raw::c_int,
    pub im: *mut _VipsImage,
    pub top: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub data: *mut VipsPel,
    pub baseaddr: *mut ::std::os::raw::c_void,
    pub length: size_t,
}
#[test]
fn bindgen_test_layout_VipsWindow() {
    const UNINIT: ::std::mem::MaybeUninit<VipsWindow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VipsWindow>(),
        48usize,
        concat!("Size of: ", stringify!(VipsWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<VipsWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(VipsWindow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseaddr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(baseaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn vips_window_unref(window: *mut VipsWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_window_print(window: *mut VipsWindow);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct VipsBufferThread {
    pub hash: *mut GHashTable,
    pub thread: *mut GThread,
}
#[test]
fn bindgen_test_layout_VipsBufferThread() {
    const UNINIT: ::std::mem::MaybeUninit<VipsBufferThread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VipsBufferThread>(),
        16usize,
        concat!("Size of: ", stringify!(VipsBufferThread))
    );
    assert_eq!(
        ::std::mem::align_of::<VipsBufferThread>(),
        8usize,
        concat!("Alignment of ", stringify!(VipsBufferThread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsBufferThread),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsBufferThread),
            "::",
            stringify!(thread)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsBufferCache {
    pub buffers: *mut GSList,
    pub thread: *mut GThread,
    pub im: *mut _VipsImage,
    pub buffer_thread: *mut VipsBufferThread,
    pub reserve: *mut GSList,
    pub n_reserve: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsBufferCache() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsBufferCache> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsBufferCache>(),
        48usize,
        concat!("Size of: ", stringify!(_VipsBufferCache))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBufferCache>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBufferCache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_thread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(buffer_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserve) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_reserve) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(n_reserve)
        )
    );
}
pub type VipsBufferCache = _VipsBufferCache;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsBuffer {
    pub ref_count: ::std::os::raw::c_int,
    pub im: *mut _VipsImage,
    pub area: VipsRect,
    pub done: gboolean,
    pub cache: *mut VipsBufferCache,
    pub buf: *mut VipsPel,
    pub bsize: size_t,
}
#[test]
fn bindgen_test_layout__VipsBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsBuffer>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).done) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bsize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(bsize)
        )
    );
}
pub type VipsBuffer = _VipsBuffer;
extern "C" {
    pub fn vips_buffer_dump_all();
}
extern "C" {
    pub fn vips_buffer_done(buffer: *mut VipsBuffer);
}
extern "C" {
    pub fn vips_buffer_undone(buffer: *mut VipsBuffer);
}
extern "C" {
    pub fn vips_buffer_unref(buffer: *mut VipsBuffer);
}
extern "C" {
    pub fn vips_buffer_new(im: *mut _VipsImage, area: *mut VipsRect) -> *mut VipsBuffer;
}
extern "C" {
    pub fn vips_buffer_ref(im: *mut _VipsImage, area: *mut VipsRect) -> *mut VipsBuffer;
}
extern "C" {
    pub fn vips_buffer_unref_ref(
        buffer: *mut VipsBuffer,
        im: *mut _VipsImage,
        area: *mut VipsRect,
    ) -> *mut VipsBuffer;
}
extern "C" {
    pub fn vips_buffer_print(buffer: *mut VipsBuffer);
}
extern "C" {
    pub fn vips__render_shutdown();
}
pub const _RegionType_VIPS_REGION_NONE: _RegionType = 0;
pub const _RegionType_VIPS_REGION_BUFFER: _RegionType = 1;
pub const _RegionType_VIPS_REGION_OTHER_REGION: _RegionType = 2;
pub const _RegionType_VIPS_REGION_OTHER_IMAGE: _RegionType = 3;
pub const _RegionType_VIPS_REGION_WINDOW: _RegionType = 4;
pub type _RegionType = ::std::os::raw::c_uint;
pub use self::_RegionType as RegionType;
extern "C" {
    pub fn vips__region_take_ownership(reg: *mut _VipsRegion);
}
extern "C" {
    pub fn vips__region_check_ownership(reg: *mut _VipsRegion);
}
extern "C" {
    pub fn vips__region_no_ownership(reg: *mut _VipsRegion);
}
pub type VipsRegionFillFn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _VipsRegion,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn vips_region_fill(
        reg: *mut _VipsRegion,
        r: *const VipsRect,
        fn_: VipsRegionFillFn,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__image_wio_output(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__image_pio_output(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__argument_get_instance(
        argument_class: *mut VipsArgumentClass,
        object: *mut VipsObject,
    ) -> *mut VipsArgumentInstance;
}
extern "C" {
    pub fn vips__argument_table_lookup(
        table: *mut VipsArgumentTable,
        pspec: *mut GParamSpec,
    ) -> *mut VipsArgument;
}
extern "C" {
    pub fn vips__demand_hint_array(
        image: *mut _VipsImage,
        hint: ::std::os::raw::c_int,
        in_: *mut *mut _VipsImage,
    );
}
extern "C" {
    pub fn vips__image_copy_fields_array(
        out: *mut _VipsImage,
        in_: *mut *mut _VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__region_count_pixels(
        region: *mut _VipsRegion,
        nickname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn vips_region_dump_all();
}
extern "C" {
    pub fn vips_region_prepare_many(
        reg: *mut *mut _VipsRegion,
        r: *const VipsRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__view_image(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _vips__argument_id: ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips__meta_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct im__INTMASK {
    pub xsize: ::std::os::raw::c_int,
    pub ysize: ::std::os::raw::c_int,
    pub scale: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_int,
    pub coeff: *mut ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_im__INTMASK() {
    const UNINIT: ::std::mem::MaybeUninit<im__INTMASK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<im__INTMASK>(),
        32usize,
        concat!("Size of: ", stringify!(im__INTMASK))
    );
    assert_eq!(
        ::std::mem::align_of::<im__INTMASK>(),
        8usize,
        concat!("Alignment of ", stringify!(im__INTMASK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeff) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(filename)
        )
    );
}
pub type INTMASK = im__INTMASK;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct im__DOUBLEMASK {
    pub xsize: ::std::os::raw::c_int,
    pub ysize: ::std::os::raw::c_int,
    pub scale: f64,
    pub offset: f64,
    pub coeff: *mut f64,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_im__DOUBLEMASK() {
    const UNINIT: ::std::mem::MaybeUninit<im__DOUBLEMASK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<im__DOUBLEMASK>(),
        40usize,
        concat!("Size of: ", stringify!(im__DOUBLEMASK))
    );
    assert_eq!(
        ::std::mem::align_of::<im__DOUBLEMASK>(),
        8usize,
        concat!("Alignment of ", stringify!(im__DOUBLEMASK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeff) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(filename)
        )
    );
}
pub type DOUBLEMASK = im__DOUBLEMASK;
extern "C" {
    pub fn im_create_imask(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_create_imaskv(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        ...
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_create_dmask(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_create_dmaskv(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        ...
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_read_imask(filename: *const ::std::os::raw::c_char) -> *mut INTMASK;
}
extern "C" {
    pub fn im_read_dmask(filename: *const ::std::os::raw::c_char) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_print_imask(in_: *mut INTMASK);
}
extern "C" {
    pub fn im_print_dmask(in_: *mut DOUBLEMASK);
}
extern "C" {
    pub fn im_write_imask(in_: *mut INTMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_write_dmask(in_: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_write_imask_name(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_write_dmask_name(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_free_imask(in_: *mut INTMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_free_dmask(in_: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_log_imask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_log_dmask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_gauss_imask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_gauss_imask_sep(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_gauss_dmask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_gauss_dmask_sep(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_dup_imask(in_: *mut INTMASK, filename: *const ::std::os::raw::c_char)
        -> *mut INTMASK;
}
extern "C" {
    pub fn im_dup_dmask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_scale_dmask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_norm_dmask(mask: *mut DOUBLEMASK);
}
extern "C" {
    pub fn im_imask2dmask(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_dmask2imask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_rotate_imask90(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_rotate_imask45(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    pub fn im_rotate_dmask90(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_rotate_dmask45(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_mattrn(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_matcat(
        top: *mut DOUBLEMASK,
        bottom: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_matmul(
        in1: *mut DOUBLEMASK,
        in2: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_lu_decomp(
        mat: *const DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_lu_solve(lu: *const DOUBLEMASK, vec: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_matinv(
        mat: *const DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_matinv_inplace(mat: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_local_dmask(out: *mut _VipsImage, mask: *mut DOUBLEMASK) -> *mut DOUBLEMASK;
}
extern "C" {
    pub fn im_local_imask(out: *mut _VipsImage, mask: *mut INTMASK) -> *mut INTMASK;
}
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MEAN: VipsRegionShrink = 0;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MEDIAN: VipsRegionShrink = 1;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MODE: VipsRegionShrink = 2;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MAX: VipsRegionShrink = 3;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MIN: VipsRegionShrink = 4;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_NEAREST: VipsRegionShrink = 5;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_LAST: VipsRegionShrink = 6;
#[doc = " VipsRegionShrink:\n @VIPS_REGION_SHRINK_MEAN: use the average\n @VIPS_REGION_SHRINK_MEDIAN: use the median\n @VIPS_REGION_SHRINK_MODE: use the mode\n @VIPS_REGION_SHRINK_MAX: use the maximum\n @VIPS_REGION_SHRINK_MIN: use the minimum\n @VIPS_REGION_SHRINK_NEAREST: use the top-left pixel\n\n How to calculate the output pixels when shrinking a 2x2 region."]
pub type VipsRegionShrink = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsRegion {
    pub parent_object: VipsObject,
    pub im: *mut VipsImage,
    pub valid: VipsRect,
    pub type_: RegionType,
    pub data: *mut VipsPel,
    pub bpl: ::std::os::raw::c_int,
    pub seq: *mut ::std::os::raw::c_void,
    pub thread: *mut GThread,
    pub window: *mut VipsWindow,
    pub buffer: *mut VipsBuffer,
    pub invalid: gboolean,
}
#[test]
fn bindgen_test_layout__VipsRegion() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsRegion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsRegion>(),
        168usize,
        concat!("Size of: ", stringify!(_VipsRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsRegion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpl) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(bpl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalid) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(invalid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsRegionClass {
    pub parent_class: VipsObjectClass,
}
#[test]
fn bindgen_test_layout__VipsRegionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsRegionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsRegionClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsRegionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRegionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsRegionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsRegionClass = _VipsRegionClass;
extern "C" {
    pub fn vips_region_get_type() -> GType;
}
extern "C" {
    pub fn vips_region_new(image: *mut VipsImage) -> *mut VipsRegion;
}
extern "C" {
    pub fn vips_region_buffer(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_image(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_region(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_equalsregion(
        reg1: *mut VipsRegion,
        reg2: *mut VipsRegion,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_position(
        reg: *mut VipsRegion,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_paint(
        reg: *mut VipsRegion,
        r: *const VipsRect,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_region_paint_pel(reg: *mut VipsRegion, r: *const VipsRect, ink: *const VipsPel);
}
extern "C" {
    pub fn vips_region_black(reg: *mut VipsRegion);
}
extern "C" {
    pub fn vips_region_copy(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_region_shrink_method(
        from: *mut VipsRegion,
        to: *mut VipsRegion,
        target: *const VipsRect,
        method: VipsRegionShrink,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_shrink(
        from: *mut VipsRegion,
        to: *mut VipsRegion,
        target: *const VipsRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_prepare(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_prepare_to(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_fetch(
        region: *mut VipsRegion,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        len: *mut size_t,
    ) -> *mut VipsPel;
}
extern "C" {
    pub fn vips_region_width(region: *mut VipsRegion) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_height(region: *mut VipsRegion) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_region_invalidate(reg: *mut VipsRegion);
}
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_ERROR: VipsDemandStyle = -1;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_SMALLTILE: VipsDemandStyle = 0;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_FATSTRIP: VipsDemandStyle = 1;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_THINSTRIP: VipsDemandStyle = 2;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_ANY: VipsDemandStyle = 3;
pub type VipsDemandStyle = ::std::os::raw::c_int;
pub const VipsImageType_VIPS_IMAGE_ERROR: VipsImageType = -1;
pub const VipsImageType_VIPS_IMAGE_NONE: VipsImageType = 0;
pub const VipsImageType_VIPS_IMAGE_SETBUF: VipsImageType = 1;
pub const VipsImageType_VIPS_IMAGE_SETBUF_FOREIGN: VipsImageType = 2;
pub const VipsImageType_VIPS_IMAGE_OPENIN: VipsImageType = 3;
pub const VipsImageType_VIPS_IMAGE_MMAPIN: VipsImageType = 4;
pub const VipsImageType_VIPS_IMAGE_MMAPINRW: VipsImageType = 5;
pub const VipsImageType_VIPS_IMAGE_OPENOUT: VipsImageType = 6;
pub const VipsImageType_VIPS_IMAGE_PARTIAL: VipsImageType = 7;
pub type VipsImageType = ::std::os::raw::c_int;
pub const VipsInterpretation_VIPS_INTERPRETATION_ERROR: VipsInterpretation = -1;
pub const VipsInterpretation_VIPS_INTERPRETATION_MULTIBAND: VipsInterpretation = 0;
pub const VipsInterpretation_VIPS_INTERPRETATION_B_W: VipsInterpretation = 1;
pub const VipsInterpretation_VIPS_INTERPRETATION_HISTOGRAM: VipsInterpretation = 10;
pub const VipsInterpretation_VIPS_INTERPRETATION_XYZ: VipsInterpretation = 12;
pub const VipsInterpretation_VIPS_INTERPRETATION_LAB: VipsInterpretation = 13;
pub const VipsInterpretation_VIPS_INTERPRETATION_CMYK: VipsInterpretation = 15;
pub const VipsInterpretation_VIPS_INTERPRETATION_LABQ: VipsInterpretation = 16;
pub const VipsInterpretation_VIPS_INTERPRETATION_RGB: VipsInterpretation = 17;
pub const VipsInterpretation_VIPS_INTERPRETATION_CMC: VipsInterpretation = 18;
pub const VipsInterpretation_VIPS_INTERPRETATION_LCH: VipsInterpretation = 19;
pub const VipsInterpretation_VIPS_INTERPRETATION_LABS: VipsInterpretation = 21;
pub const VipsInterpretation_VIPS_INTERPRETATION_sRGB: VipsInterpretation = 22;
pub const VipsInterpretation_VIPS_INTERPRETATION_YXY: VipsInterpretation = 23;
pub const VipsInterpretation_VIPS_INTERPRETATION_FOURIER: VipsInterpretation = 24;
pub const VipsInterpretation_VIPS_INTERPRETATION_RGB16: VipsInterpretation = 25;
pub const VipsInterpretation_VIPS_INTERPRETATION_GREY16: VipsInterpretation = 26;
pub const VipsInterpretation_VIPS_INTERPRETATION_MATRIX: VipsInterpretation = 27;
pub const VipsInterpretation_VIPS_INTERPRETATION_scRGB: VipsInterpretation = 28;
pub const VipsInterpretation_VIPS_INTERPRETATION_HSV: VipsInterpretation = 29;
pub const VipsInterpretation_VIPS_INTERPRETATION_LAST: VipsInterpretation = 30;
pub type VipsInterpretation = ::std::os::raw::c_int;
pub const VipsBandFormat_VIPS_FORMAT_NOTSET: VipsBandFormat = -1;
pub const VipsBandFormat_VIPS_FORMAT_UCHAR: VipsBandFormat = 0;
pub const VipsBandFormat_VIPS_FORMAT_CHAR: VipsBandFormat = 1;
pub const VipsBandFormat_VIPS_FORMAT_USHORT: VipsBandFormat = 2;
pub const VipsBandFormat_VIPS_FORMAT_SHORT: VipsBandFormat = 3;
pub const VipsBandFormat_VIPS_FORMAT_UINT: VipsBandFormat = 4;
pub const VipsBandFormat_VIPS_FORMAT_INT: VipsBandFormat = 5;
pub const VipsBandFormat_VIPS_FORMAT_FLOAT: VipsBandFormat = 6;
pub const VipsBandFormat_VIPS_FORMAT_COMPLEX: VipsBandFormat = 7;
pub const VipsBandFormat_VIPS_FORMAT_DOUBLE: VipsBandFormat = 8;
pub const VipsBandFormat_VIPS_FORMAT_DPCOMPLEX: VipsBandFormat = 9;
pub const VipsBandFormat_VIPS_FORMAT_LAST: VipsBandFormat = 10;
pub type VipsBandFormat = ::std::os::raw::c_int;
pub const VipsCoding_VIPS_CODING_ERROR: VipsCoding = -1;
pub const VipsCoding_VIPS_CODING_NONE: VipsCoding = 0;
pub const VipsCoding_VIPS_CODING_LABQ: VipsCoding = 2;
pub const VipsCoding_VIPS_CODING_RAD: VipsCoding = 6;
pub const VipsCoding_VIPS_CODING_LAST: VipsCoding = 7;
pub type VipsCoding = ::std::os::raw::c_int;
pub const VipsAccess_VIPS_ACCESS_RANDOM: VipsAccess = 0;
pub const VipsAccess_VIPS_ACCESS_SEQUENTIAL: VipsAccess = 1;
pub const VipsAccess_VIPS_ACCESS_SEQUENTIAL_UNBUFFERED: VipsAccess = 2;
pub const VipsAccess_VIPS_ACCESS_LAST: VipsAccess = 3;
pub type VipsAccess = ::std::os::raw::c_uint;
pub type VipsStartFn = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsGenerateFn = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut VipsRegion,
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        stop: *mut gboolean,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsStopFn = ::std::option::Option<
    unsafe extern "C" fn(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsProgress {
    pub im: *mut VipsImage,
    pub run: ::std::os::raw::c_int,
    pub eta: ::std::os::raw::c_int,
    pub tpels: gint64,
    pub npels: gint64,
    pub percent: ::std::os::raw::c_int,
    pub start: *mut GTimer,
}
#[test]
fn bindgen_test_layout__VipsProgress() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsProgress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsProgress>(),
        48usize,
        concat!("Size of: ", stringify!(_VipsProgress))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsProgress>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsProgress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(eta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(tpels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npels) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(npels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(start)
        )
    );
}
pub type VipsProgress = _VipsProgress;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _VipsImage {
    pub parent_instance: VipsObject,
    pub Xsize: ::std::os::raw::c_int,
    pub Ysize: ::std::os::raw::c_int,
    pub Bands: ::std::os::raw::c_int,
    pub BandFmt: VipsBandFormat,
    pub Coding: VipsCoding,
    pub Type: VipsInterpretation,
    pub Xres: f64,
    pub Yres: f64,
    pub Xoffset: ::std::os::raw::c_int,
    pub Yoffset: ::std::os::raw::c_int,
    pub Length: ::std::os::raw::c_int,
    pub Compression: ::std::os::raw::c_short,
    pub Level: ::std::os::raw::c_short,
    pub Bbits: ::std::os::raw::c_int,
    pub time: *mut VipsProgress,
    pub Hist: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub data: *mut VipsPel,
    pub kill: ::std::os::raw::c_int,
    pub Xres_float: f32,
    pub Yres_float: f32,
    pub mode: *mut ::std::os::raw::c_char,
    pub dtype: VipsImageType,
    pub fd: ::std::os::raw::c_int,
    pub baseaddr: *mut ::std::os::raw::c_void,
    pub length: size_t,
    pub magic: guint32,
    pub start_fn: VipsStartFn,
    pub generate_fn: VipsGenerateFn,
    pub stop_fn: VipsStopFn,
    pub client1: *mut ::std::os::raw::c_void,
    pub client2: *mut ::std::os::raw::c_void,
    pub sslock: *mut GMutex,
    pub regions: *mut GSList,
    pub dhint: VipsDemandStyle,
    pub meta: *mut GHashTable,
    pub meta_traverse: *mut GSList,
    pub sizeof_header: gint64,
    pub windows: *mut GSList,
    pub upstream: *mut GSList,
    pub downstream: *mut GSList,
    pub serial: ::std::os::raw::c_int,
    pub history_list: *mut GSList,
    pub progress_signal: *mut VipsImage,
    pub file_length: gint64,
    pub hint_set: gboolean,
    pub delete_on_close: gboolean,
    pub delete_on_close_filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsImage() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsImage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsImage>(),
        392usize,
        concat!("Size of: ", stringify!(_VipsImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsImage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xsize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ysize) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bands) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Bands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BandFmt) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(BandFmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Coding) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Coding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xres) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Yres) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Yres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xoffset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Yoffset) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Yoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Compression) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Compression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bbits) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Bbits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hist) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Hist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kill) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(kill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xres_float) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xres_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Yres_float) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Yres_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtype) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(dtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseaddr) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(baseaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_fn) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(start_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generate_fn) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(generate_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_fn) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(stop_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(client1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(client2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sslock) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(sslock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regions) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dhint) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(dhint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_traverse) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(meta_traverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeof_header) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(sizeof_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).windows) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(windows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upstream) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(upstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).downstream) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(downstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).history_list) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(history_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_signal) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(progress_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_length) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(file_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hint_set) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(hint_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_on_close) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(delete_on_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_on_close_filename) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(delete_on_close_filename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsImageClass {
    pub parent_class: VipsObjectClass,
    pub preeval: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            progress: *mut VipsProgress,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub eval: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            progress: *mut VipsProgress,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub posteval: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            progress: *mut VipsProgress,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub written: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            result: *mut ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub invalidate: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, data: *mut ::std::os::raw::c_void),
    >,
    pub minimise: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, data: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout__VipsImageClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsImageClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsImageClass>(),
        376usize,
        concat!("Size of: ", stringify!(_VipsImageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsImageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsImageClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preeval) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(preeval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eval) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(eval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posteval) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(posteval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).written) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(invalidate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimise) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(minimise)
        )
    );
}
pub type VipsImageClass = _VipsImageClass;
extern "C" {
    pub fn vips_image_get_type() -> GType;
}
extern "C" {
    pub fn vips_progress_set(progress: gboolean);
}
extern "C" {
    pub fn vips_image_invalidate_all(image: *mut VipsImage);
}
extern "C" {
    pub fn vips_image_minimise_all(image: *mut VipsImage);
}
extern "C" {
    pub fn vips_image_is_sequential(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_set_progress(image: *mut VipsImage, progress: gboolean);
}
extern "C" {
    pub fn vips_image_iskilled(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_set_kill(image: *mut VipsImage, kill: gboolean);
}
extern "C" {
    pub fn vips_filename_get_filename(
        vips_filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_filename_get_options(
        vips_filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_image_new() -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_memory() -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_memory() -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_file(name: *const ::std::os::raw::c_char, ...) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_file_RW(filename: *const ::std::os::raw::c_char) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_file_raw(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        offset: guint64,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_memory(
        data: *const ::std::os::raw::c_void,
        size: size_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_memory_copy(
        data: *const ::std::os::raw::c_void,
        size: size_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_buffer(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        option_string: *const ::std::os::raw::c_char,
        ...
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_source(
        source: *mut VipsSource,
        option_string: *const ::std::os::raw::c_char,
        ...
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_matrix(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_matrixv(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_matrix_from_array(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        array: *const f64,
        size: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_matrix_from_array(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        array: *const f64,
        size: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_image(
        image: *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_new_from_image1(image: *mut VipsImage, c: f64) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_set_delete_on_close(image: *mut VipsImage, delete_on_close: gboolean);
}
extern "C" {
    pub fn vips_get_disc_threshold() -> guint64;
}
extern "C" {
    pub fn vips_image_new_temp_file(format: *const ::std::os::raw::c_char) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_write(image: *mut VipsImage, out: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_write_to_file(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_write_to_buffer(
        in_: *mut VipsImage,
        suffix: *const ::std::os::raw::c_char,
        buf: *mut *mut ::std::os::raw::c_void,
        size: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_write_to_target(
        in_: *mut VipsImage,
        suffix: *const ::std::os::raw::c_char,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_write_to_memory(
        in_: *mut VipsImage,
        size: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_image_decode_predict(
        in_: *mut VipsImage,
        bands: *mut ::std::os::raw::c_int,
        format: *mut VipsBandFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_decode(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_encode(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        coding: VipsCoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_isMSBfirst(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_isfile(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_ispartial(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_hasalpha(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_copy_memory(image: *mut VipsImage) -> *mut VipsImage;
}
extern "C" {
    pub fn vips_image_wio_input(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_pio_input(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_pio_output(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_inplace(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_write_prepare(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_write_line(
        image: *mut VipsImage,
        ypos: ::std::os::raw::c_int,
        linebuffer: *mut VipsPel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_band_format_isint(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    pub fn vips_band_format_isuint(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    pub fn vips_band_format_is8bit(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    pub fn vips_band_format_isfloat(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    pub fn vips_band_format_iscomplex(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    pub fn vips_system(cmd_format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_array_image_new(
        array: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayImage;
}
extern "C" {
    pub fn vips_array_image_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayImage;
}
extern "C" {
    pub fn vips_array_image_new_from_string(
        string: *const ::std::os::raw::c_char,
        flags: VipsAccess,
    ) -> *mut VipsArrayImage;
}
extern "C" {
    pub fn vips_array_image_empty() -> *mut VipsArrayImage;
}
extern "C" {
    pub fn vips_array_image_append(
        array: *mut VipsArrayImage,
        image: *mut VipsImage,
    ) -> *mut VipsArrayImage;
}
extern "C" {
    pub fn vips_array_image_get(
        array: *mut VipsArrayImage,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut VipsImage;
}
extern "C" {
    pub fn vips_value_get_array_image(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut VipsImage;
}
extern "C" {
    pub fn vips_value_set_array_image(value: *mut GValue, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_reorder_prepare_many(
        image: *mut VipsImage,
        regions: *mut *mut VipsRegion,
        r: *mut VipsRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_reorder_margin_hint(image: *mut VipsImage, margin: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_image_free_buffer(image: *mut VipsImage, buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vips_malloc(object: *mut VipsObject, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_strdup(
        object: *mut VipsObject,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_tracked_free(s: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vips_tracked_aligned_free(s: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vips_tracked_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_tracked_aligned_alloc(size: size_t, align: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_tracked_get_mem() -> size_t;
}
extern "C" {
    pub fn vips_tracked_get_mem_highwater() -> size_t;
}
extern "C" {
    pub fn vips_tracked_get_allocs() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tracked_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tracked_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tracked_get_files() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_error_buffer() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_error_buffer_copy() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_error_clear();
}
extern "C" {
    pub fn vips_error_freeze();
}
extern "C" {
    pub fn vips_error_thaw();
}
extern "C" {
    pub fn vips_error(
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn vips_verror(
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    pub fn vips_error_system(
        err: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn vips_verror_system(
        err: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    pub fn vips_error_g(error: *mut *mut GError);
}
extern "C" {
    pub fn vips_g_error(error: *mut *mut GError);
}
extern "C" {
    pub fn vips_error_exit(fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    pub fn vips_check_uncoded(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_coding(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        coding: VipsCoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_coding_known(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_coding_noneorlabq(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_coding_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_mono(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bands(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bands_1or3(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bands_atleast(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bands_1orn(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bands_1orn_unary(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bands_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_bandno(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bandno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_int(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_uint(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_uintorf(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_noncomplex(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_complex(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_twocomponents(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_format(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        fmt: VipsBandFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_u8or16(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_8or16(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_u8or16orf(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_format_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_size_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_oddsquare(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_vector_length(
        domain: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_vector(
        domain: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_hist(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_matrix(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_separable(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_check_precision_intfloat(
        domain: *const ::std::os::raw::c_char,
        precision: VipsPrecision,
    ) -> ::std::os::raw::c_int;
}
pub const VipsFormatFlags_VIPS_FORMAT_NONE: VipsFormatFlags = 0;
pub const VipsFormatFlags_VIPS_FORMAT_PARTIAL: VipsFormatFlags = 1;
pub const VipsFormatFlags_VIPS_FORMAT_BIGENDIAN: VipsFormatFlags = 2;
pub type VipsFormatFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsFormat {
    pub parent_object: VipsObject,
}
#[test]
fn bindgen_test_layout__VipsFormat() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsFormat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsFormat>(),
        80usize,
        concat!("Size of: ", stringify!(_VipsFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsFormat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormat),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsFormat = _VipsFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsFormatClass {
    pub parent_class: VipsObjectClass,
    pub is_a: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> gboolean,
    >,
    pub header: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut VipsImage,
        ) -> ::std::os::raw::c_int,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut VipsImage,
        ) -> ::std::os::raw::c_int,
    >,
    pub save: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsImage,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> VipsFormatFlags,
    >,
    pub priority: ::std::os::raw::c_int,
    pub suffs: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsFormatClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsFormatClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsFormatClass>(),
        384usize,
        concat!("Size of: ", stringify!(_VipsFormatClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsFormatClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsFormatClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_a) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(is_a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_flags) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suffs) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(suffs)
        )
    );
}
pub type VipsFormatClass = _VipsFormatClass;
extern "C" {
    pub fn vips_format_get_type() -> GType;
}
extern "C" {
    pub fn vips_format_map(
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_format_for_file(filename: *const ::std::os::raw::c_char) -> *mut VipsFormatClass;
}
extern "C" {
    pub fn vips_format_for_name(filename: *const ::std::os::raw::c_char) -> *mut VipsFormatClass;
}
extern "C" {
    pub fn vips_format_get_flags(
        format: *mut VipsFormatClass,
        filename: *const ::std::os::raw::c_char,
    ) -> VipsFormatFlags;
}
extern "C" {
    pub fn vips_format_read(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_format_write(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type VipsRegionWrite = ::std::option::Option<
    unsafe extern "C" fn(
        region: *mut VipsRegion,
        area: *mut VipsRect,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn vips_sink_disc(
        im: *mut VipsImage,
        write_fn: VipsRegionWrite,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sink(
        im: *mut VipsImage,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sink_tile(
        im: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type VipsSinkNotify = ::std::option::Option<
    unsafe extern "C" fn(im: *mut VipsImage, rect: *mut VipsRect, a: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn vips_sink_screen(
        in_: *mut VipsImage,
        out: *mut VipsImage,
        mask: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        max_tiles: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        notify_fn: VipsSinkNotify,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sink_memory(im: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_start_one(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_stop_one(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_start_many(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_stop_many(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_allocate_input_array(out: *mut VipsImage, ...) -> *mut *mut VipsImage;
}
extern "C" {
    pub fn vips_image_generate(
        image: *mut VipsImage,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_pipeline_array(
        image: *mut VipsImage,
        hint: VipsDemandStyle,
        in_: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_pipelinev(
        image: *mut VipsImage,
        hint: VipsDemandStyle,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsInterpolate {
    pub parent_object: VipsObject,
}
#[test]
fn bindgen_test_layout__VipsInterpolate() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsInterpolate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsInterpolate>(),
        80usize,
        concat!("Size of: ", stringify!(_VipsInterpolate))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsInterpolate>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsInterpolate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolate),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsInterpolate = _VipsInterpolate;
pub type VipsInterpolateMethod = ::std::option::Option<
    unsafe extern "C" fn(
        interpolate: *mut VipsInterpolate,
        out: *mut ::std::os::raw::c_void,
        in_: *mut VipsRegion,
        x: f64,
        y: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsInterpolateClass {
    pub parent_class: VipsObjectClass,
    pub interpolate: VipsInterpolateMethod,
    pub get_window_size: ::std::option::Option<
        unsafe extern "C" fn(interpolate: *mut VipsInterpolate) -> ::std::os::raw::c_int,
    >,
    pub window_size: ::std::os::raw::c_int,
    pub get_window_offset: ::std::option::Option<
        unsafe extern "C" fn(interpolate: *mut VipsInterpolate) -> ::std::os::raw::c_int,
    >,
    pub window_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsInterpolateClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsInterpolateClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsInterpolateClass>(),
        368usize,
        concat!("Size of: ", stringify!(_VipsInterpolateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsInterpolateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsInterpolateClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interpolate) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(interpolate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_window_size) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(get_window_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_size) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(window_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_window_offset) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(get_window_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_offset) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(window_offset)
        )
    );
}
pub type VipsInterpolateClass = _VipsInterpolateClass;
extern "C" {
    pub fn vips_interpolate_get_type() -> GType;
}
extern "C" {
    pub fn vips_interpolate(
        interpolate: *mut VipsInterpolate,
        out: *mut ::std::os::raw::c_void,
        in_: *mut VipsRegion,
        x: f64,
        y: f64,
    );
}
extern "C" {
    pub fn vips_interpolate_get_method(interpolate: *mut VipsInterpolate) -> VipsInterpolateMethod;
}
extern "C" {
    pub fn vips_interpolate_get_window_size(
        interpolate: *mut VipsInterpolate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_interpolate_get_window_offset(
        interpolate: *mut VipsInterpolate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_interpolate_nearest_static() -> *mut VipsInterpolate;
}
extern "C" {
    pub fn vips_interpolate_bilinear_static() -> *mut VipsInterpolate;
}
extern "C" {
    pub fn vips_interpolate_new(nickname: *const ::std::os::raw::c_char) -> *mut VipsInterpolate;
}
extern "C" {
    pub fn vips_g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn vips_g_mutex_free(arg1: *mut GMutex);
}
extern "C" {
    pub fn vips_g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn vips_g_cond_free(arg1: *mut GCond);
}
extern "C" {
    pub fn vips_g_thread_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: GThreadFunc,
        arg3: gpointer,
    ) -> *mut GThread;
}
extern "C" {
    pub fn vips_thread_isvips() -> gboolean;
}
extern "C" {
    pub fn vips_thread_execute(
        domain: *const ::std::os::raw::c_char,
        func: GFunc,
        data: gpointer,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThreadset {
    _unused: [u8; 0],
}
pub type VipsThreadset = _VipsThreadset;
extern "C" {
    pub fn vips_threadset_new(max_threads: ::std::os::raw::c_int) -> *mut VipsThreadset;
}
extern "C" {
    pub fn vips_threadset_run(
        set: *mut VipsThreadset,
        domain: *const ::std::os::raw::c_char,
        func: GFunc,
        data: gpointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_threadset_free(set: *mut VipsThreadset);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct VipsSemaphore {
    pub name: *mut ::std::os::raw::c_char,
    pub v: ::std::os::raw::c_int,
    pub mutex: *mut GMutex,
    pub cond: *mut GCond,
}
#[test]
fn bindgen_test_layout_VipsSemaphore() {
    const UNINIT: ::std::mem::MaybeUninit<VipsSemaphore> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VipsSemaphore>(),
        32usize,
        concat!("Size of: ", stringify!(VipsSemaphore))
    );
    assert_eq!(
        ::std::mem::align_of::<VipsSemaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(VipsSemaphore))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(cond)
        )
    );
}
extern "C" {
    pub fn vips_semaphore_up(s: *mut VipsSemaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_semaphore_upn(
        s: *mut VipsSemaphore,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_semaphore_down(s: *mut VipsSemaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_semaphore_downn(
        s: *mut VipsSemaphore,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_semaphore_down_timeout(
        s: *mut VipsSemaphore,
        timeout: gint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_semaphore_destroy(s: *mut VipsSemaphore);
}
extern "C" {
    pub fn vips_semaphore_init(
        s: *mut VipsSemaphore,
        v: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsThreadState {
    pub parent_object: VipsObject,
    pub im: *mut VipsImage,
    pub reg: *mut VipsRegion,
    pub pos: VipsRect,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub stop: gboolean,
    pub a: *mut ::std::os::raw::c_void,
    pub stall: gboolean,
}
#[test]
fn bindgen_test_layout__VipsThreadState() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsThreadState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsThreadState>(),
        144usize,
        concat!("Size of: ", stringify!(_VipsThreadState))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsThreadState>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsThreadState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stall) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(stall)
        )
    );
}
pub type VipsThreadState = _VipsThreadState;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsThreadStateClass {
    pub parent_class: VipsObjectClass,
}
#[test]
fn bindgen_test_layout__VipsThreadStateClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsThreadStateClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsThreadStateClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsThreadStateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsThreadStateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsThreadStateClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadStateClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsThreadStateClass = _VipsThreadStateClass;
extern "C" {
    pub fn vips_thread_state_set(
        object: *mut VipsObject,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_thread_state_get_type() -> GType;
}
extern "C" {
    pub fn vips_thread_state_new(
        im: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut VipsThreadState;
}
pub type VipsThreadStartFn = ::std::option::Option<
    unsafe extern "C" fn(
        im: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut VipsThreadState,
>;
pub type VipsThreadpoolAllocateFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VipsThreadState,
        a: *mut ::std::os::raw::c_void,
        stop: *mut gboolean,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsThreadpoolWorkFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VipsThreadState,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsThreadpoolProgressFn = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn vips_threadpool_run(
        im: *mut VipsImage,
        start: VipsThreadStartFn,
        allocate: VipsThreadpoolAllocateFn,
        work: VipsThreadpoolWorkFn,
        progress: VipsThreadpoolProgressFn,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_get_tile_size(
        im: *mut VipsImage,
        tile_width: *mut ::std::os::raw::c_int,
        tile_height: *mut ::std::os::raw::c_int,
        n_lines: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_format_sizeof(format: VipsBandFormat) -> guint64;
}
extern "C" {
    pub fn vips_format_sizeof_unsafe(format: VipsBandFormat) -> guint64;
}
extern "C" {
    pub fn vips_interpretation_max_alpha(interpretation: VipsInterpretation) -> f64;
}
extern "C" {
    pub fn vips_image_get_width(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_height(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_bands(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_format(image: *const VipsImage) -> VipsBandFormat;
}
extern "C" {
    pub fn vips_image_get_format_max(format: VipsBandFormat) -> f64;
}
extern "C" {
    pub fn vips_image_guess_format(image: *const VipsImage) -> VipsBandFormat;
}
extern "C" {
    pub fn vips_image_get_coding(image: *const VipsImage) -> VipsCoding;
}
extern "C" {
    pub fn vips_image_get_interpretation(image: *const VipsImage) -> VipsInterpretation;
}
extern "C" {
    pub fn vips_image_guess_interpretation(image: *const VipsImage) -> VipsInterpretation;
}
extern "C" {
    pub fn vips_image_get_xres(image: *const VipsImage) -> f64;
}
extern "C" {
    pub fn vips_image_get_yres(image: *const VipsImage) -> f64;
}
extern "C" {
    pub fn vips_image_get_xoffset(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_yoffset(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_filename(image: *const VipsImage) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_image_get_mode(image: *const VipsImage) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_image_get_scale(image: *const VipsImage) -> f64;
}
extern "C" {
    pub fn vips_image_get_offset(image: *const VipsImage) -> f64;
}
extern "C" {
    pub fn vips_image_get_page_height(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_n_pages(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_n_subifds(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_orientation(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_orientation_swap(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_image_get_concurrency(
        image: *mut VipsImage,
        default_concurrency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_data(image: *mut VipsImage) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_image_init_fields(
        image: *mut VipsImage,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
        coding: VipsCoding,
        interpretation: VipsInterpretation,
        xres: f64,
        yres: f64,
    );
}
extern "C" {
    pub fn vips_image_set(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        value: *mut GValue,
    );
}
extern "C" {
    pub fn vips_image_get(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        value_copy: *mut GValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_as_string(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_typeof(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
    ) -> GType;
}
extern "C" {
    pub fn vips_image_remove(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
pub type VipsImageMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        value: *mut GValue,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn vips_image_map(
        image: *mut VipsImage,
        fn_: VipsImageMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vips_image_get_fields(image: *mut VipsImage) -> *mut *mut gchar;
}
extern "C" {
    pub fn vips_image_set_area(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vips_image_get_area(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_set_blob(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    );
}
extern "C" {
    pub fn vips_image_set_blob_copy(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    );
}
extern "C" {
    pub fn vips_image_get_blob(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *mut *const ::std::os::raw::c_void,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_int(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_set_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_image_get_double(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_set_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        d: f64,
    );
}
extern "C" {
    pub fn vips_image_get_string(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_set_string(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn vips_image_print_field(image: *const VipsImage, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vips_image_get_image(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_set_image(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    );
}
extern "C" {
    pub fn vips_image_set_array_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_image_get_array_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_array_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut f64,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_set_array_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        array: *const f64,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vips_image_history_printf(
        image: *mut VipsImage,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_history_args(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_image_get_history(image: *mut VipsImage) -> *const ::std::os::raw::c_char;
}
pub const VipsOperationFlags_VIPS_OPERATION_NONE: VipsOperationFlags = 0;
pub const VipsOperationFlags_VIPS_OPERATION_SEQUENTIAL: VipsOperationFlags = 1;
pub const VipsOperationFlags_VIPS_OPERATION_SEQUENTIAL_UNBUFFERED: VipsOperationFlags = 2;
pub const VipsOperationFlags_VIPS_OPERATION_NOCACHE: VipsOperationFlags = 4;
pub const VipsOperationFlags_VIPS_OPERATION_DEPRECATED: VipsOperationFlags = 8;
pub const VipsOperationFlags_VIPS_OPERATION_UNTRUSTED: VipsOperationFlags = 16;
pub const VipsOperationFlags_VIPS_OPERATION_BLOCKED: VipsOperationFlags = 32;
pub const VipsOperationFlags_VIPS_OPERATION_REVALIDATE: VipsOperationFlags = 64;
pub type VipsOperationFlags = ::std::os::raw::c_uint;
pub type VipsOperationBuildFn =
    ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject) -> gboolean>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsOperation {
    pub parent_instance: VipsObject,
    pub hash: guint,
    pub found_hash: gboolean,
    pub pixels: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsOperation() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsOperation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsOperation>(),
        96usize,
        concat!("Size of: ", stringify!(_VipsOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsOperation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).found_hash) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(found_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixels) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(pixels)
        )
    );
}
pub type VipsOperation = _VipsOperation;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsOperationClass {
    pub parent_class: VipsObjectClass,
    pub usage: ::std::option::Option<
        unsafe extern "C" fn(cls: *mut _VipsOperationClass, buf: *mut VipsBuf),
    >,
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(operation: *mut VipsOperation) -> VipsOperationFlags,
    >,
    pub flags: VipsOperationFlags,
    pub invalidate: ::std::option::Option<unsafe extern "C" fn(operation: *mut VipsOperation)>,
}
#[test]
fn bindgen_test_layout__VipsOperationClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsOperationClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsOperationClass>(),
        360usize,
        concat!("Size of: ", stringify!(_VipsOperationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsOperationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsOperationClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_flags) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalidate) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(invalidate)
        )
    );
}
pub type VipsOperationClass = _VipsOperationClass;
extern "C" {
    pub fn vips_operation_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_get_flags(operation: *mut VipsOperation) -> VipsOperationFlags;
}
extern "C" {
    pub fn vips_operation_class_print_usage(operation_class: *mut VipsOperationClass);
}
extern "C" {
    pub fn vips_operation_invalidate(operation: *mut VipsOperation);
}
extern "C" {
    pub fn vips_operation_call_valist(
        operation: *mut VipsOperation,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_operation_new(name: *const ::std::os::raw::c_char) -> *mut VipsOperation;
}
extern "C" {
    pub fn vips_call_required_optional(
        operation: *mut *mut VipsOperation,
        required: va_list,
        optional: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_call(operation_name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_call_split(
        operation_name: *const ::std::os::raw::c_char,
        optional: va_list,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_call_split_option_string(
        operation_name: *const ::std::os::raw::c_char,
        option_string: *const ::std::os::raw::c_char,
        optional: va_list,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_call_options(group: *mut GOptionGroup, operation: *mut VipsOperation);
}
extern "C" {
    pub fn vips_call_argv(
        operation: *mut VipsOperation,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cache_drop_all();
}
extern "C" {
    pub fn vips_cache_operation_lookup(operation: *mut VipsOperation) -> *mut VipsOperation;
}
extern "C" {
    pub fn vips_cache_operation_add(operation: *mut VipsOperation);
}
extern "C" {
    pub fn vips_cache_operation_buildp(operation: *mut *mut VipsOperation)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cache_operation_build(operation: *mut VipsOperation) -> *mut VipsOperation;
}
extern "C" {
    pub fn vips_cache_print();
}
extern "C" {
    pub fn vips_cache_set_max(max: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_cache_set_max_mem(max_mem: size_t);
}
extern "C" {
    pub fn vips_cache_get_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cache_get_size() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cache_get_max_mem() -> size_t;
}
extern "C" {
    pub fn vips_cache_get_max_files() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cache_set_max_files(max_files: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_cache_set_dump(dump: gboolean);
}
extern "C" {
    pub fn vips_cache_set_trace(trace: gboolean);
}
extern "C" {
    pub fn vips_concurrency_set(concurrency: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vips_concurrency_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_operation_block_set(name: *const ::std::os::raw::c_char, state: gboolean);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsForeign {
    pub parent_object: VipsOperation,
}
#[test]
fn bindgen_test_layout__VipsForeign() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsForeign> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsForeign>(),
        96usize,
        concat!("Size of: ", stringify!(_VipsForeign))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeign>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeign))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeign),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsForeign = _VipsForeign;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsForeignClass {
    pub parent_class: VipsOperationClass,
    pub priority: ::std::os::raw::c_int,
    pub suffs: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsForeignClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsForeignClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignClass>(),
        376usize,
        concat!("Size of: ", stringify!(_VipsForeignClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignClass),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suffs) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignClass),
            "::",
            stringify!(suffs)
        )
    );
}
pub type VipsForeignClass = _VipsForeignClass;
extern "C" {
    pub fn vips_foreign_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_map(
        base: *const ::std::os::raw::c_char,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub const VipsForeignFlags_VIPS_FOREIGN_NONE: VipsForeignFlags = 0;
pub const VipsForeignFlags_VIPS_FOREIGN_PARTIAL: VipsForeignFlags = 1;
pub const VipsForeignFlags_VIPS_FOREIGN_BIGENDIAN: VipsForeignFlags = 2;
pub const VipsForeignFlags_VIPS_FOREIGN_SEQUENTIAL: VipsForeignFlags = 4;
pub const VipsForeignFlags_VIPS_FOREIGN_ALL: VipsForeignFlags = 7;
pub type VipsForeignFlags = ::std::os::raw::c_uint;
pub const VipsFailOn_VIPS_FAIL_ON_NONE: VipsFailOn = 0;
pub const VipsFailOn_VIPS_FAIL_ON_TRUNCATED: VipsFailOn = 1;
pub const VipsFailOn_VIPS_FAIL_ON_ERROR: VipsFailOn = 2;
pub const VipsFailOn_VIPS_FAIL_ON_WARNING: VipsFailOn = 3;
pub const VipsFailOn_VIPS_FAIL_ON_LAST: VipsFailOn = 4;
#[doc = " VipsFailOn:\n @VIPS_FAIL_ON_NONE: never stop\n @VIPS_FAIL_ON_TRUNCATED: stop on image truncated, nothing else\n @VIPS_FAIL_ON_ERROR: stop on serious error or truncation\n @VIPS_FAIL_ON_WARNING: stop on anything, even warnings\n\n How sensitive loaders are to errors, from never stop (very insensitive), to\n stop on the smallest warning (very sensitive).\n\n Each one implies the ones before it, so #VIPS_FAIL_ON_ERROR implies\n #VIPS_FAIL_ON_TRUNCATED."]
pub type VipsFailOn = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsForeignLoad {
    pub parent_object: VipsForeign,
    pub memory: gboolean,
    pub access: VipsAccess,
    pub flags: VipsForeignFlags,
    pub fail_on: VipsFailOn,
    pub fail: gboolean,
    pub sequential: gboolean,
    pub out: *mut VipsImage,
    pub real: *mut VipsImage,
    pub nocache: gboolean,
    pub disc: gboolean,
    pub error: gboolean,
    pub revalidate: gboolean,
}
#[test]
fn bindgen_test_layout__VipsForeignLoad() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsForeignLoad> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignLoad>(),
        152usize,
        concat!("Size of: ", stringify!(_VipsForeignLoad))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignLoad>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignLoad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fail_on) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(fail_on)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fail) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(fail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequential) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(sequential)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nocache) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(nocache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(disc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revalidate) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(revalidate)
        )
    );
}
pub type VipsForeignLoad = _VipsForeignLoad;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsForeignLoadClass {
    pub parent_class: VipsForeignClass,
    pub is_a: ::std::option::Option<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> gboolean,
    >,
    pub is_a_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *const ::std::os::raw::c_void, size: size_t) -> gboolean,
    >,
    pub is_a_source:
        ::std::option::Option<unsafe extern "C" fn(source: *mut VipsSource) -> gboolean>,
    pub get_flags_filename: ::std::option::Option<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> VipsForeignFlags,
    >,
    pub get_flags:
        ::std::option::Option<unsafe extern "C" fn(load: *mut VipsForeignLoad) -> VipsForeignFlags>,
    pub header: ::std::option::Option<
        unsafe extern "C" fn(load: *mut VipsForeignLoad) -> ::std::os::raw::c_int,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(load: *mut VipsForeignLoad) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__VipsForeignLoadClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsForeignLoadClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignLoadClass>(),
        432usize,
        concat!("Size of: ", stringify!(_VipsForeignLoadClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignLoadClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignLoadClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_a) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(is_a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_a_buffer) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(is_a_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_a_source) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(is_a_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_flags_filename) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(get_flags_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_flags) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(load)
        )
    );
}
pub type VipsForeignLoadClass = _VipsForeignLoadClass;
extern "C" {
    pub fn vips_foreign_load_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_find_load(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_foreign_find_load_buffer(
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_foreign_find_load_source(source: *mut VipsSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_foreign_flags(
        loader: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> VipsForeignFlags;
}
extern "C" {
    pub fn vips_foreign_is_a(
        loader: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_foreign_is_a_buffer(
        loader: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_foreign_is_a_source(
        loader: *const ::std::os::raw::c_char,
        source: *mut VipsSource,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_foreign_load_invalidate(image: *mut VipsImage);
}
pub const VipsSaveable_VIPS_SAVEABLE_MONO: VipsSaveable = 0;
pub const VipsSaveable_VIPS_SAVEABLE_RGB: VipsSaveable = 1;
pub const VipsSaveable_VIPS_SAVEABLE_RGBA: VipsSaveable = 2;
pub const VipsSaveable_VIPS_SAVEABLE_RGBA_ONLY: VipsSaveable = 3;
pub const VipsSaveable_VIPS_SAVEABLE_RGB_CMYK: VipsSaveable = 4;
pub const VipsSaveable_VIPS_SAVEABLE_ANY: VipsSaveable = 5;
pub const VipsSaveable_VIPS_SAVEABLE_LAST: VipsSaveable = 6;
#[doc = " VipsSaveable:\n @VIPS_SAVEABLE_MONO: 1 band (eg. CSV)\n @VIPS_SAVEABLE_RGB: 1 or 3 bands (eg. PPM)\n @VIPS_SAVEABLE_RGBA: 1, 2, 3 or 4 bands (eg. PNG)\n @VIPS_SAVEABLE_RGBA_ONLY: 3 or 4 bands (eg. WEBP)\n @VIPS_SAVEABLE_RGB_CMYK: 1, 3 or 4 bands (eg. JPEG)\n @VIPS_SAVEABLE_ANY: any number of bands (eg. TIFF)\n\n See also: #VipsForeignSave."]
pub type VipsSaveable = ::std::os::raw::c_uint;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_NONE: VipsForeignKeep = 0;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_EXIF: VipsForeignKeep = 1;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_XMP: VipsForeignKeep = 2;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_IPTC: VipsForeignKeep = 4;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_ICC: VipsForeignKeep = 8;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_OTHER: VipsForeignKeep = 16;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_ALL: VipsForeignKeep = 31;
#[doc = " VipsForeignKeep:\n @VIPS_FOREIGN_KEEP_NONE: don't attach metadata\n @VIPS_FOREIGN_KEEP_EXIF: keep Exif metadata\n @VIPS_FOREIGN_KEEP_XMP: keep XMP metadata\n @VIPS_FOREIGN_KEEP_IPTC: keep IPTC metadata\n @VIPS_FOREIGN_KEEP_ICC: keep ICC metadata\n @VIPS_FOREIGN_KEEP_OTHER: keep other metadata (e.g. PNG comments and some TIFF tags)\n @VIPS_FOREIGN_KEEP_ALL: keep all metadata\n\n Which metadata to retain."]
pub type VipsForeignKeep = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsForeignSave {
    pub parent_object: VipsForeign,
    pub strip: gboolean,
    pub keep: VipsForeignKeep,
    pub profile: *mut ::std::os::raw::c_char,
    pub background: *mut VipsArrayDouble,
    pub page_height: ::std::os::raw::c_int,
    pub in_: *mut VipsImage,
    pub ready: *mut VipsImage,
}
#[test]
fn bindgen_test_layout__VipsForeignSave() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsForeignSave> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignSave>(),
        144usize,
        concat!("Size of: ", stringify!(_VipsForeignSave))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignSave>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignSave))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strip) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(strip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(keep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(page_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ready) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(ready)
        )
    );
}
pub type VipsForeignSave = _VipsForeignSave;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VipsForeignSaveClass {
    pub parent_class: VipsForeignClass,
    pub saveable: VipsSaveable,
    pub format_table: *mut VipsBandFormat,
    pub coding: [gboolean; 7usize],
}
#[test]
fn bindgen_test_layout__VipsForeignSaveClass() {
    const UNINIT: ::std::mem::MaybeUninit<_VipsForeignSaveClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignSaveClass>(),
        424usize,
        concat!("Size of: ", stringify!(_VipsForeignSaveClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignSaveClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignSaveClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saveable) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(saveable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_table) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(format_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coding) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(coding)
        )
    );
}
pub type VipsForeignSaveClass = _VipsForeignSaveClass;
extern "C" {
    pub fn vips_foreign_save_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_find_save(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_foreign_get_suffixes() -> *mut *mut gchar;
}
extern "C" {
    pub fn vips_foreign_find_save_buffer(
        suffix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_foreign_find_save_target(
        suffix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_vipsload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_vipsload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_vipssave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_vipssave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_openslideload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_openslideload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_AUTO: VipsForeignSubsample = 0;
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_ON: VipsForeignSubsample = 1;
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_OFF: VipsForeignSubsample = 2;
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_LAST: VipsForeignSubsample = 3;
#[doc = " VipsForeignSubsample:\n @VIPS_FOREIGN_SUBSAMPLE_AUTO: prevent subsampling when quality >= 90\n @VIPS_FOREIGN_SUBSAMPLE_ON: always perform subsampling\n @VIPS_FOREIGN_SUBSAMPLE_OFF: never perform subsampling\n\n Set subsampling mode."]
pub type VipsForeignSubsample = ::std::os::raw::c_uint;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_AUTO: VipsForeignJpegSubsample = 0;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_ON: VipsForeignJpegSubsample = 1;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_OFF: VipsForeignJpegSubsample = 2;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_LAST: VipsForeignJpegSubsample = 3;
#[doc = " VipsForeignJpegSubsample:\n @VIPS_FOREIGN_JPEG_SUBSAMPLE_AUTO: default preset\n @VIPS_FOREIGN_JPEG_SUBSAMPLE_ON: always perform subsampling\n @VIPS_FOREIGN_JPEG_SUBSAMPLE_OFF: never perform subsampling\n\n Set jpeg subsampling mode.\n\n DEPRECATED: use #VipsForeignSubsample"]
pub type VipsForeignJpegSubsample = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_jpegload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jpegload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jpegload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jpegsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jpegsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jpegsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jpegsave_mime(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_DEFAULT: VipsForeignWebpPreset = 0;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_PICTURE: VipsForeignWebpPreset = 1;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_PHOTO: VipsForeignWebpPreset = 2;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_DRAWING: VipsForeignWebpPreset = 3;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_ICON: VipsForeignWebpPreset = 4;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_TEXT: VipsForeignWebpPreset = 5;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_LAST: VipsForeignWebpPreset = 6;
#[doc = " VipsForeignWebpPreset:\n @VIPS_FOREIGN_WEBP_PRESET_DEFAULT: default preset\n @VIPS_FOREIGN_WEBP_PRESET_PICTURE: digital picture, like portrait, inner shot\n @VIPS_FOREIGN_WEBP_PRESET_PHOTO: outdoor photograph, with natural lighting\n @VIPS_FOREIGN_WEBP_PRESET_DRAWING: hand or line drawing, with high-contrast details\n @VIPS_FOREIGN_WEBP_PRESET_ICON: small-sized colorful images\n @VIPS_FOREIGN_WEBP_PRESET_TEXT: text-like\n\n Tune lossy encoder settings for different image types."]
pub type VipsForeignWebpPreset = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_webpload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_webpload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_webpload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_webpsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_webpsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_webpsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_webpsave_mime(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_NONE:
    VipsForeignTiffCompression = 0;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_JPEG:
    VipsForeignTiffCompression = 1;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE:
    VipsForeignTiffCompression = 2;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS:
    VipsForeignTiffCompression = 3;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4:
    VipsForeignTiffCompression = 4;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_LZW: VipsForeignTiffCompression =
    5;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_WEBP:
    VipsForeignTiffCompression = 6;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD:
    VipsForeignTiffCompression = 7;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_JP2K:
    VipsForeignTiffCompression = 8;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_LAST:
    VipsForeignTiffCompression = 9;
#[doc = " VipsForeignTiffCompression:\n @VIPS_FOREIGN_TIFF_COMPRESSION_NONE: no compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_JPEG: jpeg compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE: deflate (zip) compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS: packbits compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4: fax4 compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_LZW: LZW compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_WEBP: WEBP compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD: ZSTD compression\n @VIPS_FOREIGN_TIFF_COMPRESSION_JP2K: JP2K compression\n\n The compression types supported by the tiff writer.\n\n Use @Q to set the jpeg compression level, default 75.\n\n Use @predictor to set the lzw or deflate prediction, default horizontal.\n\n Use @lossless to set WEBP lossless compression.\n\n Use @level to set webp and zstd compression level."]
pub type VipsForeignTiffCompression = ::std::os::raw::c_uint;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_NONE: VipsForeignTiffPredictor = 1;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL:
    VipsForeignTiffPredictor = 2;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT: VipsForeignTiffPredictor = 3;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_LAST: VipsForeignTiffPredictor = 4;
#[doc = " VipsForeignTiffPredictor:\n @VIPS_FOREIGN_TIFF_PREDICTOR_NONE: no prediction\n @VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL: horizontal differencing\n @VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT: float predictor\n\n The predictor can help deflate and lzw compression. The values are fixed by\n the tiff library."]
pub type VipsForeignTiffPredictor = ::std::os::raw::c_uint;
pub const VipsForeignTiffResunit_VIPS_FOREIGN_TIFF_RESUNIT_CM: VipsForeignTiffResunit = 0;
pub const VipsForeignTiffResunit_VIPS_FOREIGN_TIFF_RESUNIT_INCH: VipsForeignTiffResunit = 1;
pub const VipsForeignTiffResunit_VIPS_FOREIGN_TIFF_RESUNIT_LAST: VipsForeignTiffResunit = 2;
#[doc = " VipsForeignTiffResunit:\n @VIPS_FOREIGN_TIFF_RESUNIT_CM: use centimeters\n @VIPS_FOREIGN_TIFF_RESUNIT_INCH: use inches\n\n Use inches or centimeters as the resolution unit for a tiff file."]
pub type VipsForeignTiffResunit = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_tiffload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tiffload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tiffload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tiffsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tiffsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tiffsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_openexrload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_fitsload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_fitssave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_analyzeload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rawload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rawsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rawsave_fd(
        in_: *mut VipsImage,
        fd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_csvload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_csvload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_csvsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_csvsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matrixload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matrixload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matrixsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matrixsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matrixprint(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_magickload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_magickload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_magicksave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_magicksave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_NONE: VipsForeignPngFilter = 8;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_SUB: VipsForeignPngFilter = 16;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_UP: VipsForeignPngFilter = 32;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_AVG: VipsForeignPngFilter = 64;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_PAETH: VipsForeignPngFilter = 128;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_ALL: VipsForeignPngFilter = 248;
#[doc = " VipsForeignPngFilter:\n @VIPS_FOREIGN_PNG_FILTER_NONE: no filtering\n @VIPS_FOREIGN_PNG_FILTER_SUB: difference to the left\n @VIPS_FOREIGN_PNG_FILTER_UP: difference up\n @VIPS_FOREIGN_PNG_FILTER_AVG: average of left and up\n @VIPS_FOREIGN_PNG_FILTER_PAETH: pick best neighbor predictor automatically\n @VIPS_FOREIGN_PNG_FILTER_ALL: adaptive\n\n http://www.w3.org/TR/PNG-Filters.html\n The values mirror those of png.h in libpng."]
pub type VipsForeignPngFilter = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_pngload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pngload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pngload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pngsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pngsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pngsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PBM: VipsForeignPpmFormat = 0;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PGM: VipsForeignPpmFormat = 1;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PPM: VipsForeignPpmFormat = 2;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PFM: VipsForeignPpmFormat = 3;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PNM: VipsForeignPpmFormat = 4;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_LAST: VipsForeignPpmFormat = 5;
#[doc = " VipsForeignPpmFormat:\n @VIPS_FOREIGN_PPM_FORMAT_PBM: portable bitmap\n @VIPS_FOREIGN_PPM_FORMAT_PGM: portable greymap\n @VIPS_FOREIGN_PPM_FORMAT_PPM: portable pixmap\n @VIPS_FOREIGN_PPM_FORMAT_PFM: portable float map\n @VIPS_FOREIGN_PPM_FORMAT_PNM: portable anymap\n\n The netpbm file format to save as.\n\n #VIPS_FOREIGN_PPM_FORMAT_PBM images are single bit.\n\n #VIPS_FOREIGN_PPM_FORMAT_PGM images are 8, 16, or 32-bits, one band.\n\n #VIPS_FOREIGN_PPM_FORMAT_PPM images are 8, 16, or 32-bits, three bands.\n\n #VIPS_FOREIGN_PPM_FORMAT_PFM images are 32-bit float pixels.\n\n #VIPS_FOREIGN_PPM_FORMAT_PNM images are anymap images -- the image format\n is used to pick the saver.\n"]
pub type VipsForeignPpmFormat = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_ppmload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_ppmload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_ppmsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_ppmsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_radload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_radload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_radload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_radsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_radsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_radsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pdfload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pdfload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pdfload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_svgload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_svgload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_svgload_string(
        str_: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_svgload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gifload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gifload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gifload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gifsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gifsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gifsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_heifload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_heifload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_heifload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_heifsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_heifsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_heifsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_niftiload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_niftiload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_niftisave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jp2kload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jp2kload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jp2kload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jp2ksave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jp2ksave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jp2ksave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jxlload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jxlload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jxlload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jxlsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jxlsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_jxlsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_DZ: VipsForeignDzLayout = 0;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY: VipsForeignDzLayout = 1;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_GOOGLE: VipsForeignDzLayout = 2;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_IIIF: VipsForeignDzLayout = 3;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_IIIF3: VipsForeignDzLayout = 4;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_LAST: VipsForeignDzLayout = 5;
#[doc = " VipsForeignDzLayout:\n @VIPS_FOREIGN_DZ_LAYOUT_DZ: use DeepZoom directory layout\n @VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY: use Zoomify directory layout\n @VIPS_FOREIGN_DZ_LAYOUT_GOOGLE: use Google maps directory layout\n @VIPS_FOREIGN_DZ_LAYOUT_IIIF: use IIIF v2 directory layout\n @VIPS_FOREIGN_DZ_LAYOUT_IIIF3: use IIIF v3 directory layout\n\n What directory layout and metadata standard to use."]
pub type VipsForeignDzLayout = ::std::os::raw::c_uint;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL: VipsForeignDzDepth = 0;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_ONETILE: VipsForeignDzDepth = 1;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_ONE: VipsForeignDzDepth = 2;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_LAST: VipsForeignDzDepth = 3;
#[doc = " VipsForeignDzDepth:\n @VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL: create layers down to 1x1 pixel\n @VIPS_FOREIGN_DZ_DEPTH_ONETILE: create layers down to 1x1 tile\n @VIPS_FOREIGN_DZ_DEPTH_ONE: only create a single layer\n\n How many pyramid layers to create."]
pub type VipsForeignDzDepth = ::std::os::raw::c_uint;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_FS: VipsForeignDzContainer = 0;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_ZIP: VipsForeignDzContainer = 1;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_SZI: VipsForeignDzContainer = 2;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_LAST: VipsForeignDzContainer = 3;
#[doc = " VipsForeignDzContainer:\n @VIPS_FOREIGN_DZ_CONTAINER_FS: write tiles to the filesystem\n @VIPS_FOREIGN_DZ_CONTAINER_ZIP: write tiles to a zip file\n @VIPS_FOREIGN_DZ_CONTAINER_SZI: write to a szi file\n\n How many pyramid layers to create."]
pub type VipsForeignDzContainer = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_dzsave(
        in_: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_dzsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_dzsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_HEVC:
    VipsForeignHeifCompression = 1;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_AVC: VipsForeignHeifCompression =
    2;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_JPEG:
    VipsForeignHeifCompression = 3;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_AV1: VipsForeignHeifCompression =
    4;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_LAST:
    VipsForeignHeifCompression = 5;
#[doc = " VipsForeignHeifCompression:\n @VIPS_FOREIGN_HEIF_COMPRESSION_HEVC: x265\n @VIPS_FOREIGN_HEIF_COMPRESSION_AVC: x264\n @VIPS_FOREIGN_HEIF_COMPRESSION_JPEG: jpeg\n @VIPS_FOREIGN_HEIF_COMPRESSION_AV1: aom\n\n The compression format to use inside a HEIF container.\n\n This is assumed to use the same numbering as %heif_compression_format."]
pub type VipsForeignHeifCompression = ::std::os::raw::c_uint;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_AUTO: VipsForeignHeifEncoder = 0;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_AOM: VipsForeignHeifEncoder = 1;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_RAV1E: VipsForeignHeifEncoder = 2;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_SVT: VipsForeignHeifEncoder = 3;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_X265: VipsForeignHeifEncoder = 4;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_LAST: VipsForeignHeifEncoder = 5;
#[doc = " VipsForeignHeifEncoder:\n @VIPS_FOREIGN_HEIF_ENCODER_AUTO: auto\n @VIPS_FOREIGN_HEIF_ENCODER_AOM: aom\n @VIPS_FOREIGN_HEIF_ENCODER_RAV1E: RAV1E\n @VIPS_FOREIGN_HEIF_ENCODER_SVT: SVT-AV1\n @VIPS_FOREIGN_HEIF_ENCODER_X265: x265\n\n The selected encoder to use.\n If libheif hasn't been compiled with the selected encoder,\n we will fallback to the default encoder for the compression format.\n"]
pub type VipsForeignHeifEncoder = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_operation_math_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_math2_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_round_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_relational_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_boolean_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_complex_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_complex2_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_complexget_get_type() -> GType;
}
extern "C" {
    pub fn vips_precision_get_type() -> GType;
}
extern "C" {
    pub fn vips_intent_get_type() -> GType;
}
extern "C" {
    pub fn vips_pcs_get_type() -> GType;
}
extern "C" {
    pub fn vips_extend_get_type() -> GType;
}
extern "C" {
    pub fn vips_compass_direction_get_type() -> GType;
}
extern "C" {
    pub fn vips_direction_get_type() -> GType;
}
extern "C" {
    pub fn vips_align_get_type() -> GType;
}
extern "C" {
    pub fn vips_angle_get_type() -> GType;
}
extern "C" {
    pub fn vips_angle45_get_type() -> GType;
}
extern "C" {
    pub fn vips_interesting_get_type() -> GType;
}
extern "C" {
    pub fn vips_blend_mode_get_type() -> GType;
}
extern "C" {
    pub fn vips_combine_get_type() -> GType;
}
extern "C" {
    pub fn vips_text_wrap_get_type() -> GType;
}
extern "C" {
    pub fn vips_combine_mode_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_flags_get_type() -> GType;
}
extern "C" {
    pub fn vips_fail_on_get_type() -> GType;
}
extern "C" {
    pub fn vips_saveable_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_keep_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_subsample_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_jpeg_subsample_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_webp_preset_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_tiff_compression_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_tiff_predictor_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_tiff_resunit_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_png_filter_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_ppm_format_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_dz_layout_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_dz_depth_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_dz_container_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_heif_compression_get_type() -> GType;
}
extern "C" {
    pub fn vips_foreign_heif_encoder_get_type() -> GType;
}
extern "C" {
    pub fn vips_demand_style_get_type() -> GType;
}
extern "C" {
    pub fn vips_image_type_get_type() -> GType;
}
extern "C" {
    pub fn vips_interpretation_get_type() -> GType;
}
extern "C" {
    pub fn vips_band_format_get_type() -> GType;
}
extern "C" {
    pub fn vips_coding_get_type() -> GType;
}
extern "C" {
    pub fn vips_access_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_morphology_get_type() -> GType;
}
extern "C" {
    pub fn vips_argument_flags_get_type() -> GType;
}
extern "C" {
    pub fn vips_operation_flags_get_type() -> GType;
}
extern "C" {
    pub fn vips_region_shrink_get_type() -> GType;
}
extern "C" {
    pub fn vips_kernel_get_type() -> GType;
}
extern "C" {
    pub fn vips_size_get_type() -> GType;
}
extern "C" {
    pub fn vips_token_get_type() -> GType;
}
pub const VipsOperationMath_VIPS_OPERATION_MATH_SIN: VipsOperationMath = 0;
pub const VipsOperationMath_VIPS_OPERATION_MATH_COS: VipsOperationMath = 1;
pub const VipsOperationMath_VIPS_OPERATION_MATH_TAN: VipsOperationMath = 2;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ASIN: VipsOperationMath = 3;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ACOS: VipsOperationMath = 4;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ATAN: VipsOperationMath = 5;
pub const VipsOperationMath_VIPS_OPERATION_MATH_LOG: VipsOperationMath = 6;
pub const VipsOperationMath_VIPS_OPERATION_MATH_LOG10: VipsOperationMath = 7;
pub const VipsOperationMath_VIPS_OPERATION_MATH_EXP: VipsOperationMath = 8;
pub const VipsOperationMath_VIPS_OPERATION_MATH_EXP10: VipsOperationMath = 9;
pub const VipsOperationMath_VIPS_OPERATION_MATH_SINH: VipsOperationMath = 10;
pub const VipsOperationMath_VIPS_OPERATION_MATH_COSH: VipsOperationMath = 11;
pub const VipsOperationMath_VIPS_OPERATION_MATH_TANH: VipsOperationMath = 12;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ASINH: VipsOperationMath = 13;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ACOSH: VipsOperationMath = 14;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ATANH: VipsOperationMath = 15;
pub const VipsOperationMath_VIPS_OPERATION_MATH_LAST: VipsOperationMath = 16;
#[doc = " VipsOperationMath:\n @VIPS_OPERATION_MATH_SIN: sin(), angles in degrees\n @VIPS_OPERATION_MATH_COS: cos(), angles in degrees\n @VIPS_OPERATION_MATH_TAN: tan(), angles in degrees\n @VIPS_OPERATION_MATH_ASIN: asin(), angles in degrees\n @VIPS_OPERATION_MATH_ACOS: acos(), angles in degrees\n @VIPS_OPERATION_MATH_ATAN: atan(), angles in degrees\n @VIPS_OPERATION_MATH_LOG: log base e\n @VIPS_OPERATION_MATH_LOG10: log base 10\n @VIPS_OPERATION_MATH_EXP: e to the something\n @VIPS_OPERATION_MATH_EXP10: 10 to the something\n @VIPS_OPERATION_MATH_SINH: sinh(), angles in radians\n @VIPS_OPERATION_MATH_COSH: cosh(), angles in radians\n @VIPS_OPERATION_MATH_TANH: tanh(), angles in radians\n @VIPS_OPERATION_MATH_ASINH: asinh(), angles in radians\n @VIPS_OPERATION_MATH_ACOSH: acosh(), angles in radians\n @VIPS_OPERATION_MATH_ATANH: atanh(), angles in radians\n\n See also: vips_math()."]
pub type VipsOperationMath = ::std::os::raw::c_uint;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_POW: VipsOperationMath2 = 0;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_WOP: VipsOperationMath2 = 1;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_ATAN2: VipsOperationMath2 = 2;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_LAST: VipsOperationMath2 = 3;
#[doc = " VipsOperationMath2:\n @VIPS_OPERATION_MATH2_POW: pow(left, right)\n @VIPS_OPERATION_MATH2_WOP: pow(right, left)\n @VIPS_OPERATION_MATH2_ATAN2: atan2(left, right)\n\n See also: vips_math()."]
pub type VipsOperationMath2 = ::std::os::raw::c_uint;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_RINT: VipsOperationRound = 0;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_CEIL: VipsOperationRound = 1;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_FLOOR: VipsOperationRound = 2;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_LAST: VipsOperationRound = 3;
#[doc = " VipsOperationRound:\n @VIPS_OPERATION_ROUND_RINT: round to nearest\n @VIPS_OPERATION_ROUND_FLOOR: largest integral value not greater than\n @VIPS_OPERATION_ROUND_CEIL: the smallest integral value not less than\n\n See also: vips_round()."]
pub type VipsOperationRound = ::std::os::raw::c_uint;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_EQUAL: VipsOperationRelational = 0;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_NOTEQ: VipsOperationRelational = 1;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_LESS: VipsOperationRelational = 2;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_LESSEQ: VipsOperationRelational = 3;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_MORE: VipsOperationRelational = 4;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_MOREEQ: VipsOperationRelational = 5;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_LAST: VipsOperationRelational = 6;
#[doc = " VipsOperationRelational:\n @VIPS_OPERATION_RELATIONAL_EQUAL: ==\n @VIPS_OPERATION_RELATIONAL_NOTEQ: !=\n @VIPS_OPERATION_RELATIONAL_LESS: <\n @VIPS_OPERATION_RELATIONAL_LESSEQ: <=\n @VIPS_OPERATION_RELATIONAL_MORE: >\n @VIPS_OPERATION_RELATIONAL_MOREEQ: >=\n\n See also: vips_relational()."]
pub type VipsOperationRelational = ::std::os::raw::c_uint;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_AND: VipsOperationBoolean = 0;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_OR: VipsOperationBoolean = 1;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_EOR: VipsOperationBoolean = 2;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_LSHIFT: VipsOperationBoolean = 3;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_RSHIFT: VipsOperationBoolean = 4;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_LAST: VipsOperationBoolean = 5;
#[doc = " VipsOperationBoolean:\n @VIPS_OPERATION_BOOLEAN_AND: &\n @VIPS_OPERATION_BOOLEAN_OR: |\n @VIPS_OPERATION_BOOLEAN_EOR: ^\n @VIPS_OPERATION_BOOLEAN_LSHIFT: >>\n @VIPS_OPERATION_BOOLEAN_RSHIFT: <<\n\n See also: vips_boolean()."]
pub type VipsOperationBoolean = ::std::os::raw::c_uint;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_POLAR: VipsOperationComplex = 0;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_RECT: VipsOperationComplex = 1;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_CONJ: VipsOperationComplex = 2;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_LAST: VipsOperationComplex = 3;
#[doc = " VipsOperationComplex:\n @VIPS_OPERATION_COMPLEX_POLAR: convert to polar coordinates\n @VIPS_OPERATION_COMPLEX_RECT: convert to rectangular coordinates\n @VIPS_OPERATION_COMPLEX_CONJ: complex conjugate\n\n See also: vips_complex()."]
pub type VipsOperationComplex = ::std::os::raw::c_uint;
pub const VipsOperationComplex2_VIPS_OPERATION_COMPLEX2_CROSS_PHASE: VipsOperationComplex2 = 0;
pub const VipsOperationComplex2_VIPS_OPERATION_COMPLEX2_LAST: VipsOperationComplex2 = 1;
#[doc = " VipsOperationComplex2:\n @VIPS_OPERATION_COMPLEX2_CROSS_PHASE: convert to polar coordinates\n\n See also: vips_complex2()."]
pub type VipsOperationComplex2 = ::std::os::raw::c_uint;
pub const VipsOperationComplexget_VIPS_OPERATION_COMPLEXGET_REAL: VipsOperationComplexget = 0;
pub const VipsOperationComplexget_VIPS_OPERATION_COMPLEXGET_IMAG: VipsOperationComplexget = 1;
pub const VipsOperationComplexget_VIPS_OPERATION_COMPLEXGET_LAST: VipsOperationComplexget = 2;
#[doc = " VipsOperationComplexget:\n @VIPS_OPERATION_COMPLEXGET_REAL: get real component\n @VIPS_OPERATION_COMPLEXGET_IMAG: get imaginary component\n\n See also: vips_complexget()."]
pub type VipsOperationComplexget = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_add(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sum(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_subtract(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_multiply(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_divide(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_linear(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: *const f64,
        b: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_linear1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: f64,
        b: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_remainder(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_remainder_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_remainder_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_invert(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_abs(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sign(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_round(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        round: VipsOperationRound,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_floor(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_ceil(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rint(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_math(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math: VipsOperationMath,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sin(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cos(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tan(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_asin(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_acos(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_atan(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_exp(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_exp10(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_log(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_log10(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sinh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cosh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tanh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_asinh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_acosh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_atanh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_complex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        cmplx: VipsOperationComplex,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_polar(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rect(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_conj(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_complex2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        cmplx: VipsOperationComplex2,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cross_phase(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_complexget(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        get: VipsOperationComplexget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_real(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_imag(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_complexform(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_relational(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_equal(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_notequal(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_less(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_lesseq(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_more(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_moreeq(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_relational_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_equal_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_notequal_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_less_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_lesseq_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_more_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_moreeq_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_relational_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_equal_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_notequal_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_less_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_lesseq_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_more_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_moreeq_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_boolean(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_andimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_orimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_eorimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_lshift(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rshift(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_boolean_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_andimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_orimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_eorimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_lshift_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rshift_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_boolean_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_andimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_orimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_eorimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_lshift_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rshift_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_math2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pow(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_wop(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_atan2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_math2_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pow_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_wop_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_atan2_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_math2_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pow_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_wop_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_atan2_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_avg(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_deviate(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_min(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_max(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_stats(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_measure(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        h: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_find_trim(
        in_: *mut VipsImage,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_getpoint(
        in_: *mut VipsImage,
        vector: *mut *mut f64,
        n: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_find(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_find_ndim(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_find_indexed(
        in_: *mut VipsImage,
        index: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hough_line(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hough_circle(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_project(
        in_: *mut VipsImage,
        columns: *mut *mut VipsImage,
        rows: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_profile(
        in_: *mut VipsImage,
        columns: *mut *mut VipsImage,
        rows: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsExtend_VIPS_EXTEND_BLACK: VipsExtend = 0;
pub const VipsExtend_VIPS_EXTEND_COPY: VipsExtend = 1;
pub const VipsExtend_VIPS_EXTEND_REPEAT: VipsExtend = 2;
pub const VipsExtend_VIPS_EXTEND_MIRROR: VipsExtend = 3;
pub const VipsExtend_VIPS_EXTEND_WHITE: VipsExtend = 4;
pub const VipsExtend_VIPS_EXTEND_BACKGROUND: VipsExtend = 5;
pub const VipsExtend_VIPS_EXTEND_LAST: VipsExtend = 6;
pub type VipsExtend = ::std::os::raw::c_uint;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_CENTRE: VipsCompassDirection = 0;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_NORTH: VipsCompassDirection = 1;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_EAST: VipsCompassDirection = 2;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_SOUTH: VipsCompassDirection = 3;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_WEST: VipsCompassDirection = 4;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_NORTH_EAST: VipsCompassDirection = 5;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_SOUTH_EAST: VipsCompassDirection = 6;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_SOUTH_WEST: VipsCompassDirection = 7;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_NORTH_WEST: VipsCompassDirection = 8;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_LAST: VipsCompassDirection = 9;
pub type VipsCompassDirection = ::std::os::raw::c_uint;
pub const VipsDirection_VIPS_DIRECTION_HORIZONTAL: VipsDirection = 0;
pub const VipsDirection_VIPS_DIRECTION_VERTICAL: VipsDirection = 1;
pub const VipsDirection_VIPS_DIRECTION_LAST: VipsDirection = 2;
pub type VipsDirection = ::std::os::raw::c_uint;
pub const VipsAlign_VIPS_ALIGN_LOW: VipsAlign = 0;
pub const VipsAlign_VIPS_ALIGN_CENTRE: VipsAlign = 1;
pub const VipsAlign_VIPS_ALIGN_HIGH: VipsAlign = 2;
pub const VipsAlign_VIPS_ALIGN_LAST: VipsAlign = 3;
pub type VipsAlign = ::std::os::raw::c_uint;
pub const VipsAngle_VIPS_ANGLE_D0: VipsAngle = 0;
pub const VipsAngle_VIPS_ANGLE_D90: VipsAngle = 1;
pub const VipsAngle_VIPS_ANGLE_D180: VipsAngle = 2;
pub const VipsAngle_VIPS_ANGLE_D270: VipsAngle = 3;
pub const VipsAngle_VIPS_ANGLE_LAST: VipsAngle = 4;
pub type VipsAngle = ::std::os::raw::c_uint;
pub const VipsAngle45_VIPS_ANGLE45_D0: VipsAngle45 = 0;
pub const VipsAngle45_VIPS_ANGLE45_D45: VipsAngle45 = 1;
pub const VipsAngle45_VIPS_ANGLE45_D90: VipsAngle45 = 2;
pub const VipsAngle45_VIPS_ANGLE45_D135: VipsAngle45 = 3;
pub const VipsAngle45_VIPS_ANGLE45_D180: VipsAngle45 = 4;
pub const VipsAngle45_VIPS_ANGLE45_D225: VipsAngle45 = 5;
pub const VipsAngle45_VIPS_ANGLE45_D270: VipsAngle45 = 6;
pub const VipsAngle45_VIPS_ANGLE45_D315: VipsAngle45 = 7;
pub const VipsAngle45_VIPS_ANGLE45_LAST: VipsAngle45 = 8;
pub type VipsAngle45 = ::std::os::raw::c_uint;
pub const VipsInteresting_VIPS_INTERESTING_NONE: VipsInteresting = 0;
pub const VipsInteresting_VIPS_INTERESTING_CENTRE: VipsInteresting = 1;
pub const VipsInteresting_VIPS_INTERESTING_ENTROPY: VipsInteresting = 2;
pub const VipsInteresting_VIPS_INTERESTING_ATTENTION: VipsInteresting = 3;
pub const VipsInteresting_VIPS_INTERESTING_LOW: VipsInteresting = 4;
pub const VipsInteresting_VIPS_INTERESTING_HIGH: VipsInteresting = 5;
pub const VipsInteresting_VIPS_INTERESTING_ALL: VipsInteresting = 6;
pub const VipsInteresting_VIPS_INTERESTING_LAST: VipsInteresting = 7;
pub type VipsInteresting = ::std::os::raw::c_uint;
pub const VipsBlendMode_VIPS_BLEND_MODE_CLEAR: VipsBlendMode = 0;
pub const VipsBlendMode_VIPS_BLEND_MODE_SOURCE: VipsBlendMode = 1;
pub const VipsBlendMode_VIPS_BLEND_MODE_OVER: VipsBlendMode = 2;
pub const VipsBlendMode_VIPS_BLEND_MODE_IN: VipsBlendMode = 3;
pub const VipsBlendMode_VIPS_BLEND_MODE_OUT: VipsBlendMode = 4;
pub const VipsBlendMode_VIPS_BLEND_MODE_ATOP: VipsBlendMode = 5;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST: VipsBlendMode = 6;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_OVER: VipsBlendMode = 7;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_IN: VipsBlendMode = 8;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_OUT: VipsBlendMode = 9;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_ATOP: VipsBlendMode = 10;
pub const VipsBlendMode_VIPS_BLEND_MODE_XOR: VipsBlendMode = 11;
pub const VipsBlendMode_VIPS_BLEND_MODE_ADD: VipsBlendMode = 12;
pub const VipsBlendMode_VIPS_BLEND_MODE_SATURATE: VipsBlendMode = 13;
pub const VipsBlendMode_VIPS_BLEND_MODE_MULTIPLY: VipsBlendMode = 14;
pub const VipsBlendMode_VIPS_BLEND_MODE_SCREEN: VipsBlendMode = 15;
pub const VipsBlendMode_VIPS_BLEND_MODE_OVERLAY: VipsBlendMode = 16;
pub const VipsBlendMode_VIPS_BLEND_MODE_DARKEN: VipsBlendMode = 17;
pub const VipsBlendMode_VIPS_BLEND_MODE_LIGHTEN: VipsBlendMode = 18;
pub const VipsBlendMode_VIPS_BLEND_MODE_COLOUR_DODGE: VipsBlendMode = 19;
pub const VipsBlendMode_VIPS_BLEND_MODE_COLOUR_BURN: VipsBlendMode = 20;
pub const VipsBlendMode_VIPS_BLEND_MODE_HARD_LIGHT: VipsBlendMode = 21;
pub const VipsBlendMode_VIPS_BLEND_MODE_SOFT_LIGHT: VipsBlendMode = 22;
pub const VipsBlendMode_VIPS_BLEND_MODE_DIFFERENCE: VipsBlendMode = 23;
pub const VipsBlendMode_VIPS_BLEND_MODE_EXCLUSION: VipsBlendMode = 24;
pub const VipsBlendMode_VIPS_BLEND_MODE_LAST: VipsBlendMode = 25;
pub type VipsBlendMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_copy(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tilecache(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_linecache(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sequential(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cache(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_copy_file(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_embed(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gravity(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsCompassDirection,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_flip(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_insert(
        main: *mut VipsImage,
        sub: *mut VipsImage,
        out: *mut *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_join(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_arrayjoin(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_extract_area(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_crop(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_smartcrop(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_extract_band(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        band: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_replicate(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        across: ::std::os::raw::c_int,
        down: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_grid(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        tile_height: ::std::os::raw::c_int,
        across: ::std::os::raw::c_int,
        down: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_transpose3d(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_wrap(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        angle: VipsAngle,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rot90(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rot180(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rot270(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rot45(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_autorot_remove_angle(image: *mut VipsImage);
}
extern "C" {
    pub fn vips_autorot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_zoom(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        xfac: ::std::os::raw::c_int,
        yfac: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_subsample(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        xfac: ::std::os::raw::c_int,
        yfac: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        format: VipsBandFormat,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_uchar(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_char(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_ushort(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_short(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_uint(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_int(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_float(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_double(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_complex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_cast_dpcomplex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_scale(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_msb(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_byteswap(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandjoin(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandjoin2(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandjoin_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandjoin_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandrank(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandfold(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandunfold(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandbool(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandand(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandor(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandeor(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_bandmean(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_recomb(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        m: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_ifthenelse(
        cond: *mut VipsImage,
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_switch(
        tests: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_flatten(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_addalpha(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_premultiply(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_unpremultiply(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_composite(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        mode: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_composite2(
        base: *mut VipsImage,
        overlay: *mut VipsImage,
        out: *mut *mut VipsImage,
        mode: VipsBlendMode,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_falsecolour(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gamma(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsCombine_VIPS_COMBINE_MAX: VipsCombine = 0;
pub const VipsCombine_VIPS_COMBINE_SUM: VipsCombine = 1;
pub const VipsCombine_VIPS_COMBINE_MIN: VipsCombine = 2;
pub const VipsCombine_VIPS_COMBINE_LAST: VipsCombine = 3;
pub type VipsCombine = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_conv(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_convf(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_convi(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_conva(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_convsep(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_convasep(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_compass(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gaussblur(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        sigma: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sharpen(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_spcor(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_fastcor(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sobel(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_scharr(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_prewitt(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_canny(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsOperationMorphology_VIPS_OPERATION_MORPHOLOGY_ERODE: VipsOperationMorphology = 0;
pub const VipsOperationMorphology_VIPS_OPERATION_MORPHOLOGY_DILATE: VipsOperationMorphology = 1;
pub const VipsOperationMorphology_VIPS_OPERATION_MORPHOLOGY_LAST: VipsOperationMorphology = 2;
pub type VipsOperationMorphology = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_morph(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        morph: VipsOperationMorphology,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rank(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_median(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        size: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_countlines(
        in_: *mut VipsImage,
        nolines: *mut f64,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_labelregions(
        in_: *mut VipsImage,
        mask: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_fill_nearest(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_merge(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mosaic(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        xref: ::std::os::raw::c_int,
        yref: ::std::os::raw::c_int,
        xsec: ::std::os::raw::c_int,
        ysec: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mosaic1(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xs1: ::std::os::raw::c_int,
        ys1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
        xs2: ::std::os::raw::c_int,
        ys2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_match(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xs1: ::std::os::raw::c_int,
        ys1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
        xs2: ::std::os::raw::c_int,
        ys2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_globalbalance(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_remosaic(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        old_str: *const ::std::os::raw::c_char,
        new_str: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_matrixinvert(
        m: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_maplut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        lut: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_percent(
        in_: *mut VipsImage,
        percent: f64,
        threshold: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_stdif(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_cum(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_norm(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_equal(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_plot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_match(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_local(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_ismonotonic(
        in_: *mut VipsImage,
        out: *mut gboolean,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_hist_entropy(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_case(
        index: *mut VipsImage,
        cases: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_fwfft(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_invfft(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_freqmult(
        in_: *mut VipsImage,
        mask: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_spectrum(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_phasecor(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsKernel_VIPS_KERNEL_NEAREST: VipsKernel = 0;
pub const VipsKernel_VIPS_KERNEL_LINEAR: VipsKernel = 1;
pub const VipsKernel_VIPS_KERNEL_CUBIC: VipsKernel = 2;
pub const VipsKernel_VIPS_KERNEL_MITCHELL: VipsKernel = 3;
pub const VipsKernel_VIPS_KERNEL_LANCZOS2: VipsKernel = 4;
pub const VipsKernel_VIPS_KERNEL_LANCZOS3: VipsKernel = 5;
pub const VipsKernel_VIPS_KERNEL_LAST: VipsKernel = 6;
pub type VipsKernel = ::std::os::raw::c_uint;
pub const VipsSize_VIPS_SIZE_BOTH: VipsSize = 0;
pub const VipsSize_VIPS_SIZE_UP: VipsSize = 1;
pub const VipsSize_VIPS_SIZE_DOWN: VipsSize = 2;
pub const VipsSize_VIPS_SIZE_FORCE: VipsSize = 3;
pub const VipsSize_VIPS_SIZE_LAST: VipsSize = 4;
pub type VipsSize = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_shrink(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_shrinkh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_shrinkv(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        vshrink: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_reduce(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_reduceh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_reducev(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_thumbnail(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_thumbnail_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_thumbnail_image(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_thumbnail_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_similarity(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rotate(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        angle: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_affine(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_resize(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        scale: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mapim(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        index: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_quadratic(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        coeff: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsIntent_VIPS_INTENT_PERCEPTUAL: VipsIntent = 0;
pub const VipsIntent_VIPS_INTENT_RELATIVE: VipsIntent = 1;
pub const VipsIntent_VIPS_INTENT_SATURATION: VipsIntent = 2;
pub const VipsIntent_VIPS_INTENT_ABSOLUTE: VipsIntent = 3;
pub const VipsIntent_VIPS_INTENT_LAST: VipsIntent = 4;
pub type VipsIntent = ::std::os::raw::c_uint;
pub const VipsPCS_VIPS_PCS_LAB: VipsPCS = 0;
pub const VipsPCS_VIPS_PCS_XYZ: VipsPCS = 1;
pub const VipsPCS_VIPS_PCS_LAST: VipsPCS = 2;
pub type VipsPCS = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_colourspace_issupported(image: *const VipsImage) -> gboolean;
}
extern "C" {
    pub fn vips_colourspace(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        space: VipsInterpretation,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LabQ2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_rad2float(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_float2rad(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LabS2LabQ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LabQ2LabS(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LabQ2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_Lab2LabQ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LCh2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_Lab2LCh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_Yxy2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_CMC2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_Lab2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_XYZ2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_XYZ2scRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_scRGB2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_scRGB2BW(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sRGB2scRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_scRGB2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_HSV2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sRGB2HSV(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LCh2CMC(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_CMC2LCh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_XYZ2Yxy(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_Yxy2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_LabS2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_Lab2LabS(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_CMYK2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_XYZ2CMYK(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_profile_load(
        name: *const ::std::os::raw::c_char,
        profile: *mut *mut VipsBlob,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_icc_present() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_icc_transform(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        output_profile: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_icc_import(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_icc_export(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_icc_ac2rc(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        profile_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_icc_is_compatible_profile(
        image: *mut VipsImage,
        data: *const ::std::os::raw::c_void,
        data_length: size_t,
    ) -> gboolean;
}
extern "C" {
    pub fn vips_dE76(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_dE00(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_dECMC(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_Lab2XYZ(L: f32, a: f32, b: f32, X: *mut f32, Y: *mut f32, Z: *mut f32);
}
extern "C" {
    pub fn vips_col_XYZ2Lab(X: f32, Y: f32, Z: f32, L: *mut f32, a: *mut f32, b: *mut f32);
}
extern "C" {
    pub fn vips_col_ab2h(a: f64, b: f64) -> f64;
}
extern "C" {
    pub fn vips_col_ab2Ch(a: f32, b: f32, C: *mut f32, h: *mut f32);
}
extern "C" {
    pub fn vips_col_Ch2ab(C: f32, h: f32, a: *mut f32, b: *mut f32);
}
extern "C" {
    pub fn vips_col_L2Lcmc(L: f32) -> f32;
}
extern "C" {
    pub fn vips_col_C2Ccmc(C: f32) -> f32;
}
extern "C" {
    pub fn vips_col_Ch2hcmc(C: f32, h: f32) -> f32;
}
extern "C" {
    pub fn vips_col_make_tables_CMC();
}
extern "C" {
    pub fn vips_col_Lcmc2L(Lcmc: f32) -> f32;
}
extern "C" {
    pub fn vips_col_Ccmc2C(Ccmc: f32) -> f32;
}
extern "C" {
    pub fn vips_col_Chcmc2h(C: f32, hcmc: f32) -> f32;
}
extern "C" {
    pub fn vips_col_sRGB2scRGB_8(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_sRGB2scRGB_16(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_sRGB2scRGB_8_noclip(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_sRGB2scRGB_16_noclip(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_scRGB2XYZ(
        R: f32,
        G: f32,
        B: f32,
        X: *mut f32,
        Y: *mut f32,
        Z: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_XYZ2scRGB(
        X: f32,
        Y: f32,
        Z: f32,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_scRGB2sRGB_8(
        R: f32,
        G: f32,
        B: f32,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_scRGB2sRGB_16(
        R: f32,
        G: f32,
        B: f32,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_scRGB2BW_16(
        R: f32,
        G: f32,
        B: f32,
        g: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_col_scRGB2BW_8(
        R: f32,
        G: f32,
        B: f32,
        g: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_pythagoras(L1: f32, a1: f32, b1: f32, L2: f32, a2: f32, b2: f32) -> f32;
}
extern "C" {
    pub fn vips_col_dE00(L1: f32, a1: f32, b1: f32, L2: f32, a2: f32, b2: f32) -> f32;
}
pub const VipsCombineMode_VIPS_COMBINE_MODE_SET: VipsCombineMode = 0;
pub const VipsCombineMode_VIPS_COMBINE_MODE_ADD: VipsCombineMode = 1;
pub const VipsCombineMode_VIPS_COMBINE_MODE_LAST: VipsCombineMode = 2;
pub type VipsCombineMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_draw_rect(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_rect1(
        image: *mut VipsImage,
        ink: f64,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_point(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_point1(
        image: *mut VipsImage,
        ink: f64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_image(
        image: *mut VipsImage,
        sub: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_mask(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        mask: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_mask1(
        image: *mut VipsImage,
        ink: f64,
        mask: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_line(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_line1(
        image: *mut VipsImage,
        ink: f64,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_circle(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_circle1(
        image: *mut VipsImage,
        ink: f64,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_flood(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_flood1(
        image: *mut VipsImage,
        ink: f64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_draw_smudge(
        image: *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsTextWrap_VIPS_TEXT_WRAP_WORD: VipsTextWrap = 0;
pub const VipsTextWrap_VIPS_TEXT_WRAP_CHAR: VipsTextWrap = 1;
pub const VipsTextWrap_VIPS_TEXT_WRAP_WORD_CHAR: VipsTextWrap = 2;
pub const VipsTextWrap_VIPS_TEXT_WRAP_NONE: VipsTextWrap = 3;
pub const VipsTextWrap_VIPS_TEXT_WRAP_LAST: VipsTextWrap = 4;
pub type VipsTextWrap = ::std::os::raw::c_uint;
extern "C" {
    pub fn vips_black(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_xyz(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_grey(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gaussmat(
        out: *mut *mut VipsImage,
        sigma: f64,
        min_ampl: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_logmat(
        out: *mut *mut VipsImage,
        sigma: f64,
        min_ampl: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_text(
        out: *mut *mut VipsImage,
        text: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_gaussnoise(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_eye(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_sines(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_zone(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_identity(out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_buildlut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_invertlut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_tonelut(out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_ideal(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_ideal_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_ideal_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_butterworth(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_butterworth_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_butterworth_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_gaussian(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_gaussian_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_gaussian_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_mask_fractal(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fractal_dimension: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_fractsurf(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fractal_dimension: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_worley(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_perlin(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_video_v4l1(
        im: *mut VipsImage,
        device: *const ::std::os::raw::c_char,
        channel: ::std::os::raw::c_int,
        brightness: ::std::os::raw::c_int,
        colour: ::std::os::raw::c_int,
        contrast: ::std::os::raw::c_int,
        hue: ::std::os::raw::c_int,
        ngrabs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn im_video_test(
        im: *mut VipsImage,
        brightness: ::std::os::raw::c_int,
        error: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_init(argv0: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_get_argv0() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_get_prgname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_shutdown();
}
extern "C" {
    pub fn vips_thread_shutdown();
}
extern "C" {
    pub fn vips_add_option_entries(option_group: *mut GOptionGroup);
}
extern "C" {
    pub fn vips_leak_set(leak: gboolean);
}
extern "C" {
    pub fn vips_block_untrusted_set(state: gboolean);
}
extern "C" {
    pub fn vips_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_version(flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vips_guess_prefix(
        argv0: *const ::std::os::raw::c_char,
        env_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vips_guess_libdir(
        argv0: *const ::std::os::raw::c_char,
        env_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
